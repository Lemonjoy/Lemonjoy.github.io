<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[12-整数转罗马数字]]></title>
    <url>%2F2020%2F01%2F12%2F12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 |通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 示例1234示例 1:输入: 3输出: &quot;III&quot; 1234示例 2:输入: 4输出: &quot;IV&quot; 1234示例 3:输入: 9输出: &quot;IX&quot; 12345示例 4:输入: 58输出: &quot;LVIII&quot;解释: L = 50, V = 5, III = 3. 12345示例 5:输入: 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4. 解法 核心思想：使用贪心算法 123456789101112131415161718192021222324252627class Solution: def intToRoman(self, num: int) -&gt; str: num_dict = &#123;1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'&#125; res = "" # 贪心算法，将字典逆置，从大的开始除 for key in sorted(num_dict.keys())[::-1]: if(num == 0): break tmp = num//key if(tmp == 0): continue res += num_dict[key] * (tmp) # 更新num值 num -= key*(tmp) return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11-盛最多水的容器]]></title>
    <url>%2F2020%2F01%2F11%2F11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例123输入: [1,8,6,2,5,4,8,3,7]输出: 49 解法 核心思想：只有相对短的一边向内收缩才有可能使得面积变大 12345678910111213class Solution: def maxArea(self, height: List[int]) -&gt; int: left, right, res = 0, len(height)-1, 0 while (left &lt; right): # 判断是否需要更新最大面积 if min(height[left], height[right])*(right-left) &gt; res: res = min(height[left], height[right]) * (right - left) # 使得短的一端向内收缩 if height[left] &lt; height[right]: left += 1 else: right -= 1 return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10-正则表达式匹配]]></title>
    <url>%2F2020%2F01%2F10%2F10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 字符 匹配规则 . 匹配任意单个字符 * 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例12345示例 1:输入: s = &quot;aa&quot; p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 12345示例 2:输入: s = &quot;aa&quot; p = &quot;a*&quot;输出: true解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。 12345示例 3:输入: s = &quot;ab&quot; p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。 12345示例 4:输入: s = &quot;aab&quot; p = &quot;c*a*b&quot;输出: true解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 1234示例 5:输入: s = &quot;mississippi&quot; p = &quot;mis*is*p*.&quot;输出: false 解法12345678910111213class Solution: def isMatch(self, text: str, pattern: str) -&gt; bool: # 递归边界： if not pattern: return not text # text 非空并且p[0]==s[0]或者“.” first = bool(text) and pattern[0] in &#123;text[0], '.'&#125; # 处理带星号的问题 if len(pattern) &gt;= 2 and pattern[1] == '*': return self.isMatch(text, pattern[2:]) or first and self.isMatch(text[1:], pattern) else: # 正常递归 return first and self.isMatch(text[1:], pattern[1:]) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9-回文数]]></title>
    <url>%2F2020%2F01%2F09%2F9-%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例1234示例 1:输入: 121输出: true 12345示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 12345示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 解法直接转换成字符串对比即可。 123class Solution: def isPalindrome(self, x: int) -&gt; bool: return True if str(x)==str(x)[::-1] else False 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-字符串转换整数]]></title>
    <url>%2F2020%2F01%2F08%2F8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。 示例1234示例 1:输入: &quot;42&quot;输出: 42 1234567示例 2:输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 123456示例 3:输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 123456示例 4:输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。因此无法执行有效的转换。 123456示例 5:输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解法-常规该题解法很容易想到，只是有很多小细节需要注意。 123456789101112131415161718192021222324252627282930class Solution: def myAtoi(self, s: str) -&gt; int: str_ = s.strip() # 去掉字符串的空白 if len(str_) == 0: # 空字符串 return 0 nums_ls = [str(i) for i in range(10)] symbols_ls = ["-", "+"] # 判断首个字符 if str_[0]not in nums_ls and str_[0] not in symbols_ls: return 0 else: res = str_[0] # 判断后面的字符 for i in str_[1:]: if i in nums_ls: res += i else: break try: # 只有正负号时，返回0 res = int(res) except: return 0 # if res &gt; 2147483647: # return 2147483647 # elif res &lt; -2147483648: # return -2147483648 # else: # return res # 功能同上面注释部分，不过更加优雅 return min(max(res, -2147483648), 2147483647) 解法-正则利用正则表达式，来提取有效字符串。 正则 含义 ^ 匹配字符串开头 [+-] 代表一个+字符或-字符 ? 前面一个字符可有可无 \d 一个数字 + 前面一个字符的一个或多个 * 前面一个字符的零个或多个 123class Solution: def myAtoi(self, s: str) -&gt; int: return max(min(int(*re.findall('^[\+\-]?\d+', s.lstrip())), 2**31 - 1), -2**31) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-整数反转]]></title>
    <url>%2F2020%2F01%2F07%2F7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例1234示例 1:输入: 123输出: 321 1234示例 2:输入: -123输出: -321 1234示例 3:输入: 120输出: 21 123注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解法 核心思路：int -&gt; abs(int) -&gt; str[::-1] -&gt; int 12345678910class Solution: def reverse(self, x: int) -&gt; int: y = abs(x) k = int(str(y)[::-1]) if k &gt; 2147483647: return 0 elif x &gt; 0: return k else: return k*(-1) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode刷题笔记]]></title>
    <url>%2F2020%2F01%2F07%2FLeetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[所有刷题笔记内容的汇总，与个人总结。 # 题目 难度 标签 源码文件 博客文章 001 两数之和 简单 数组；哈希表 Python3.5.2 :memo: 002 两数相加 中等 链表；数学 Python3.5.2 :memo: 003 无重复字符的最长子串 中等 字符串；滑动窗口 Python3.5.2 :memo: 004 寻找两个有序数组的中位数 困难 数组；分治算法 Python3.5.2 :memo: 005 最长回文子串 中等 字符串；动态规划；中心扩展 Python3.5.2 :memo: 006 Z字形变换 中等 字符串 Python3.5.2 :memo: 007 008]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.Z字形变换]]></title>
    <url>%2F2020%2F01%2F06%2F6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： 123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。 示例1234示例 1:输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 1234示例 2:输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot; 123456解释:L D RE O E I IE C I H NT S G 解法 Key Point：巧妙利用flag实现触碰到边界时进行“回弹”的效果 1234567891011121314class Solution: def convert(self, s: str, numRows: int) -&gt; str: if numRows&lt;2: # 该算法在小于2时，直接返回即可 return s # 初始化一个长度为numRows的列表 ls = ["" for _ in range(numRows)] flag, i = -1, 0 for string in s: ls[i] += string # i等于0或者numRows-1时，改变方向 if i % (numRows-1) == 0: flag = -flag i += flag return "".join(ls) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.最长回文子串]]></title>
    <url>%2F2020%2F01%2F05%2F5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例12345示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 1234示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot; 解法1-中心扩展我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。 由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 n+n-1 个中心。 时间复杂度：O(n²） 空间复杂度：O(1） 代码12345678910111213141516171819class Solution: # 中心扩展 def expandAroundCenter(self,s: str,left:int,right:int) -&gt; str: L, R = left, right while L&gt;= 0 and R&lt; len(s) and s[L]==s[R]: L -= 1 R += 1 return s[L+1:R] # 求最长回文子串 def longestPalindrome(self, s: str) -&gt; str: if len(s) &lt;= 1: # 长度小于等于1直接返回原字符串 return s res = s[:1] # 初始化result为字符串首位 for i in range(len(s)): len1 = self.expandAroundCenter(s, i, i) len2 = self.expandAroundCenter(s, i, i + 1) # 迭代res使其成为最长的子串 res = max(len1,len2,res,key=len) return res 2-马拉车算法（Manacher’s Algorithm）Manacher‘s Algorithm是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。 首先我们解决下奇数和偶数的问题，在每个字符间插入 “#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。 首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 “#” 的原字符串的总长度。例如下图中下标是 6 的地方，可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 “#c#b#c#b#c#”。而去掉 # 恢复到原来的字符串，变成 “cbcbc”，它的长度刚好也就是 5。 求原字符串下标用 P 的下标 i 减去 P [ i ]，再除以 2，就是原字符串的开头下标了。 例如我们找到 P[ i ] 的最大值为 5，也就是回文串的最大长度是 5，对应的下标是 6，所以原字符串的开头下标是（6 - 5 ）/ 2 = 0。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。 求每个 P [ i ]接下来是算法的关键了，它充分利用了回文串的对称性。 我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。 让我们考虑求 P [ i ] 的时候，如下图。 用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。 我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。 但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。 超出了 R 当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。 P [ i_mirror ] 遇到了原字符串的左边界 此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#”，之后遇到了 “^” 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。 i 等于了 R此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。 考虑 C 和 R 的更新就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。 此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。 作者：windliang|链接地址 代码12345678910111213141516171819202122class Solution: # 马拉车算法 def longestPalindrome(self, s: str) -&gt; str: if len(s) &lt; 2: return s # 将一个可能是偶数长/奇数长的字符串，首位以及每个字符间添加# test = '#'+'#'.join(s)+'#' # 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度 max_len = 0 for i in range(len(test)): left = i - 1 right = i + 1 step = 0 while left &gt;= 0 and right &lt; len(test) and test[left] == test[right]: left -= 1 right += 1 step += 1 # 找到合适的起点位置 if step &gt; max_len: max_len = step start = (i - max_len) // 2 return s[start: start + max_len] 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>中心扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.寻找两个有序数组的中位数]]></title>
    <url>%2F2020%2F01%2F04%2F4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 示例1234567示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0 1234567示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 解法核心方法分别在num1和num2切割，找到满足Lmax1&lt;Rmin2且Lmax2&lt;Rmin的位置。 奇偶问题两个数组合并后的长度，有可能是偶数，也有可能是奇数。如果可以让数组长度总是为偶数，那么就可以用公式覆盖。 通过虚拟加入&quot;#&quot;，让每个数组的长度都变成 2x + 1，所以 n+m -&gt; 2n + 2m + 2，恒为偶数。 转换后，原始的元素可以通过新下标//2得到。 比如9，原来是3位，现在是7位， 7//2=3 而对于割，如果‘#’上等于割在2个元素之间，割在数字上等于把数字划到2个部分，总是有以下成立： 12LMaxi = (Ci-1)/2 位置上的元素RMini = Ci/2 位置上的元素 点击查看详细 代码1234567891011121314151617181920212223242526272829class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: m = len(nums1) n = len(nums2) # 使得num2成为更长的表 if n &lt; m: return self.findMedianSortedArrays(nums2, nums1) start_pos = 0 end_pos = 2 * m while start_pos &lt;= end_pos: c1 = (start_pos + end_pos) // 2 c2 = m + n - c1 # 因为数组从0开始，所以c1+c2=(m+n+1)-1 # 切割nums1 LMax1 = nums1[(c1 - 1) // 2] if c1 &gt; 0 else (-1 * sys.maxsize) RMin1 = nums1[c1 // 2] if c1 &lt; 2 * n else sys.maxsize # 切割nums2 LMax2 = nums2[(c2 - 1) // 2] if c2 &gt; 0 else (-1 * sys.maxsize) RMin2 = nums2[c2 // 2] if c2 &lt; 2 * m else sys.maxsize # 不满足LMax&lt;RMin 则进行调整切割位置 if LMax1 &gt; RMin2: end_pos = c1 - 1 elif LMax2 &gt; RMin1: start_pos = c1 + 1 else: # 找到合适的c1 break # 返回中位数 return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.无重复字符的最长子串]]></title>
    <url>%2F2020%2F01%2F03%2F3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 示例示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解法这道题主要用到思路是：滑动窗口 什么是滑动窗口？ 其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！ 如何移动？ 我们只要找到那个相同元素的位置，把队列中它左边的元素移出就行了，直到满足题目要求！ 一直维持这样的队列，找出队列出现最长的长度时候，求出解！ 12345678910111213141516171819202122class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if not s:return 0 # 如果字符串s为空，返回0 lookup = [] # 初始化窗口 max_len = 0 # 窗口长度 cur_len = 0 # 当前子串长度 for i in range(len(s)): # 遍历字符串s val = s[i] if not val in lookup: # 如果该值不在窗口中 lookup.append(val) # 添加到窗口内 cur_len += 1 # 当前长度+1 else:# 如果该值在窗口中已存在 index = lookup.index(val) # 获取其在窗口中的位置 lookup = lookup[index+1:] # 移除该位置及之前的字符 lookup.append(val) cur_len = len(lookup) # 当前长度更新为窗口长度 if cur_len &gt; max_len: # 看是否需要更新最大长度值 max_len = cur_len return max_len # 返回最大子串长度 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.两数相加]]></title>
    <url>%2F2020%2F01%2F03%2F2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 解法1将链表转换成字符串，方便进行逆置操作；最后再讲字符串转换成链表。 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: def ln2str(ln: ListNode):#链表转换为字符串 if ln.next == None: return str(ln.val) else: return str(ln.val) + str(ln2str(ln.next)) def str2ln(str_res: str):#字符串转换成链表 if len(str_res)==1: return ListNode(int(str_res)) else: ln_temp = ListNode(int(str_res[0])) ln_temp.next = str2ln(str_res[1:]) return ln_temp str1 = ln2str(l1)[::-1] #将链表1转换为字符串并逆置 str2 = ln2str(l2)[::-1] #将链表2转换为字符串并逆置 str_res = str(int(str1)+int(str2))[::-1] #相加后转换为字符串，逆置 return str2ln(str_res) #返回转换成的链表 解法2把两个数按位相加，并存到一个新的链表中，使用carry保存是否需要进位。 1234567891011121314151617181920# 官方解法class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: dummyHead = ListNode(0) # 建立一个头结点 curr, carry = dummyHead, 0 #curr表当前结点；carry表进位 while l1 or l2: # 不全为空 sum = 0 if l1: # l1非空 sum += l1.val l1 = l1.next if l2: # l2非空 sum += l2.val l2 = l2.next sum += carry carry = sum // 10 curr.next = ListNode(sum % 10) curr = curr.next if carry &gt; 0: # 需要进位，使得链表加长 curr.next = ListNode(1) return dummyHead.next; #返回除头结点之后链表 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.两数之和]]></title>
    <url>%2F2020%2F01%2F02%2F1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例1给定 nums = [2, 7, 11, 15], target = 9 12因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法通过哈希来求解，这里通过字典来模拟哈希查询的过程。 1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashmap=&#123;&#125; for i,num in enumerate(nums): if hashmap.get(target - num) is not None: # 当前字典中找到对应key return [i,hashmap.get(target - num)] hashmap[num] = i # 未找到则将其加入字典中 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[基于C/C++二叉树的构建与操作。 二叉树-递归实现 树的结点1234567typedef int BT_ElemType;//树的结点结构typedef struct BTNode&#123; BT_ElemType data; BTNode *L_child, *R_child;//左右孩子结点的指针&#125; BTNode; 树的创建1234567891011121314151617181920BTNode *BiTree_Create()&#123; BT_ElemType data; scanf("%d", &amp;data);//手动输入树的结点值 BTNode *T; if (data == 0) //当遇到0时，令树的根节点为NULL，从而结束该分支的递归 &#123; T = NULL;//空分支 return T; &#125; else &#123; T = (BTNode *)malloc(sizeof(BTNode));//创建新的树节点 //先序创建树 T-&gt;data = data;//先给根节点赋值 T-&gt;L_child = BiTree_Create();//创建左子树 T-&gt;R_child = BiTree_Create();//创建右子树 &#125; return T;&#125; 访问结点数据12345//访问节点数据void BiTree_Vist_Node(BTNode *T)&#123; printf("%d ", T-&gt;data);&#125; 前序遍历12345678910//前序遍历void BiTree_Preorder_Traversal(BTNode *T)&#123; if (T) &#123; BiTree_Vist_Node(T); BiTree_Preorder_Traversal(T-&gt;L_child); BiTree_Preorder_Traversal(T-&gt;R_child); &#125;&#125; 中序遍历12345678910//中序遍历void BiTree_Inorder_Traversal(BTNode *T)&#123; if (T) &#123; BiTree_Inorder_Traversal(T-&gt;L_child); BiTree_Vist_Node(T); BiTree_Inorder_Traversal(T-&gt;R_child); &#125;&#125; 后序遍历12345678910//后序遍历void BiTree_Postorder_Traversal(BTNode *T)&#123; if (T) &#123; BiTree_Postorder_Traversal(T-&gt;L_child); BiTree_Postorder_Traversal(T-&gt;R_child); BiTree_Vist_Node(T); &#125;&#125; 双序遍历1234567891011//二叉树的双序遍历void BiTree_DblOrder_Traverse(BTNode *T)&#123; if(T) &#123; BiTree_Vist_Node(T); BiTree_DblOrder_Traverse(T-&gt;L_child); BiTree_Vist_Node(T); BiTree_DblOrder_Traverse(T-&gt;R_child); &#125;&#125; 树的复制123456789101112131415//二叉树的复制void BiTree_Copy(BTNode *T, BTNode *NewT)&#123; if (T == NULL) &#123; NewT = NULL; &#125; else &#123; NewT = (BTNode *)malloc(sizeof(BTNode)); NewT-&gt;data = T-&gt;data; BiTree_Copy(T-&gt;L_child, NewT-&gt;L_child); BiTree_Copy(T-&gt;R_child, NewT-&gt;R_child); &#125;&#125; 树的深度123456789101112131415//树的深度int BiTree_Depth(BTNode *T)&#123; if (T == NULL) return 0; else &#123; int m = BiTree_Depth(T-&gt;L_child); int n = BiTree_Depth(T-&gt;R_child); if (m &gt; n) return (m + 1); else return (n + 1); &#125;&#125; 结点个数12345678//统计二叉树中结点的个数int BiTree_Node_Count(BTNode *T)&#123; if (T == NULL) return 0; else return BiTree_Node_Count(T-&gt;L_child) + BiTree_Node_Count(T-&gt;R_child) + 1;&#125; ··· 二叉树-非递归实现 结点结构123456//树的结点结构typedef struct BTNode&#123; BT_ElemType data; BTNode *L_child, *R_child; int visitCount;//用于非递归的后序遍历&#125; BTNode; 先序遍历123456789101112131415161718192021//先序遍历-使用栈(Stack)void Preorder_Traversal(BTNode *T)&#123; stack &lt;BTNode *&gt; TreeStack;//声明一个树的栈名为TreeStack BTNode *p = T; //辅助结点指针 while (p || !TreeStack.empty())//p不指向NULL或者栈内非空 &#123; if (p)//p不指向NULL &#123; printf("%d ", p-&gt;data);//访问结点值 TreeStack.push(p);//将p压入栈中,后进先出 p = p-&gt;L_child;//p指向他的左孩子 &#125; else//p指向NULL &#123; p = TreeStack.top();//取得栈顶指针 TreeStack.pop();//开始出栈,即访问左节点为空 p = p-&gt;R_child;//开始访问出战的左节点为空的父节点的右结点 &#125; &#125;&#125; 中序遍历12345678910111213141516171819202122// 中序遍历 void Inorder_Traverse(BTNode* T) &#123; stack &lt;BTNode*&gt; TreeStack; BTNode* p = T; while (p || !TreeStack.empty())//p不指向NULL或者栈非空 &#123; if (p)//p不指向NULL &#123; TreeStack.push(p);//压进栈内 p = p-&gt;L_child;//访问他的左孩子 &#125; else//p指向NULL &#123; p = TreeStack.top();//取得栈顶指针 printf("%d ", p-&gt;data);//访问根节点 TreeStack.pop();//根结点的左孩子开始出栈 p = p-&gt;R_child;//访问目前根节点的右孩子 &#125; &#125;&#125; 后序遍历123456789101112131415161718192021222324252627282930// 后序遍历void Postorder_Traversal(BTNode *T)&#123; stack&lt;BTNode *&gt; TreeStack; BTNode *p = T; while (p || !TreeStack.empty()) &#123; if (p) //不指向NULL &#123; p-&gt;visitCount = 1; //访问根节点一次 TreeStack.push(p); //压入栈中 p = p-&gt;L_child; //访问左结点 &#125; else //指向NULL &#123; p = TreeStack.top(); if (p-&gt;visitCount == 2) &#123; TreeStack.pop(); //出栈 printf("%d ", p-&gt;data); //读出栈顶的值 p = NULL;//指向空 &#125; else //只有访问过一次 &#123; p-&gt;visitCount++; //访问次数+1 p = p-&gt;R_child; //访问右孩子 &#125; &#125; &#125;&#125; 层序遍历12345678910111213141516171819202122232425// 层序遍历void Levelorder_Traversal(BTNode *T)&#123; if (!T) &#123; return; &#125; queue&lt;BTNode *&gt; TreeQueue; //调用队列 TreeQueue.push(T);//树的根节点入队 BTNode *p = T; while (!TreeQueue.empty())//队列非空 &#123; p = TreeQueue.front();//指向队头 TreeQueue.pop();//出队 printf("%d ", p-&gt;data);//取值 if (p-&gt;L_child)//存在左结点,入队 &#123; TreeQueue.push(p-&gt;L_child); &#125; if (p-&gt;R_child)//存在右结点,入队 &#123; TreeQueue.push(p-&gt;R_child); &#125; &#125;&#125; ··· 调用栈与队列 使用命名空间1using namespace std; //使用命名空间调用队列堆栈 引入头文件12#include &lt;queue&gt;#include &lt;stack&gt; 调用1stack&lt;BTNode *&gt; TreeStack; //声明一个元素为树结点指针的栈，名为TreeStack 基本操作123xx.empty() //为空则返回真xx.pop() //删除元素xx.push() //增加元素 ··· 测试源码 递归/非递归实现源码，请点击这里获取 随时补充]]></content>
      <categories>
        <category>Data Structure Study Notes</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-队]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%2F</url>
    <content type="text"><![CDATA[基于C/C++顺序队列和链式队列的构建与操作。 顺序队列 队的结构12345678#define MaxSize 10typedef int ElemType;//顺序队列结构typedef struct SeqQueue&#123; ElemType data[MaxSize]; int front, rear; // 队列头和队列尾&#125;SeqQueue; 队的操作初始化空队1234567//初始化空队列SeqQueue *SeqQueue_Init()&#123; SeqQueue *Q = (SeqQueue *)malloc(sizeof(SeqQueue));//分配内存 Q-&gt;rear = Q-&gt;front = 0;//初始化对手与队尾 return Q;&#125; 是否空队1234567//是否空队bool SeqQueue_Is_Empty(SeqQueue *Q)&#123; if (Q-&gt;front == Q-&gt;rear)//队首与队尾相同时为空队 return true; return false;&#125; 入队123456789101112bool SeqQueue_Push(SeqQueue *Q, ElemType x)&#123; if ((Q-&gt;rear + 1) % MaxSize == Q-&gt;front) //判断是否队满 &#123; printf("The Queue has been full.\n"); return false; &#125; Q-&gt;data[Q-&gt;rear] = x; printf("Elem %d has been in the Queue.\n", Q-&gt;data[Q-&gt;rear]); Q-&gt;rear = (Q-&gt;rear + 1) % MaxSize; return true;&#125; 出队12345678910//出队bool SeqQueue_Pop(SeqQueue *Q)&#123; if (SeqQueue_Is_Empty(Q)) //如果空队 return false; printf("Elem %d has been out of the Queue.\n", Q-&gt;data[Q-&gt;front]); Q-&gt;data[Q-&gt;front] = NULL; //清空队首元素，队首上移 Q-&gt;front = (Q-&gt;front + 1) % MaxSize; //循环队列操作 return true;&#125; 遍历打印123456789//循环打印void SeqQueue_Print(SeqQueue *Q)&#123; for (int i = Q-&gt;front; (i + 1) % MaxSize != Q-&gt;rear; i++)//取余判断是否循环一遍 &#123; printf("%d ", Q-&gt;data[i]); &#125; printf("\n");&#125; ··· 链式队列 链式队列结构123456789101112typedef int ElemType;//结点结构typedef struct QNode&#123; ElemType data;//数据域 QNode *next;//指针域&#125; QNode;//链式队列结构typedef struct LinkedQueue&#123; QNode *front, *rear; // 队列头和队列尾&#125;LinkedQueue; 链式队列操作空队初始化12345678//初始化空队列LinkedQueue* LinkedQueue_Init()&#123; LinkedQueue *Q = (LinkedQueue*)malloc(sizeof(LinkedQueue)); Q-&gt;front = Q-&gt;rear = (QNode *)malloc(sizeof(QNode));//分配空间给两个指针域结点 Q-&gt;rear-&gt;next = Q-&gt;front-&gt;next = NULL; //初始de后继指针均指向NULL return Q;&#125; 入队123456789101112//入队bool LinkedQueue_Push(LinkedQueue *Q, ElemType x)&#123; //链式队列不用考虑满队 QNode *r = (QNode*)malloc(sizeof(QNode));//新结点 r-&gt;data = x; //插入元素 r-&gt;next = NULL; //后继结点为空 Q-&gt;rear-&gt;next = r; //Q的原队尾结点指向s Q-&gt;rear = r; //更新队尾指针 printf("Elem %d has been in the Queue.\n", x); return true;&#125; 出队123456789101112//出队,需要注意头节点的问题bool LinkedQueue_Pop(LinkedQueue *Q)&#123; if (LinkedQueue_Is_Empty(Q)) //如果空队 return false; QNode *s=Q-&gt;front-&gt;next;//辅助结点,指向头结点的下一个 printf("Elem %d has been out of the Queue.\n",s-&gt;data);//跳过头节点 Q-&gt;front-&gt;next = s-&gt;next; // Q-&gt;front = Q-&gt;front-&gt;next; //队首后移动 free(s);//释放原来的头结点后继 return true;&#125; 是否非空1234567//是否空队bool LinkedQueue_Is_Empty(LinkedQueue *Q)&#123; if (Q-&gt;front==Q-&gt;rear) return true; return false;&#125; 遍历打印12345678910//循环打印void LinkedQueue_Print(LinkedQueue *Q)&#123; while(Q-&gt;front-&gt;next) &#123; printf("%d ", Q-&gt;front-&gt;next-&gt;data); Q-&gt;front = Q-&gt;front-&gt;next; &#125; printf("\n");&#125; ··· 测试源码 顺序队列源码，请点击这里获取 链式队列源码，请点击这里获取 随时补充]]></content>
      <categories>
        <category>Data Structure Study Notes</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈]]></title>
    <url>%2F2018%2F08%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[基于C/C++顺序栈和链栈的构建与操作。 顺序栈 栈的结构12345678#define MaxSize 50typedef int ElemType;//顺序栈结构typedef struct&#123; ElemType data[MaxSize]; int top; //栈的栈顶&#125; SeqStack; 栈的操作进栈12345678//进栈bool SeqStack_Push(SeqStack *S, ElemType x)&#123; if (S-&gt;top &gt;= MaxSize - 1)//若栈满，拒绝入栈 return false; S-&gt;data[++S-&gt;top] = x; //先移动指针。再赋值 return true;&#125; 出栈12345678910//出栈,返回出栈元素值bool SeqStack_Pop(SeqStack *S)&#123; if (S-&gt;top == -1) //若空栈，返回 return false; ElemType x = S-&gt;data[S-&gt;top--];//取得出栈元素后，top指针下移 S-&gt;data[S-&gt;top + 1] = NULL;//将要删除的元素删除 printf("ELm %d has been out\n", x); return true;&#125; 自动建栈123456789101112//自动建栈SeqStack *Create_SeqStack()&#123; SeqStack *S; //定义栈 S = (SeqStack *)malloc(sizeof(SeqStack)); S-&gt;top = -1; //初始化栈顶指针 for (int i = 0; i &lt; 10; i++) &#123; SeqStack_Push(S, i); &#125; return S;&#125; 遍历打印1234567891011// 从栈顶遍历顺序栈元素void Print_SeqStack_FromTop(SeqStack *S)&#123; if (S-&gt;top == -1) printf("NULL"); for (int x = S-&gt;top; x &gt; -1; x--) &#123; printf("%d ", S-&gt;data[x]); &#125; printf("\n");&#125; ··· 链栈 栈的结构12345678910111213typedef int ElemType;// 链式栈的结点typedef struct SNode&#123; ElemType data; struct SNode *next;&#125; SNode;//链式栈的结构typedef struct LinkedStack&#123; SNode *top; //栈顶指针 int count; //链式栈的结点数&#125; LinkedStack; 栈的操作进栈12345678910// 进栈bool LinkedStack_Push(LinkedStack *S, ElemType x)&#123; SNode *p = (SNode*)malloc(sizeof(SNode));//申请新结点内存 p-&gt;data = x;//赋值 p-&gt;next = S-&gt;top;//p得后继指针指向原来的栈顶 S-&gt;top = p;//将栈顶指针移动到新结点 S-&gt;count++;//增加结点数 return true;&#125; 出栈12345678910111213// 出栈bool LinkedStack_Pop(LinkedStack *S)&#123; if (!S-&gt;top)//判定是否为空 return false; ElemType x = S-&gt;top-&gt;data;//得到出栈元素 SNode *p = S-&gt;top;//辅助指针指向栈顶 S-&gt;top = S-&gt;top-&gt;next;//移动栈顶指针到原栈顶指针的后继 free(p);//释放掉原栈顶 S-&gt;count--;//结点数-1 printf("Elem %d has been out of stack\n",x); return true;&#125; 自动建栈12345678910111213//自动建栈LinkedStack *Create_LinkedStack()&#123; LinkedStack *S; S = (LinkedStack*)malloc(sizeof(SNode));//申请内存 S-&gt;count = 0;//初始化结点数 S-&gt;top = NULL;//初始化栈顶指针 for (int x = 0; x &lt; 10; x++) &#123; LinkedStack_Push(S, x);//进栈操作 &#125; return S;&#125; 遍历打印1234567891011//遍历打印void Print_LinkedStack_FromTop(LinkedStack *S)&#123; SNode *p = S-&gt;top; while (p)//当栈顶指针不为空 &#123; printf("%d ", p-&gt;data); p = p-&gt;next; &#125; printf("\n");&#125; ··· 测试源码 链式栈源码，请点击这里获取 顺序栈源码，请点击这里获取 随时补充]]></content>
      <categories>
        <category>Data Structure Study Notes</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-表]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[基于C/C++顺序表和链表的构建与操作。 顺序表 静态表结构12345//静态顺序表结构typedef struct SeqList_Static&#123; ElemType data[MaxSize]; int length;&#125;SeqList_Static; 静态表操作初始化123456789101112131415//顺序表初始化SeqList_Static *SeqList_Static_Init()&#123; // 一次性开辟存储空间 SeqList_Static *L = (SeqList_Static *)malloc(sizeof(SeqList_Static)); L-&gt;data[0] = NULL;//初始化为空，长度为0 L-&gt;length = 0; //初始化时，顺序插入0-9 for (int i = 0; i &lt; 10; i++) &#123; L-&gt;data[i] = i; L-&gt;length++; &#125; return L;&#125; 顺序打印12345678//静态链表的打印void SeqList_Static_Print(SeqList_Static *L)&#123; for (int i = 0; i &lt; L-&gt;length; i++) &#123; printf("%d ", L-&gt;data[i]); &#125;&#125; 元素插入1234567891011121314151617// 静态链表——插入元素bool SeqList_Static_Insert(SeqList_Static *L, int i, ElemType x)&#123; //判断插入位置的合法性 if (i &gt; L-&gt;length or i &lt;= 0) return false; // 要插入位置的后面结点循环右移一位 for (int j = L-&gt;length; j &gt;= i; j--) &#123; L-&gt;data[j] = L-&gt;data[j - 1]; &#125; L-&gt;data[i-1] = x;//插入元素 L-&gt;length++; printf("\n插入之后的链表为:\n"); SeqList_Static_Print(L); return true;&#125; 元素删除12345678910111213141516// 静态链表——删除元素bool SeqList_Static_Delete(SeqList_Static *L, int i)&#123; //判断要删除位置的合法性 if (i &gt; L-&gt;length or i &lt;= 0) return false; // 要删除位置的后面结点循环左移一位 for (; i &lt; L-&gt;length; i++) &#123; L-&gt;data[i-1] = L-&gt;data[i]; &#125; L-&gt;length--; printf("\n删除之后的链表为:\n"); SeqList_Static_Print(L); return true;&#125; 动态表结构12345678910#define MaxSize 100 //静态链表的最大长度#define InitSize 10 //预定义顺序表初始长度#define ListIncrement 10 //预定义顺序表扩充增量typedef int ElemType; //元素类型//动态顺序表结构typedef struct SeqList&#123; ElemType *data; int length,capacity;//长度，动态的最大容量&#125; SeqList; 动态表操作初始化12345678910111213141516// 动态表初始化SeqList *SeqList_Init()&#123; SeqList *L = (SeqList *)malloc(sizeof(SeqList)); L-&gt;data = (ElemType *)malloc(sizeof(ElemType) * InitSize);//不加会出错 不懂为什么 L-&gt;length = 0; L-&gt;capacity = InitSize; //动态的空间最大量 L-&gt;data[0] = NULL; //初始化时，顺序插入0-9 for (int i = 0; i &lt; 10; i++) &#123; L-&gt;data[i] = i; L-&gt;length++; &#125; return L;&#125; 查找元素1234567//按值查找int SeqList_Locate(SeqList L,ElemType e)&#123; for(int i=1;i&lt;=L.length;i++) if(L.data[i-1]==e)return i; //返回第i个元素(下标为i-1值为e)的位号i return 0; //返回0表明查找失败&#125; 插入元素12345678910111213141516171819//插入元素bool ListInsert_Seq(SeqList *L, int i, ElemType e)&#123; if (i &lt; 1 || i &gt; L-&gt;length + 1) return false; //i的位置不合法 if (L-&gt;length &gt;= L-&gt;capacity) &#123; //当前长度已达到最大容量，扩充分配存储空间 ElemType *newbase = (ElemType *)realloc(L-&gt;data, sizeof(ElemType) * (InitSize + ListIncrement)); //顺序表扩充 if (!newbase) return false; //存储分配失败 L-&gt;data = newbase; //新基址 L-&gt;capacity += ListIncrement; //增加存储容量 &#125; for (int j = L-&gt;length; j &gt;= i; j--) //第i个元素以及其后的元素右移1个位置 L-&gt;data[j] = L-&gt;data[j - 1]; L-&gt;data[i - 1] = e; //腾出一个空位置插入新元素 L-&gt;length++; //表当前长度+1 return true;&#125; 删除元素123456789//删除操作bool ListDelete_Seq(SeqList &amp;L,int i,ElemType&amp; e)&#123;//删除第i个位置（1&lt;=i&lt;=L.length）元素 if(i&lt;1||i&gt;L.length)return false; //i的位置不合法 e=L.data[i-1]; //将被删除的元素用引用变量e返回 for(int j=i;j&lt;L.length;j++) //第i个位置之后元素前移 L.data[j-1]=L.data[j]; L.length--; //表长度-1 return true;&#125; ··· 单链表 结点结构123456789//结点元素typedef int ElemType;// 创建单链表结点结构typedef struct LNode&#123; ElemType data;//数据域 struct LNode *next;//指针域，用于指向下一个结点&#125; LNode, *LinkedList; 单链表创建头插法以顺序插入0-9为例创建带有头结点的单链表： 12345678910111213141516//头插法创建单链表LinkedList Create_LinkedList_H()&#123; LNode *L;//创建头结点 L = (LNode*)malloc(sizeof(LNode));//开辟头结点存储空间 L-&gt;next = NULL;//默认将头结点指向空 LNode *s; //创建辅助结点 for (int x = 0; x &lt; 10; x++)//0-9循环入队 &#123; s = (LNode *)malloc(sizeof(LNode));//开辟新的结点空间 s-&gt;data = x; //1.为新的结点赋值 s-&gt;next = L-&gt;next; //2.将新结点的后继指针指向头节点原来的后继，即插入到头结点后面 L-&gt;next = s; //3.最后修改头结点的后继指针指向新节点 &#125; return L;//返回生成的链表&#125; 尾插法1234567891011121314151617// 尾插法创建单链表LinkedList Create_LinkedList_R()&#123; LNode *L;//创建头结点 L = (LNode*)malloc(sizeof(LNode));//开辟结点空间 LNode *s; //辅助节点指针 LNode *r = L; //相当于尾指针，当前初始指向头结点 for (ElemType x = 0; x &lt; 10; x++) &#123; s = (LNode *)malloc(sizeof(LNode));//开辟新节点空间 s-&gt;data = x; //将新结点赋值 r-&gt;next = s; //将新结点接到当前尾指针的后端 r = s; //将尾指针移到最后的结点 &#125; s-&gt;next = NULL;//将最后得结点后继指针指向空 return L;//返回新的结点&#125; 单链表操作遍历打印123456789// 遍历打印带头结点的单链表void Print_LinkedList(LNode *L)&#123; LNode *p = L-&gt;next;//跳过头结点 for (; p; p = p-&gt;next)//循环遍历链表 &#123; printf("%d ", p-&gt;data); &#125;&#125; 查找元素12345678910111213141516//按照序号查找元素LinkedList GetElem_By_Number(LinkedList L, int i)&#123; if (i == 1) //查找第一个元素，则直接返回头结点的后继结点 return L-&gt;next; if (i &lt; = 0)//非法查找 return NULL; int j = 1; LNode *p = L-&gt;next;//跳过头结点 while (p &amp;&amp; j &lt; i)//当p非空且未到循环次数 &#123; j++; p = p-&gt;next;//跳到下一个结点 &#125; return p;//返回p的指针位置&#125; 123456789101112// 按照值来查找元素LinkedList GetElem_By_Value(LinkedList L, ElemType x)&#123; if (L == NULL || x == NULL)//其一为空 return NULL; LNode *p = L-&gt;next;//跳过头结点 while (p-&gt;data != x) &#123; p = p-&gt;next; &#125; return p;//返回指针&#125; 插入结点12345678910// 在第i个结点处插入新结点LinkedList Insert_LinkedList(LinkedList &amp;L, int i, ElemType x)&#123; LNode *p = GetElem_By_Number(L, i - 1);//得到要插入元素的前一个结点 LNode *s = (LNode *)malloc(sizeof(LNode));//开辟存储空间 s-&gt;data = x;//赋值 s-&gt;next = p-&gt;next;//将新节点的后继指向要插入位置的后一个结点 p-&gt;next = s;//将要插入位置的前一个元素的后继指向新节点 return L;//返回新链表&#125; 删除结点123456789// 删除第i个结点LinkedList Delete_LinkedList(LinkedList &amp;L, int i)&#123; LNode *p = GetElem_By_Number(L, i - 1);//p指向删除元素的前一个结点 LNode *q = p-&gt;next; //q指向要删除的结点 p-&gt;next = q-&gt;next; //前一个直接跳过要删除元素指向要删除元素的后继 free(q); //释放掉q的空间 return L;&#125; ··· 双链表 结点结构12345//定义双链表结点结构typedef struct DLNode&#123; ElemType data; struct DLNode *prior, *next;//双指针&#125;DLNode; 双链表操作头插法创建单链表1234567891011121314151617181920//头插法建立双链表DLNode *Create_Double_LinkedList_H()&#123; DLNode *L; //头结点L L = (DLNode *)malloc(sizeof(DLNode)); //为头结点分配内存 L-&gt;next = L; //初始化指针 L-&gt;prior = L; L-&gt;data = NULL; DLNode *s; //新结点 for (int i = 0; i &lt; 10; i++) &#123; s = (DLNode *)malloc(sizeof(DLNode)); s-&gt;data = i; L-&gt;next-&gt;prior = s; s-&gt;prior = L; s-&gt;next = L-&gt;next; L-&gt;next = s; &#125; return L;&#125; 尾插法创建双链表123456789101112131415161718//尾插法建立双链表DLNode *Create_Double_LinkedList_R()&#123; DLNode *L = (DLNode *)malloc(sizeof(DLNode)); L-&gt;prior = L-&gt;next = L; DLNode *s; for (int i = 0; i &lt; 10; i++) &#123; DLNode *r = L-&gt;prior; //定义为尾指针 s = (DLNode *)malloc(sizeof(DLNode)); s-&gt;data = i;//赋值 r-&gt;next = s;//原尾指针后继指向新结点 s-&gt;prior = r;//新结点前驱指向原尾结点 s-&gt;next = L;//新结点的后继为头结点 L-&gt;prior = s; //头结点的前驱为新结点 &#125; return L;&#125; 打印双链表1234567891011// 打印双循环链表void Print_Double_LinkedList(DLNode *L)&#123; DLNode *p = L-&gt;next; //p跳过头结点，指向第一个结点 while (p != L) &#123; printf("%d ", p-&gt;data); p = p-&gt;next; &#125; printf("\n");&#125; ··· 测试源码 链表源码，请点击这里获取 顺序表源码，请点击这里获取 随时补充]]></content>
      <categories>
        <category>Data Structure Study Notes</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linked List</tag>
        <tag>Sequence List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python下划线]]></title>
    <url>%2F2018%2F04%2F21%2FPython%E4%B8%8B%E5%88%92%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[Python中单下划线和双下划线的各种含义和命名约定，名称修饰的工作原理，以及它如何影响你自己的Python类。 前言单下划线和双下划线在Python变量和方法名称中都各有其含义。有一些含义仅仅是依照约定，被视作是对程序员的提示 - 而有一些含义是由Python解释器严格执行的。 在本文中，我们将讨论以下五种下划线模式和命名约定，以及它们如何影响Python程序的行为： 单前导下划线：_var 单末尾下划线：var_ 双前导下划线：__var 双前导和末尾下划线：__var__ 单下划线：_ 1. 单前导下划线 _var当涉及到变量和方法名称时，单个下划线前缀有一个约定俗成的含义。 它是对程序员的一个提示 - 意味着Python开发人员一致认为它应该是什么意思，但程序的行为不受影响。 下划线前缀的含义是告知其他程序员：以单个下划线开头的变量或方法仅供内部使用。 该约定在PEP 8中有定义。 这不是Python强制规定的。 Python不像Java那样在“私有”和“公共”变量之间有很强的区别。 这就像有人提出了一个小小的下划线警告标志，说： “嘿，这不是真的要成为类的公共接口的一部分。不去管它就好。“ 看看下面的例子： 如果你实例化此类，并尝试访问在__init__构造函数中定义的foo和_bar属性，会发生什么情况？ 让我们来看看： 你会看到_bar中的单个下划线并没有阻止我们“进入”类并访问该变量的值。 这是因为Python中的单个下划线前缀仅仅是一个约定 - 至少相对于变量和方法名而言。 但是，前导下划线的确会影响从模块中导入名称的方式。假设你在一个名为my_module的模块中有以下代码： 现在，如果使用通配符从模块中导入所有名称，则Python不会导入带有前导下划线的名称（除非模块定义了覆盖此行为的__all__列表）： 顺便说一下，应该避免通配符导入，因为它们使名称空间中存在哪些名称不清楚。 为了清楚起见，坚持常规导入更好。 与通配符导入不同，常规导入不受前导单个下划线命名约定的影响： 我知道这一点可能有点令人困惑。 如果你遵循PEP 8推荐，避免通配符导入，那么你真正需要记住的只有这个： 单个下划线是一个Python命名约定，表示这个名称是供内部使用的。 它通常不由Python解释器强制执行，仅仅作为一种对程序员的提示。 2. 单末尾下划线 var_有时候，一个变量的最合适的名称已经被一个关键字所占用。 因此，像class或def这样的名称不能用作Python中的变量名称。 在这种情况下，你可以附加一个下划线来解决命名冲突：总之，单个末尾下划线（后缀）是一个约定，用来避免与Python关键字产生命名冲突。 PEP 8解释了这个约定。 3. 双前导下划线 __var到目前为止，我们所涉及的所有命名模式的含义，来自于已达成共识的约定。 而对于以双下划线开头的Python类的属性（包括变量和方法），情况就有点不同了。 双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。 这也叫做名称修饰（name mangling） - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。 我知道这听起来很抽象。 因此，我组合了一个小小的代码示例来予以说明： 让我们用内置的dir()函数来看看这个对象的属性： 以上是这个对象属性的列表。 让我们来看看这个列表，并寻找我们的原始变量名称foo，_bar和__baz - 我保证你会注意到一些有趣的变化。 self.foo变量在属性列表中显示为未修改为foo。 self._bar的行为方式相同 - 它以_bar的形式显示在类上。 就像我之前说过的，在这种情况下，前导下划线仅仅是一个约定。 给程序员一个提示而已。 然而，对于self.__baz而言，情况看起来有点不同。 当你在该列表中搜索__baz时，你会看不到有这个名字的变量。 __baz出什么情况了？ 如果你仔细观察，你会看到此对象上有一个名为_Test__baz的属性。 这就是Python解释器所做的名称修饰。 它这样做是为了防止变量在子类中被重写。 让我们创建另一个扩展Test类的类，并尝试重写构造函数中添加的现有属性： 等一下，当我们尝试查看t2 .__ baz的值时，为什么我们会得到AttributeError？ 名称修饰被再次触发了！ 事实证明，这个对象甚至没有__baz属性： 正如你可以看到__baz变成_ExtendedTest__baz以防止意外修改： 但原来的_Test__baz还在： 双下划线名称修饰对程序员是完全透明的。 下面的例子证实了这一点： 名称修饰是否也适用于方法名称？ 是的，也适用。名称修饰会影响在一个类的上下文中，以两个下划线字符（”dunders”）开头的所有名称： 这是另一个也许令人惊讶的运用名称修饰的例子： 在这个例子中，我声明了一个名为_MangledGlobal__mangled的全局变量。然后我在名为MangledGlobal的类的上下文中访问变量。由于名称修饰，我能够在类的test()方法内，以__mangled来引用_MangledGlobal__mangled全局变量。 Python解释器自动将名称__mangled扩展为_MangledGlobal__mangled，因为它以两个下划线字符开头。这表明名称修饰不是专门与类属性关联的。它适用于在类上下文中使用的两个下划线字符开头的任何名称。 4. 双前导和双末尾下划线 __var__也许令人惊讶的是，如果一个名字同时以双下划线开始和结束，则不会应用名称修饰。 由双下划线前缀和后缀包围的变量不会被Python解释器修改： 但是，Python保留了有双前导和双末尾下划线的名称，用于特殊用途。 这样的例子有，__init__对象构造函数，或__call__ — 它使得一个对象可以被调用。 这些dunder方法通常被称为神奇方法 , 但Python开发者们都不喜欢这种方法。 最好避免在自己的程序中使用以双下划线（dunders）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。 5. 单下划线 _按照习惯，有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。 例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用“_”来表示它只是一个临时值： 你也可以在拆分(unpacking)表达式中将单个下划线用作“不关心的”变量，以忽略特定的值。 同样，这个含义只是“依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。 在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，“_”作为占位符变量可以派上用场： 除了用作临时变量之外，“_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。 这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字： 总结以下是一个简短的小结，即“速查表”，罗列了我在本文中谈到的五种Python下划线模式的含义： 英文原文：https://dbader.org/blog/meaning-of-underscores-in-python 单前导下划线]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>下划线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium遇到click失效问题解决]]></title>
    <url>%2F2018%2F04%2F11%2Fselenium%E9%81%87%E5%88%B0click%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[在使用selenium webdriver进行爬取淘宝信息，爬取一页结束后，进行翻页操作失败，仔细检查源码，发现在底端输入页码后模拟点击并未生效，本篇记录一下解决问题的办法。 问题描述相关代码1234# 使用谷歌浏览器browser = webdriver.Chrome(executable_path=chromedriver, chrome_options=options)# 定义一个等待，方便后面调用wait = WebDriverWait(browser, 10) 12345678910111213# 函数功能：跳转到指定页数def jump_to_page(page): # 输入页码 input_page = wait.until( EC.presence_of_element_located((By.CSS_SELECTOR, "#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input")) ) input_page.clear() input_page.send_keys(page) # 等待提交按钮可点击 submit_page = wait.until( EC.element_to_be_clickable((By.CLASS_NAME, "btn J_Submit")) ) submit_page.click() 在这里发现submit_page.click()并未生效。在网页中的这个地方： 页码可以正常插入，但并未发生跳转，即click方法未生效。 解决办法方法一：先点父元素即先点击想要点击的父元素，再点击子元素。12browser.find_element_by_css_selector('#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form').click()browser.find_element_by_css_selector('"#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit').click() 淘宝真的强无敌，该方法并未起作用，是时候放大招了。 方法二：JS大法好即直接用js直接去点击，简单粗暴，但有效。12js = 'document.getElementsByClassName("btn J_Submit")[0].click();'browser.execute_script(js)]]></content>
      <categories>
        <category>Spider Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
        <tag>Selenium</tag>
        <tag>web driver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：ViewSets与Routers]]></title>
    <url>%2F2018%2F04%2F08%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9AViewSets%E4%B8%8ERouters%2F</url>
    <content type="text"><![CDATA[在这一篇文章中，要介绍的是另一种基于类的视图的写法，它的抽象程度更高，也可以说是代码量又减少了。 使用ViewSets重构视图先介绍一下这个ViewSets。ViewSets，翻译过来可以说是视图集，也就是几个视图的集合。 拿本项目为例子，我们之前查看所有用户列表就要写一个视图类UserList，并在urls.py中为其设置一个模式然后as_view使用它，然后要看单个用户的详情页就要再写一个UserDetail视图类并再在添加一个url模式。同时注意到这两个视图类都是继承的generics.XXXAPIView。而使用ViewSets我们就可以把UserList和UserDetail合并成UserViewSet视图类，并且继承的类改为viewsets.ReadOnlyModelViewSet，这样就是一个视图集了。 还是有点懵逼？没事，下面看看代码。编辑snippets/view.py，导入viewsets并使用UserViewSet来替换掉UserList和UserDetail： 12345678from rest_framework import viewsetsclass UserViewSet(viewsets.ReadOnlyModelViewSet): """ viewset自动提供了list和detail动作 """ queryset = User.objects.all() serializer_class = UserSerializer 这里面的queryset和serializer_class的值还是和原来一样。因为关于User的API都是只读的，所以我们继承了一个ReadOnlyModelViewSet类，这样就把原先的两个视图类集合起来了。原本类里面的： 12queryset = User.objects.all()serializer_class = UserSerializer 这部分属于重复代码，所以通过视图集来实现视图类我们的代码量确实减少了，更加简洁。 ViewSet类与View类其实几乎是相同的,但提供的是read或update这些操作,而不是get或put 等HTTP动作。同时，ViewSet为我们提供了默认的URL结构, 使得我们能更专注于API本身。 上面这段话呢，是官方文档里面说的，想就这样看看就算了来理解也行，不过如果我们看一下源码也许能理解的更好。因为我用的是PyCharm，所以查看源码很方便，按住CTRL键然后鼠标点击一下就会自动跳转了，首先查看一下ReadOnlyModelViewSet，发现它是这样的： 12345678class ReadOnlyModelViewSet(mixins.RetrieveModelMixin, mixins.ListModelMixin, GenericViewSet): &quot;&quot;&quot; A viewset that provides default `list()` and `retrieve()` actions. &quot;&quot;&quot; pass 发现原来有用到之前说的mixins，所以刚才才说ViewSet类与View类其实几乎是相同的。但是这里多了一个GenericViewSet类是新的内容，继续CTRL点击查看其代码，发现它内部只是一个pass然后就没有其他的操作了，但是可以继续查看其父类ViewSetMixin的源码来了解ViewSets，然后就可以看到这个ViewSetMixin其实重写了as_view方法： 12345678@classonlymethod def as_view(cls, actions=None, **initkwargs): &quot;&quot;&quot; Because of the way class based views create a closure around the instantiated view, we need to totally reimplement `.as_view`, and slightly modify the view function that is created and returned. &quot;&quot;&quot; ... 我们平时使用视图类的时候，编写urls.py时，就一个XXX.as_view()，现在使用ViewSets，需要传入参数，大概像下面这样的： 1UserViewSet.as_view(&#123;'get': 'list'&#125;) 之后url就配置好了，也就是上面说的ViewSet为我们提供了默认的URL结构。当然了，这个还不是完整的url模式，稍后补全。 刚才把User的两个视图类合并成视图集了，那么Snippet的几个视图类操作上也是差不多的。用视图集SnippetViewSet代替SnippetList, SnippetDetail 和 SnippetHighlight这三个视图类： 123456789101112131415161718192021from rest_framework.decorators import detail_routeclass SnippetViewSet(viewsets.ModelViewSet): """ viewset自动提供了`list`, `create`, `retrieve`, `update` 和 `destroy` 动作. 同时我们手动增加一个额外的'highlight'动作用于查看高亮的代码段 """ queryset = Snippet.objects.all() serializer_class = SnippetSerializer permission_classes = (permissions.IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly,) @detail_route(renderer_classes=[renderers.StaticHTMLRenderer]) def highlight(self, request, *args, **kwargs): snippet = self.get_object() return Response(snippet.highlighted) def perform_create(self, serializer): serializer.save(owner=self.request.user) 因为查看highlight不像其他动作那样，django-rest-framework并没有替我们封装好，所以我们需要自己添加这个额外的动作，要记得在方法前面加上装饰器@detail_route，这个装饰器就是用来创建自定义的动作，当然我们的自定义动作不可以是create/update/delete这些标准的，否则会有冲突。 还有一点，用@detail_route装饰器定义的动作默认是GET请求，需要其他的请求方式可以传入methods参数给这个装饰器。同样的，默认情况下，自定义操作的URL取决于方法名称本身。如果要更改url应该构造的方式，可以将url_path作为decorator的关键字参数。 最后还要注意继承的类是ModelViewSet和刚才的也有点不同，为什么换成这个，也可以看看源码能略知一二： 1234567class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet): ... 将ViewSets明确的绑定到URL根据上面所说的，每个视图集的url模式都需要我们在as_view中传入参数，把snippets/urls.py的代码换成下面的： 1234567891011121314151617181920212223242526272829303132333435from django.conf.urls import url,includefrom snippets.views import SnippetViewSet, UserViewSet, api_rootfrom rest_framework import renderersfrom rest_framework.urlpatterns import format_suffix_patternssnippet_list = SnippetViewSet.as_view(&#123; 'get': 'list', 'post': 'create'&#125;)snippet_detail = SnippetViewSet.as_view(&#123; 'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy'&#125;)snippet_highlight = SnippetViewSet.as_view(&#123; 'get': 'highlight'&#125;, renderer_classes=[renderers.StaticHTMLRenderer])user_list = UserViewSet.as_view(&#123; 'get': 'list'&#125;)user_detail = UserViewSet.as_view(&#123; 'get': 'retrieve'&#125;)urlpatterns = format_suffix_patterns([ url(r'^$', api_root), url(r'^snippets/$', snippet_list, name='snippet-list'), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', snippet_detail, name='snippet-detail'), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$', snippet_highlight, name='snippet-highlight'), url(r'^users/$', user_list, name='user-list'), url(r'^users/(?P&lt;pk&gt;[0-9]+)/$', user_detail, name='user-detail')]) OK，到了这里对视图的改造已经完成了，可以启动服务器测试一下，我们的项目功能还是和之前的一样的。 使用Routers不过看到urls.py的代码，我们可能会发现一个问题，就是我们的视图类代码简洁了变少了，但是urls.py的代码量好像多了啊，要绑定那么多动作，这样算起来好像也没多大提升？ 确实是这样。但是我们这可是在用python开发啊，当然是能短则短了，没错，django-rest-framework的作者也是这么想的，所以我们又有现成的轮子可以使用了。这个轮子就是本文的另一个主角——Routers。用起来也是简单粗暴，重写urls.py： 1234567891011121314from django.conf.urls import url, includefrom snippets import viewsfrom rest_framework.routers import DefaultRouter# Create a router and register our viewsets with it.router = DefaultRouter()router.register(r'snippets', views.SnippetViewSet)router.register(r'users', views.UserViewSet)# The API URLs are now determined automatically by the router.# Additionally, we include the login URLs for the browsable API.urlpatterns = [ url(r'^', include(router.urls)),] 这样就搞定了，代码少了很多，连原来用来设置后缀的下面这行代码都不需要了。 1urlpatterns = format_suffix_patterns(urlpatterns) 而且这个DefaultRouter 类还会自动帮我们创建API根视图，也就是说view.py中的api_root方法也可以删除掉了。 额…这个Routers帮我们做的事情真是有点多啊。。不过这也就是我为什么在文章的前言里面说使用ViewSets会比原本的视图更抽象的原因。 拿过来用是会了，但是这里面发生了什么我们完全不知道啊，比如说API后缀去哪了？上面我们写的： 1234snippet_list = SnippetViewSet.as_view(&#123; 'get': 'list', 'post': 'create'&#125;) 这些绑定全都自动生成了？这些确实都是DefaultRouter 帮我们做好了，怎么做的，我们还是可以看一下源码了解一下大概的过程。首先就是register方法，我们绑定了那么多动作它两行就搞定了，查看它的源码，发现它是BaseRouter类下的一个方法： 12345678910111213141516class BaseRouter(object): def __init__(self): self.registry = [] def register(self, prefix, viewset, base_name=None): if base_name is None: base_name = self.get_default_base_name(viewset) self.registry.append((prefix, viewset, base_name)) ... @property def urls(self): if not hasattr(self, '_urls'): self._urls = self.get_urls() return self._urls 改方法根据传进来的参数生成url端点，也就是/snippets和/users，然后存到registry列表中。并且这个类的最后是一个可以当属性用的方法urls，而这个方法里面又调用了get_urls()来生成所有的url模式，当然这个get_urls()被子类SimpleRouter和子子类DefaultRouter重写了。SimpleRouter中的get_urls()实现了生成是5个url模式，也就是原本的： 12345url(r'^snippets/$',snippet_list,name='snippet-list'),url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', snippet_detail, name='snippet-detail'),url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$', snippet_highlight, name='snippet-highlight'),url(r'^users/$', user_list, name='user-list'),url(r'^users/(?P&lt;pk&gt;[0-9]+)/$', user_detail, name='user-detail') 而DefaultRouter中的get_urls()中则生成了api_root的url模式，同时还为这些url模式加了格式后缀，所以我们自己不会用到format_suffix_patterns这个东西。 当然了，并不一定要使用ViewSets的视图代替View，两者各有好处ViewSets节省了很多代码并且url模式也不用我们自己设置了，但是也会带来一些不确定性，自动化的效果有时候可能和你预想的不太一样，所以想要选择哪种方法看你自己喜欢。 声明本篇文章来自ziv的博客，仅作整理学习分享。点击这里访问原文。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：超链接]]></title>
    <url>%2F2018%2F04%2F08%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E8%B6%85%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[在不同的资源信息之间使用超链接进行跳转，及之前提到的显示时代码段高亮的实现。 在上篇中，加入了用户模型，以及相关的认证和权限的功能。但是我们在使用的时候，会发现在访问http://127.0.0.1:8000/users/时看到的用户列表，不能够直接点击某个链接然后查看其详情，也就是不能跳转到http://127.0.0.1:8000/users/2这样的链接，查看Snippet列表的时候也是如此。而且User和Snippet也没相关的链接进行相互之间的跳转。这些就很影响用户体验了，每次都需要重新输入URL才可以访问别的内容。这就是这篇文章主要解决的问题。 另外，上一篇文章说的能使代码段高亮的HTML代码，也会在本文中看到其使用。 为API创建根URL根URL也就是访问根路径，就是http://127.0.0.1:8000/，要让这个页面能显示并访问所有的模型，也就是本项目的snippets和users。所以在views.py中肯定要多增加一个内容作为根URL（也就是首页）的视图，在这里我们采用基于函数的视图，编辑snippets/views.py并添加下面的内容： 1234567891011from rest_framework.decorators import api_viewfrom rest_framework.response import Responsefrom rest_framework.reverse import reverse@api_view(['GET'])def api_root(request, format=None): return Response(&#123; 'users': reverse('user-list', request=request, format=format), 'snippets': reverse('snippet-list', request=request, format=format) &#125;) 关于装饰器在之前的文章已经讲解过了，这里的新知识是reverse，这是rest_framework的reverse而不是Django自带的那个，但是使用习惯类似，它会根据参数返回一个超链接，看到’user-list’和’snippet-list’基本就和Django自带的reverse一样的道理，就是根据路由匹配模式的命名来生成超链接，所以等下需要编辑snippets/urls.py设置一下name参数。 然后Response的参数是一个字典，这个其实也和Django开发一样，这个字典的键和值会传到前端模板然后经过模板引擎渲染，只不过这里的前端模板django-rest-framework已经帮我们做好了，只需把值传递过去就OK啦。 创建跳转至查看高亮代码段的URL现在我们的API还不能查看高亮代码段，所以需要添加一个链接进行跳转。 回到上一篇文章里面的snippets/models.py，我们为Snippet模型添加了highlighted字段，并且使用save方法，使得保存数据时生成能使代码段高亮的HTML代码，也就是下面这段代码： 1234567891011def save(self, *args, **kwargs): """ 使用pygments库来生成能使代码高亮的HTML代码 """ lexer = get_lexer_by_name(self.language) linenos = self.linenos and 'table' or False options = self.title and &#123;'title': self.title&#125; or &#123;&#125; formatter = HtmlFormatter(style=self.style, linenos=linenos, full=True, **options) self.highlighted = highlight(self.code, lexer, formatter) super(Snippet, self).save(*args, **kwargs) 所以每次保存数据时都会自动更新生成新的HTML代码。 现在我们要做的就是使用API的时候，每个snippet下面除了id、title、owner等这些本来就有的，还要加一个超链接，点击链接就能查看高亮代码段的页面，所以需要为这个新页面再创建一个视图，编辑snippet/views.py，添加代码： 123456789from rest_framework import renderersclass SnippetHighlight(generics.GenericAPIView): queryset = Snippet.objects.all() renderer_classes = (renderers.StaticHTMLRenderer,) def get(self, request, *args, **kwargs): snippet = self.get_object() return Response(snippet.highlighted) 这个代码高亮是为了在浏览器上使用API时查看的，所以返回json格式的数据就没有什么意思了，所以这里限定为只用HTML方式呈现。 REST framework为我们提供了两种方式来呈现HTML，一种是使用已有的模板（我们平时开发Django更常用的那种方式），另一种就是使用已经构建好的HTML代码。在这里我们会使用第二种方法，因为刚才已经说了每次保存数据时都会自动更新生成新的HTML代码，而这个由pygments生成的代码就保存在Snippet下的highlighted，所以有浏览器渲染并呈现highlighted下的HTML代码就行了。因此有： 1renderer_classes = (renderers.StaticHTMLRenderer,) 另外我们还注意到这里使用了get方法，其他的视图类不用这个方法因为他们返回的是整个实例对象，而我们的高亮代码段页面只需要这个实例对象的一个属性，也就是snippet.highlighted。REST framework提供的通用视图类并没有提供直接返回一个实例的某个属性的方法，所以这里需要我们自己写一个get方法来指定返回的属性。 完成了根视图以及高亮代码段视图的设计，要调用到它们的话，接下来自然要为其设计URL了。编辑snippets/urls.py，添加下面两个url模式： 12url(r'^$', views.api_root),url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$', views.SnippetHighlight.as_view()), 用超链接关联API到目前，User和Snippet在浏览时还不能相互之间进行跳转，比如我们访问一个用户的详情页时，单个User下的snippets会显示此用户创建的所有snippet，但是只显示了id值，可读性不好并且不能跳转，光看到个数字其实意义不大。我们希望实现的是把这些id值换成相应的snippet的超链接，同时希望在查看用户列表的时候每个用户下面有个超链接能直接进入该用户详情页；同样的，在每个snippet下有个URL指向其创建者的详情页面。 说了那么多，我们想要的就是用超链接来关联API，用来代替之前简单粗暴的使用外键以及id值来表示。 由此，在序列化器中引出一个新的HyperlinkedModelSerializer类来代替之前的ModelSerializer类。 这个新的类有以下的不同点： 默认不包含id值 通过HyperlinkedIdentityField这个字段会为序列化器生成一个url属性 关联API使用的是HyperlinkedRelatedField而不是PrimaryKeyRelatedField（超链接代替外键） 这么一看，这个新的HyperlinkedModelSerializer类好像可以实现上面我们所说的那些功能，确实是这样的。编辑snippet/serializers.py，改进序列化器： 12345678910111213141516class SnippetSerializer(serializers.HyperlinkedModelSerializer): owner = serializers.ReadOnlyField(source='owner.username') highlight = serializers.HyperlinkedIdentityField(view_name='snippet-highlighted', format='html') class Meta: model = Snippet fields = ('url', 'id', 'highlight', 'owner', 'title', 'code', 'linenos', 'language', 'style')class UserSerializer(serializers.HyperlinkedModelSerializer): snippets = serializers.HyperlinkedRelatedField(many=True, view_name='snippet-detail', read_only=True) class Meta: model = User fields = ('url', 'id', 'username', 'snippets') 可以看到两个Meta类都多了一个’url’，这就是HyperlinkedRelatedField生成的，并且看到参数中又有一个命名空间，乍一看好像有点像reverse生成URL的套路啊？ 额…内部的实现真的是有用到reverse，通过查看源码就能追踪到那里，首先进入HyperlinkedRelatedField源码，发现里面只有一个__init__构造方法，那就继续进入它的父类HyperlinkedRelatedField的源码，发现里面有这么一个函数： 1234567891011121314def get_url(self, obj, view_name, request, format): """ Given an object, return the URL that hyperlinks to the object. May raise a `NoReverseMatch` if the `view_name` and `lookup_field` attributes are not configured to correctly match the URL conf. """ # Unsaved objects will not yet have a valid URL. if hasattr(obj, 'pk') and obj.pk in (None, ''): return None lookup_value = getattr(obj, self.lookup_field) kwargs = &#123;self.lookup_url_kwarg: lookup_value&#125; return self.reverse(view_name, kwargs=kwargs, request=request, format=format) 发现其实这个方法最后用的还是reverse方法，并且将生成的url作为返回的数据。所以继续往下看这个类的代码，会发现还有个to_representation方法里面有这么几行代码： 123456789try: url = self.get_url(value, self.view_name, request, format)except NoReverseMatch: ...if url is None: return Nonereturn Hyperlink(url, value) 这个过程下来我们大概能知道HyperlinkedIdentityField也能帮我们生成相应url，并且是一个超链接的形式。 另外注意到我们想要让代码高亮API只用HTML呈现，所以还设置了format=’html’参数限定了后缀。 为各个URL模式命名上面的程序为了生成url又是reverse又是HyperlinkedIdentityField的，其中的参数都用到了命名，所以我们想要生成正确的url就要给各个URL模式根据上面的参数正确命名。 编辑 snippets/urls.py，添加命名： 1234567891011121314from django.conf.urls import urlfrom snippets import viewsfrom rest_framework.urlpatterns import format_suffix_patternsurlpatterns = [ url(r'^snippets/$', views.SnippetList.as_view(),name='snippet-list'), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', views.SnippetDetail.as_view(),name='snippet-detail'), url(r'^users/$',views.UserList.as_view(),name='user-list'), url(r'^users/(?P&lt;pk&gt;[0-9]+)/$',views.UserDetail.as_view(),name='user-detail'), url(r'^$',views.api_root), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlighted/$',views.SnippetHighlight.as_view(),name='snippet-highlighted'),]urlpatterns = format_suffix_patterns(urlpatterns) 添加分页如果我们创建的用户和代码段都很多的话，再查看列表是全部显示在一页有时候可能有点难看，所以这里需要添加一个分页设置，很简单，只需要在项目的settings.py中添加一个配置字典： 123REST_FRAMEWORK = &#123; 'PAGE_SIZE': 10&#125; 这样就可以实现分页了 OK，现在我们的项目通过使用各种超链接来关联，API之间已经可以方便的进行花式跳转了。 实际效果首先是API根页面： 里面的链接都是可以点击的，下面是单个Snippet详情页： 最后是代码高亮页面，其实就是highlighted中的HTML代码被浏览器渲染后的样子： 想要这个页面的源码的话除了在浏览器右键打开，还可以直接SnippetSerializer下面的Meta类中，直接为field再加一个’highlighted’，然后浏览的时候就会发现Snippet详情页多了个highlighted键，它的值就是很长很长的一坨HTML代码，这代码生成的页面其实就是上面那个图的样子。 OK，关于添加超链接提高模型间的关联性的介绍就先到这了。下一篇文章会介绍视图集和路由相关的内容。 声明本篇文章来自ziv的博客，仅作整理学习分享。点击这里访问原文。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：权限控制]]></title>
    <url>%2F2018%2F04%2F07%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[现在我们的API还有一个很明显的缺陷，那就是没有认证和权限功能，任何资源都会任何用户被随意更改，所以我们要添加这一功能。 需求分析我们要改进程序，实现以下功能： snippet与其创建者相互关联 只有经过身份验证（登录）的用户才可以创建snippets 只有创建该snippet的用户才可以对其进行更改或者删除 未经验证的用户只具有访问（只读）的功能 修改snippet模型首先，我们想让snippets都和它们的创建用户关联起来，所以我们自然的要在Snippet模型添加一个owner字段来表示。另外，我们还添加一个highlighted字段用来实现代码高亮，修改snippets/models.py的Snippet：12owner = models.ForeignKey('auth.User', related_name='snippets', on_delete=models.CASCADE)highlighted = models.TextField() 想要实现代码高亮，当然不是上面一行代码就搞定了，它现在还只是一个普通的字段而已。我们要做的是在保存的时候，也就是当执行save()时, 我们使用pygments生成高亮后的HTML，还是在model.py,首先导入相关的库: 123from pygments.lexers import get_lexer_by_namefrom pygments.formatters.html import HtmlFormatterfrom pygments import highlight 然后在Snippet类中添加save()方法： 1234567891011def save(self, *args, **kwargs): """ 使用pygments库来生成能使代码高亮的HTML代码 """ lexer = get_lexer_by_name(self.language) linenos = self.linenos and 'table' or False options = self.title and &#123;'title': self.title&#125; or &#123;&#125; formatter = HtmlFormatter(style=self.style, linenos=linenos, full=True, **options) self.highlighted = highlight(self.code, lexer, formatter) super(Snippet, self).save(*args, **kwargs) 在保存数据的时候就会执行上面这个方法，整个方法的功能如注释所示，在这一篇文章中还不会具体的展示这个功能，在接下来的文章中会展示。 修改了模型当然需要同步一下数据库了，在这里我们和官方文档一样把数据库删了在重新生成，首先把工程目录下的db.sqlite3以及snippets下的migrations文件夹删除，然后再执行迁移步骤： 12python manage.py makemigrations snippetspython manage.py migrate 同时，由于我们想要实现的是访问各个snippet时显示相应的创建者，所以这里需要创建几个不同的账户稍后才可以显示。 1python manage.py createsuperuser 为用户模型添加端点原理和之前的SnippetSerializer基本一样，在snippets/serializers.py中添加一个User序列化器： 12345678from django.contrib.auth.models import Userclass UserSerializer(serializers.ModelSerializer): snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all()) class Meta: model = User fields = ('id', 'username', 'snippets') 注意到里面的： 1snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all()) 因为snippets在User模型中是一个反向关系，在使用ModelSerializer类时默认情况是不会包括这个关系，就是说通过Snippet的owner能查询到User，而User这边查询不到一个用户创建的snippet，所以我们需要手动为用户序列添加这个字段。 弄好了User的序列化器，接着就要让其能够显示出来，所以要添加相关的视图类，编辑view.py: 123456789101112from django.contrib.auth.models import Userfrom snippets.serializers import UserSerializerclass UserList(generics.ListAPIView): queryset = User.objects.all() serializer_class = UserSerializerclass UserDetail(generics.RetrieveAPIView): queryset = User.objects.all() serializer_class = UserSerializer 写好了视图函数，想要通过URL访问到它们，肯定是配置一下路由分发啦，编辑snippets/urls.py添加下面的匹配模式： 12url(r'^users/$', views.UserList.as_view()),url(r'^users/(?P&lt;pk&gt;[0-9]+)/$', views.UserDetail.as_view() 关联Snippets和Users到了这里，如果像之前那样创建代码段的话，我们还不能把Snippets和Users关联起来。因为在使用的时候User的数据是通过request传入的，而不是以序列化的数据传递过来。 而我们刚才添加了一个owner作为外键，这个时候就要看到它的用处了，编辑view.py,为SnippetList视图类添加一个方法： 1234567class SnippetList(generics.ListCreateAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer permission_classes = (permissions.IsAuthenticatedOrReadOnly,) def perform_create(self, serializer): serializer.save(owner=self.request.user) 这个perform_create() 可以让用户在通过POST请求创建一个新的Snippet时，在保存新的Snippet数据的时候会把request中的user赋值给Snippet的owner。等下具体使用的时候就可以轻松的理解了。 更新serializer上一步已经把两者关联起来了，owner会在创建新的Snippet的时候拥有User的各个属性，那么在API中要让owner显示id还是用户名，为了提高可读性，答案当然是显示用户名了，所以我们在SnippetSerializer 下面增加一个字段： 1owner = serializers.ReadOnlyField(source='owner.username') 这里的source参数就指定了哪个属性用于填充字段，为了在使用的时候显示owner，但是还要把它添加进Meta类里面，所以整个SnippetSerializer如下： 1234567class SnippetSerializer(serializers.ModelSerializer): # 这里可以使用也 CharField(read_only=True) 来替换 owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style','owner') 添加权限现在Snippet和User已经关联起来并且是可浏览的。接下来我们要实现的及时权限的问题了。也就是我们一开始说的几点中的： 只有经过身份验证（登录）的用户才可以创建snippet 只有创建该snippet的用户才可以对其进行更改或者删除 未经验证的用户只具有访问（只读）的功能 首先在views.py导入一个库： 1from rest_framework import permissions 接着为SnippetList 和 SnippetDetail添加权限判断，在这两个视图类中都加入： 1permission_classes = (permissions.IsAuthenticatedOrReadOnly, ) 这里要特别注意，有一个坑，就是那个逗号一定要加上去，不然就会报错。这行代码的作用就是判断当前用户是否为该Snippet的创建者，而其他用户只有只读属性，就是只能查看。 为可浏览的API添加登录功能刚才添加了权限判断，如果没有登录用户，那就相当于游客啦，什么功能都没有只能看，所以在浏览器浏览API的时候就需要登录 功能。在这里，强大的django-rest-framework又为我们做了很多事情，想要在添加登录按钮和页面，只需要修改一个rest_tutorial/urls.py，添加一个URL匹配： 1234urlpatterns += [ url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework')),] 这里的r&#39;^api-auth/&#39;你可以设置成任意你喜欢的，但是命名空间一定要相同，就是namespace=&#39;rest_framework。 好了，现在打开浏览器，就可以看到在我们的API页面的右上角有一个登录的按钮，点击之后就可以使用之前创建的用户登录了。 这个时候访问单个用户的详情，就可以看到该用户创建的所有Snippet的id值（需要先创建好几个Snippet，可以按照本系列第一篇文章中在shell模式中的方法来创建）。比如访问： 1http://127.0.0.1:8000/users/ 添加对象权限接着我们要实现的是让所有的Snippet可以被所有人访问到，但是每个Snippet只有其创建者才可以对其进行更改、删除等操作。 因此，我们需要设置一下自定义权限，使每个Snippet只允许其创建者编辑它。在snippets目录下新建一个permissions.py： 1234567891011121314151617from rest_framework import permissionsclass IsOwnerOrReadOnly(permissions.BasePermission): """ 使每个Snippet只允许其创建者编辑它 """ def has_object_permission(self, request, view, obj): # 任何用户或者游客都可以访问任何Snippet，所以当请求动作在安全范围内， # 也就是GET，HEAD，OPTIONS请求时，都会被允许 if request.method in permissions.SAFE_METHODS: return True # 而当请求不是上面的安全模式的话，那就需要判断一下当前的用户 # 如果Snippet所有者和当前的用户一致，那就允许，否则返回错误信息 return obj.owner == request.user 代码的逻辑已在注释中，简单说就是提供判断功能，然后我们要把它运用起来，在view.py中的SnippetDetail 修改一下： 12345class SnippetDetail(generics.RetrieveUpdateDestroyAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer permission_classes = (permissions.IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly,) 注意要导入IsOwnerOrReadOnly类： 1from snippets.permissions import IsOwnerOrReadOnly 现在用浏览器打开单个Snippet详情页，如果你当前登录的用户是这个Snippet的创建者，那你会发现多了DELETE和PUT两个操作，比如访问http://127.0.0.1:8000/snippets/2/，效果如下： 使用API授权由于现在我们还没使用authentication 类，所以项目目前还是使用默认的SessionAuthentication 和 BasicAuthentication. 在使用浏览器访问API的时候，浏览器会帮我们保存会话信息，所以当权限满足时就可以对一个Snippet进行删除或者更改，或者是创建一个新的Snippet。 当如果是通过命令行来操作API，我们就必须在每次发送请求的时候添加授权信息，也就是用户名和密码，没有的话就会报错，比如： 12345http POST http://127.0.0.1:8000/snippets/ code=&quot;print 123&quot;&#123; &quot;detail&quot;: &quot;Authentication credentials were not provided.&quot;&#125; 正确的操作如下： 1234567891011http -a username:password POST http://127.0.0.1:8000/snippets/ code=&quot;print 789&quot;&#123; &quot;id&quot;: 1, &quot;owner&quot;: &quot;username1&quot;, &quot;title&quot;: &quot;&quot;, &quot;code&quot;: &quot;print 789&quot;, &quot;linenos&quot;: false, &quot;language&quot;: &quot;python&quot;, &quot;style&quot;: &quot;friendly&quot;&#125; 我们可以看出owner就是提交过来的用户名，这就是上面代码的功能体现： 12def perform_create(self, serializer): serializer.save(owner=self.request.user) 通过实际使用更能理解程序，owner会在一个用户创建Snippet时得到该用户的信息就是这么来的。 声明本篇文章来自ziv的博客，仅作整理学习分享。点击这里访问原文。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：类视图]]></title>
    <url>%2F2018%2F04%2F06%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E7%B1%BB%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，主要讲的是请求和响应，项目里面views.py中的视图函数都是基于函数的，并且我们介绍了@api_view这个很有用的装饰器。同时，我们还介绍了APIView这个类，但是还没使用它。在这篇文章中，我们要做的是把基于方法的视图改为基于类的视图，将会了解到APIView。 改为基于类的视图重构一下snippets/view.py： 1234567891011121314151617181920212223from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom django.http import Http404from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework import statusclass SnippetList(APIView): """ 列出所有已经存在的snippet或者创建一个新的snippet """ def get(self, request, format=None): snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) def post(self, request, format=None): serializer = SnippetSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 到这里应该很容易理解，和原来的相比，可以发现基于类的视图把各种不同的HTTP请求分离开变成单个的方法，而不是if...elif...这样的结构，所以这样处理起来很更加的高效。 同样的，把另一个视图函数也进行修改： 123456789101112131415161718192021222324252627class SnippetDetail(APIView): """ 检索查看、更新或者删除一个snippet """ def get_object(self, pk): try: return Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: raise Http404 def get(self, request, pk, format=None): snippet = self.get_object(pk) serializer = SnippetSerializer(snippet) return Response(serializer.data) def put(self, request, pk, format=None): snippet = self.get_object(pk) serializer = SnippetSerializer(snippet, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) def delete(self, request, pk, format=None): snippet = self.get_object(pk) snippet.delete() return Response(status=status.HTTP_204_NO_CONTENT) 修改路由改为基于类的视图之后，当然也要修改一下路由了，对snippets/urls.py稍加修改： 12345678910from django.conf.urls import urlfrom rest_framework.urlpatterns import format_suffix_patternsfrom snippets import viewsurlpatterns = [ url(r'^snippets/$', views.SnippetList.as_view()), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', views.SnippetDetail.as_view()),]urlpatterns = format_suffix_patterns(urlpatterns) 使用mixins类使用基于类的视图的好处除了上面所说的把各种HTTP请求分离开，还有什么好处吗？答案是肯定的——使用基于类的视图的最大优势之一是它可以轻松地构成可重复使用的行为。 可重复使用的行为？简单说，就是让我们少写一点功能类似的代码，由此就要介绍一下mixins类了，它帮我们封装了很多操作，简化代码，使用也很简单，编辑snippets/view.py函数： 12345678910111213141516from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom rest_framework import mixinsfrom rest_framework import genericsclass SnippetList(mixins.ListModelMixin, mixins.CreateModelMixin, generics.GenericAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) 新的视图类中继承了 generic.GenericAPIView、mixins.ListModelMixin和mixins.CreatteModelMixin，类的作用看字面意思就能懂啦，mixins类为我们提供了list()和create()方法，当然，使用这两个函数需要先设置queryset和serializer_class，这点我们查看一下mixins的源码就可以看出来了，比如list方法： 1234567891011121314class ListModelMixin(object): """ List a queryset. """ def list(self, request, *args, **kwargs): queryset = self.filter_queryset(self.get_queryset()) page = self.paginate_queryset(queryset) if page is not None: serializer = self.get_serializer(page, many=True) return self.get_paginated_response(serializer.data) serializer = self.get_serializer(queryset, many=True) return Response(serializer.data) 这里的代码会分别通过get_queryset()和get_serializer()得到查询集和序列化器，其他封装好的方法也是如此。 知道了这个，再修改一下另一个视图类就很容易了： 123456789101112131415class SnippetDetail(mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, generics.GenericAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer def get(self, request, *args, **kwargs): return self.retrieve(request, *args, **kwargs) def put(self, request, *args, **kwargs): return self.update(request, *args, **kwargs) def delete(self, request, *args, **kwargs): return self.destroy(request, *args, **kwargs) 使用generics视图类到这里，视图代码已经简化了许多了，但是我要告诉你的是，还可以进一步简化。进一步简化就是连mixins类都不用了，只使用generics就可以了，代码如下 12345678910111213from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom rest_framework import genericsclass SnippetList(generics.ListCreateAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializerclass SnippetDetail(generics.RetrieveUpdateDestroyAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer 好了，现在的代码就显得非常简洁了，但是短小却精悍，依然可以实现原本的功能。 测试Api测试方法和上篇雷同，可跳过。1http http://127.0.0.1:8000/snippets/ 通过设置Accept头部信息来控制返回的格式 12http http://127.0.0.1:8000/snippets/ Accept:application/json # JSONhttp http://127.0.0.1:8000/snippets/ Accept:text/html # HTML 效果如下（返回的是页面的HTML代码，只展示了一部分）： 直接加格式后缀 12http http://127.0.0.1:8000/snippets.json # JSON suffixhttp http://127.0.0.1:8000/snippets.api # Browsable API suffix 浏览器查看Api 我们可以直接在浏览器输入 http://127.0.0.1:8000/snippets.api 进行查看，会得到一个美观的页面： 增加数据我们可以控制 Content-Type 头部信息来提交POST请求： 12http --form POST http://127.0.0.1:8000/snippets/ code=&quot;print 123&quot;http --json POST http://127.0.0.1:8000/snippets/ code=&quot;print 456&quot; 它会自动在原有的数据后面添加你提交过去的数据，效果如下： 修改数据我们通过PUT来实现修改功能，在我们之前定义的函数views.snippet_detail中： 1url(r'^snippets/(?P&lt;pk&gt;[0-9]+)$', views.snippet_detail), 所以通过 url snippets/[id]就可以访问到我们要的数据，就可以对其进行修改。 1http --json PUT http://127.0.0.1:8000/snippets/1.json code="sss" 删除数据同之前的修改一样，我们使用DELETE，通过 url snippets/[id]访问数据，提交删除。 1http DELETE http://127.0.0.1:8000/snippets/8.json 这样我们就成功的删除了一条数据。 声明本篇文章来自ziv的博客，仅作整理学习分享。点击这里访问原文。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：请求与响应]]></title>
    <url>%2F2018%2F04%2F06%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[之前已经实现了访问指定URL就返回了指定的数据，这也体现了RESTful-API的一个理念，每一个URL代表着一个资源。当然RESTful API的另一个特性就是，发送不同的请求动作，会返还不同的响应。 Request对象平时我们在写Django的视图函数的时候，都会带上一个request参数，这样就能处理平时搭建网站时，浏览器访问网页时发出的常规的HttpRequest。但是现在我们导入了django-rest-framework，它能够对request进行拓展，并且提供更灵活的请求解析。这个特性体现在哪呢？请看下面这个例子： 12request.POST # 只能处理表单数据.只能处理POST请求request.data # 能处理各种数据。 可以处理'POST', 'PUT' 和 'PATCH'模式的请求 这个例子里面的注释已经说得很清楚，拓展后的request使用request.data就可以处理各种各样的请求了，而原本的request在处理时需要指定请求模式。 Response对象和request对象一样，django-rest-framewor也对其进行了很实用的拓展，在我上一篇文章的snippets/views.py中，我们导入了JsonResponse用于返回json格式的响应，在视图函数中是这样的： 1234567891011121314151617@csrf_exemptdef snippet_list(request): """ 列出所有已经存在的snippet或者创建一个新的snippet """ if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return JsonResponse(serializer.data, safe=False) elif request.method == 'POST': data = JSONParser().parse(request) serializer = SnippetSerializer(data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400) 也就是说，在return的时候就需要指明json格式，这样显得很不实用而且很单一，所以经过拓展后的Reponse对象就很方便了，它会根据客户端的请求头部信息来确定正确的内容类型以返回给客户端。只需如下代码： 1return Response(data) 状态码我们知道发送http请求时会返回各种各样的状态吗，但是都是简单的数字，比如200、404等，这些纯数字标识符有时候可能不够明确或者客户端在使用的时候不清楚错误信息甚至是没注意看不到，所以django-rest-framework也对此进行了优化，状态码会是HTTP_400_BAD_REQUEST、HTTP_404_NOT_FOUND这种，极大的提高可读性。 装饰API视图REST框架还提供了一个装饰器和一个类来包装视图函数，可以使用它们来写API视图，让程序能处理的情况更多。 @api_view装饰器用在基于视图的方法上。 APIView类用在基于视图的类上。 注意： 这里使用的是基于视图方法，所以使用的是装饰器@api_view，APIview这个类暂时不会提及。 这两个东西提供的一些功能，让我们省去很多工作，比如说确保你在视图中收到Request对象或在你的Response对象中添加上下文，这样就能实现内容通信。 另外装饰器可以在接收到输入错误的request.data时抛出ParseError异常，或者在适当的时候返回405 Method Not Allowed状态码。 改进代码上面说了这么多拓展和优化，接下来就把它们都使用起来，改进一下原本的snippets/views.py，程序如下： 1234567891011121314151617181920212223from rest_framework import status # 导入HHTP状态from rest_framework.decorators import api_view #导入装饰器from rest_framework.response import Response #导入应答from snippets.models import Snippet # 导入数据库类from snippets.serializers import SnippetSerializer # 导入之前写好的序列化函数@api_view(['GET', 'POST'])def snippet_list(request): """ 列出所有已经存在的snippet或者创建一个新的snippet """ if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) elif request.method == 'POST': serializer = SnippetSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 可以看出，经过改进的代码已经把上面所说的几个django-rest-framework带来的特性都应用起来了，我们可以看出程序代码量变少，并且能处理的情况更多了。 比如说，在原本的视图函数snippet_detail中，处理&#39;PUT&#39;请求的时候，需要先解析json格式的数据再进一步处理： 12data = JSONParser().parse(request)serializer = SnippetSerializer(snippet, data=data) 也就是说需要分成两步实现，而且这里有一个限制就是只能解析json格式的数据流。而改进后的程序只需一行代码： 1serializer = SnippetSerializer(data=request.data) 直接使用之前说的request.data就可以获取到提交过来的数据了，并且可以处理各种数据和各种请求动作，方便了开发。 还有在return的时候也不需要指定json格式了，由原本的 1return JsonResponse(serializer.data, status=201) 改成了 1return Response(serializer.data,status=status.HTTP_201_CREATED) 这也意味着返回给客户端的可以是json或者html等格式的内容，返回HTML格式的内容的话，会在浏览器返回经过渲染的、更美观的页面。同时可以看出状态码也改进成了django-rest-framework给我们带来的可读性更高的状态标识码，以上这些措施都很大程度的提高了对客户的友好度。 对于另一个视图函数的修改也是同样的原理，这里就不做同样的讲解了，代码如下： 123456789101112131415161718192021222324@api_view(['GET', 'PUT', 'DELETE'])def snippet_detail(request, pk): """ Retrieve, update or delete a snippet instance. """ try: snippet = Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: return Response(status=status.HTTP_404_NOT_FOUND) if request.method == 'GET': serializer = SnippetSerializer(snippet) return Response(serializer.data) elif request.method == 'PUT': serializer = SnippetSerializer(snippet, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) elif request.method == 'DELETE': snippet.delete() return Response(status=status.HTTP_204_NO_CONTENT) 以上就是对原有的常规的Django视图函数的改进。 总结一下： 处理request提交过来的数据不需要一定是json格式的数据，返回的响应也不需要一定是json数据，也可以是经过渲染的HTML页面。稍后就会示范使用。 URL添加格式后缀既然上面已经说了返回给客户端的Response可是json或者是HTML等格式的内容，那么用户在使用的时候是如何指定返回哪种格式的内容呢，那就是在URL的最后加上后缀。比如http://127.0.0.1:8000/snippets.json，这样就是用户自己指定了返回json格式的Response，而不是我们在后台指定返回固定的格式。 只需对我们的程序稍加改进就可以了，在两个视图函数添加关键词参数format： 12def snippet_list(request, format=None): ... 以及 12def snippet_detail(request, pk, format=None): ... 再修改一下snippets/urls.py，导入format_suffix_patterns（格式后缀模式）： 12345678910from django.conf.urls import urlfrom rest_framework.urlpatterns import format_suffix_patternsfrom snippets import viewsurlpatterns = [ url(r'^snippets/$', views.snippet_list), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)$', views.snippet_detail),]urlpatterns = format_suffix_patterns(urlpatterns) 测试Api首先当然还是可以像上一篇文章中那样的使用： 1http http://127.0.0.1:8000/snippets/ 通过设置Accept头部信息来控制返回的格式 12http http://127.0.0.1:8000/snippets/ Accept:application/json # JSONhttp http://127.0.0.1:8000/snippets/ Accept:text/html # HTML 效果如下（返回的是页面的HTML代码，只展示了一部分）： 直接加格式后缀 12http http://127.0.0.1:8000/snippets.json # JSON suffixhttp http://127.0.0.1:8000/snippets.api # Browsable API suffix 浏览器查看Api 我们可以直接在浏览器输入 http://127.0.0.1:8000/snippets.api 进行查看，会得到一个美观的页面： 实现功能增加数据我们可以控制 Content-Type 头部信息来提交POST请求： 12http --form POST http://127.0.0.1:8000/snippets/ code=&quot;print 123&quot;http --json POST http://127.0.0.1:8000/snippets/ code=&quot;print 456&quot; 它会自动在原有的数据后面添加你提交过去的数据，效果如下： 修改数据我们通过PUT来实现修改功能，在我们之前定义的函数views.snippet_detail中： 1url(r'^snippets/(?P&lt;pk&gt;[0-9]+)$', views.snippet_detail), 所以通过 url snippets/[id]就可以访问到我们要的数据，就可以对其进行修改。 1http --json PUT http://127.0.0.1:8000/snippets/1.json code="sss" 删除数据同之前的修改一样，我们使用DELETE，通过 url snippets/[id]访问数据，提交删除。 1http DELETE http://127.0.0.1:8000/snippets/8.json 这样我们就成功的删除了一条数据。 声明本篇文章来自ziv的博客，仅作整理学习分享。点击这里访问原文]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：序列化]]></title>
    <url>%2F2018%2F04%2F06%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[利用Django框架实现Restful-Api的序列化，即当其他人访问这个URL时返回json格式的数据。 搭建环境首先当然是在虚拟环境中使用了，这里我们使用Django-REST-Framework的库，需要用到的包： 123pip install djangopip install djangorestframeworkpip install pygments # 用来实现代码高亮 创建工程首先创建一个名为tutorial的工程，然后在这个工程中创建一个snippets的APP： 123django-admin.py startproject tutorialcd tutorialpython manage.py startapp snippets 创建完成之后在tutorial/settings.py中修改一下INSTALLED_APPS，添加两个APP： 12345INSTALLED_APPS = ( ... 'rest_framework', 'snippets.apps.SnippetsConfig', # 如果Django&lt;1.9，那么使用snippets代替) 创建模型类创建一个Snippet模型类，用于储存代码段，编写snippets/models.py： 12345678910111213141516171819from django.db import modelsfrom pygments.lexers import get_all_lexersfrom pygments.styles import get_all_stylesLEXERS = [item for item in get_all_lexers() if item[1]]LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS]) # 得到所有的编程语言STYLE_CHOICES = sorted((item, item) for item in get_all_styles()) # 得到所有的配色风格class Snippet(models.Model): created = models.DateTimeField(auto_now_add=True) title = models.CharField(max_length=100, blank=True, default='') code = models.TextField() linenos = models.BooleanField(default=False) language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100) style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100) class Meta: ordering = ('created',) 除了注释的那里，其他的代码都很常规，和我们平时Django开发时是一样的。然后就为这个模型创建并迁移数据（这里只是为了展示，所以使用的数据库是Django自带的那个sqlite）： 12python manage.py makemigrations snippetspython manage.py migrate 创建序列化类首先解释一下序列化：在这里可以先简单的理解为serializer，把模型实例转化为json格式然后响应出去，这样便于客户端调用时解析使用。 例如一个PostModel，里面有两个字段分别为title和author，序列化之后就是{&#39;title&#39;:&#39;RESTful API&#39;,&#39;author&#39;:&#39;liu&#39;}这样的json格式，这样明显就更适合各种客户端的使用人员解析使用。 那么反序列化其实道理差不多，反序列化之后的数据格式更便于后台使用，等下会有例子加深理解。 解释完序列化，那么接下来就该敲代码了，在snippets下面创建一个serializers.py，代码如下： 1234567891011121314151617181920212223242526from rest_framework import serializersfrom snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICESclass SnippetSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(required=False, allow_blank=True, max_length=100) # 利用字段标志控制序列化器渲染到HTML页面时的的显示模板 code = serializers.CharField(style=&#123;'base_template': 'textarea.html'&#125;) linenos = serializers.BooleanField(required=False) language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python') style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly') # 给定经过验证的数据，创建并返回一个新的 Snippet 实例 def create(self, validated_data): return Snippet.objects.create(**validated_data) # 给定经过验证的数据，更新并返回一个已经存在的 Snippet 实例 def update(self, instance, validated_data): instance.title = validated_data.get('title', instance.title) instance.code = validated_data.get('code', instance.code) instance.linenos = validated_data.get('linenos', instance.linenos) instance.language = validated_data.get('language', instance.language) instance.style = validated_data.get('style', instance.style) instance.save() return instance create和update方法定义在调用serializer.save()时如何创建或修改完整的实例。 关于下面这行代码： 1code = serializers.CharField(style=&#123;'base_template':'textarea.html'&#125;) 暂时需要知道的就是它的功能是控制序列化器渲染到HTML页面时的的显示模板，至于为什么要这样做，是因为这对于控制如何显示可浏览的API特别有用，这将在后面的文章中看到。 使用序列化器首先进入shell模式： 1python manage.py shell 接下来的操作就和学习Django的orm时那样，创建并保存Snippet模型实例： 12345678&gt;&gt;&gt; from snippets.models import Snippet&gt;&gt;&gt; from snippets.serializers import SnippetSerializer&gt;&gt;&gt; from rest_framework.renderers import JSONRenderer&gt;&gt;&gt; from rest_framework.parsers import JSONParser&gt;&gt;&gt; snippet = Snippet(code='foo = "bar"\n')&gt;&gt;&gt; snippet.save()&gt;&gt;&gt; snippet = Snippet(code='print "hello, world"\n')&gt;&gt;&gt; snippet.save() 这个时候查看数据库就会发现相关的表中已经多了两行数据，就是我们刚才创建的数据： image 也可以继续在shell中查看： 1234&gt;&gt;&gt; serializer = SnippetSerializer(snippet)&gt;&gt;&gt; serializer.data&#123;'code': 'print "hello, world"\n', 'title': '', 'linenos': False, 'style': 'friendly', 'language': 'python', 'id': 2&#125; 将数据渲染成json格式： 1234&gt;&gt;&gt; content = JSONRenderer().render(serializer.data)&gt;&gt;&gt; contentb'&#123;"id":2,"title":"","code":"print \\"hello, world\\"\\n","linenos":false,"language":"python","style":"friendly"&#125;' 这里已经出现了json格式，也就是说这个json格式的数据就是要展示在某个URL上，大概可以感觉到，等下我们在访问某个URL时，会返回上面这堆数据供你使用，这其实就完成了一个序列化的过程，也可以看出客户端的功能雏形。 序列化是为了返回json格式的数据给客户端查看和使用数据，那么当客户端需要修改、增加或者删除数据时，就要把过程反过来了，也就是反序列化，把客户端提交的json格式的数据反序列化。 下面的代码把json数据流解析成Python自带的数据格式，便于我们后台Django的操作： 123&gt;&gt;&gt; from django.utils.six import BytesIO&gt;&gt;&gt; stream = BytesIO(content)&gt;&gt;&gt; data = JSONParser().parse(stream) 检查并保存数据： 12345678&gt;&gt;&gt; serializer = SnippetSerializer(data=data)&gt;&gt;&gt; serializer.is_valid()True&gt;&gt;&gt; serializer.validated_dataOrderedDict([('title', ''), ('code', 'print "hello, world"'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])&gt;&gt;&gt; serializer.save()&lt;Snippet: Snippet object&gt; 这个时候查看数据库又多了一条数据： 使用 ModelSerializers在上面的SnippetSerializer类中，我们继承的是serializers.Serializer类，可以看到SnippetSerializer类中有很多代码其实是和models.py中的Snippet模型类似一样的，所以这里我们可以改进一下。就像在Django中提供了Form类和ModelForm类一样，django-rest-framework为我们提供了Serializer类和ModelSerializer类。利用它可以让我们的代码简洁很多，修改serializers.py： 1234class SnippetSerializer(serializers.ModelSerializer): class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style') 我们可以通过在shell中的打印来检查序列化器实例中的所有字段： 123&gt;&gt;&gt; from snippets.serializers import SnippetSerializer&gt;&gt;&gt; serializer = SnippetSerializer()&gt;&gt;&gt; print(repr(serializer)) 打印后出现的效果如下（language非常长，只截取了一部分）： 在我们新的SnippetSerializer类中，可以发现和之前的对比代码少了很多，这里体现了ModelSerializer 类的快捷： 自动确定字段 create和update方法的简单默认实现 编写Django视图接下来要做的就是使用我们的新的Serializer类编写一些API视图。编辑snippets/views.py： 点击查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from django.http import HttpResponse, JsonResponsefrom django.views.decorators.csrf import csrf_exemptfrom rest_framework.renderers import JSONRendererfrom rest_framework.parsers import JSONParserfrom snippets.models import Snippetfrom snippets.serializers import SnippetSerializer# Create your views here.@csrf_exemptdef snippet_list(request): """ 列出所有已经存在的snippet或者创建一个新的snippet """ if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return JsonResponse(serializer.data, safe=False) elif request.method == 'POST': data = JSONParser().parse(request) serializer = SnippetSerializer(data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400)@csrf_exemptdef snippet_detail(request, pk): """ 检索查看、更新或者删除一个代码段 """ try: snippet = Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: return HttpResponse(status=404) if request.method == 'GET': serializer = SnippetSerializer(snippet) return JsonResponse(serializer.data) elif request.method == 'PUT': data = JSONParser().parse(request) serializer = SnippetSerializer(snippet, data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data) return JsonResponse(serializer.errors, status=400) elif request.method == 'DELETE': snippet.delete() return HttpResponse(status=204) 上面的代码都比较好理解，定义了不同http动作时后台不同的操作，在这里也体现了restful API的理念。 需要注意的是记得添加@csrf_exempt修饰器。 设计Django的urls为了让视图函数被调用，那当然需要设计一下url了，这里的处理和平时Django开发时是一样的。首先创建snippets/urls.py： 1234567from django.conf.urls import urlfrom snippets import viewsurlpatterns = [ url(r'^snippets/$', views.snippet_list), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', views.snippet_detail),] 接着就是tutorial/urls.py，代码如下： 12345from django.conf.urls import url, includeurlpatterns = [ url(r'^', include('snippets.urls')),] 对API进行测试完成了上面那些工作后，就可以开始测试了，退出shell模式并启动服务器，根据我们刚才设计的url发送请求，需要先安装httpie模块： 1pip install httpie 然后在命令行窗口访问，效果如下： 或者也可以直接在浏览输入网址访问。 到这里，也就实现了一个功能，当其他人访问这个URL时返回json格式的数据给他使用。 声明本篇文章来自ziv的博客，仅作整理学习分享。 点击这里访问原文]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Restful-Api介绍]]></title>
    <url>%2F2018%2F04%2F04%2FRestful-Api%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[为了方便不同的前端设备与后端进行通信，这导致API构架的流行，甚至出现”API First”的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。 Restful架构 点击这里查看 要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。 资源（Resources）REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 表现层（Representation）“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 状态转化（State Transfer）访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 综述综合上面的解释，我们总结一下什么是RESTful架构： （1）每一个URI代表一种资源； （2）客户端和服务器之间，传递这种资源的某种表现层； （3）客户端通过HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 协议API与用户的通信协议，总是使用HTTPs协议。 域名应该尽量将API部署在专用域名之下。 1https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 1https://example.org/api/ 版本（Versioning）应该将API的版本号放入URL。 1https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 路径（Endpoint）路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 例子有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 123https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees HTTP动词对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 还有两个不常用的HTTP动词。 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 例子 例子 描述 GET /zoos 列出所有动物园 POST /zoos 新建一个动物园 GET /zoos/ID 获取某个指定动物园的信息 PUT /zoos/ID 更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID 更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID 删除某个动物园 GET /zoos/ID/animals 列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID 删除某个指定动物园的指定动物 过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 下面是一些常见的参数。 12345?limit=10：指定返回记录的数量?offset=10：指定返回记录的开始位置。?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 状态码的完全列表参见这里。 错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: "Invalid API key"&#125; 返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。 123456GET /collection 返回资源对象的列表（数组）GET /collection/resource 返回单个资源对象POST /collection 返回新生成的资源对象PUT /collection/resource 返回完整的资源对象PATCH /collection/resource 返回完整的资源对象DELETE /collection/resource 返回一个空文档 Hypermedia APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 123456&#123;"link": &#123; "rel": "collection https://www.example.com/zoos", "href": "https://api.example.com/zoos", "title": "List of zoos", "type": "application/vnd.yourformat+json"&#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。 12345&#123; "current_user_url": "https://api.github.com/user", "authorizations_url": "https://api.github.com/authorizations", // ...&#125; 从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。 1234&#123; "message": "Requires authentication", "documentation_url": "https://developer.github.com/v3"&#125; 上面代码表示，服务器给出了提示信息，以及文档的网址。 其他（1）API的身份认证应该使用OAuth 2.0框架。 （2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 声明本文来自阮一峰先生，仅作整理学习使用。 访问原文请点击这里。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax的介绍与实现方法]]></title>
    <url>%2F2018%2F04%2F02%2FAjax%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[AJAX翻译成中文就是“异步+Javascript+XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML）。 Ajax特点1.异步传输同步与异步的区别 同步交互：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求； 异步交互：客户端发出一个请求后，无需等待服务器响应结束，就可以发出第二个请求。 2.局部刷新并不是重新加载全部页面，仅仅加载需要加载的那一部分。这一特点给用户的感受是在不知不觉中完成请求和响应过程。 应用场景举例1.在百度搜索栏输入内容，会自动弹出联想输入内容提示： 2.注册账号的时候，输入已存在的用户名会给与提示： Ajax的优缺点优点 AJAX使用Javascript技术向服务器发送异步请求； AJAX无须刷新整个页面； 因为服务器响应内容不再是整个页面，而是页面中的局部，所以AJAX性能高； 缺点 AJAX并不适合所有场景，很多时候还是要使用同步交互； AJAX虽然提高了用户体验，但无形中向服务器发送的请求次数增多了，导致服务器压力增大； 因为AJAX是在浏览器中使用Javascript技术完成的，所以还需要处理浏览器兼容性问题； Ajax代码实现基于js的ajaxAJAX核心（XMLHttpRequest）其实AJAX就是在Javascript中多添加了一个对象：XMLHttpRequest对象。所有的异步交互都是使用XMLHttpServlet对象完成的。也就是说，我们只需要学习一个Javascript的新对象即可。 1var xmlHttp = new XMLHttpRequest()；//（大多数浏览器都支持DOM2规范） 注意：各个浏览器对XMLHttpRequest的支持也是不同的！为了处理浏览器兼容问题，给出下面方法来创建XMLHttpRequest对象： 123456789101112131415161718function createXMLHttpRequest() &#123; var xmlHttp; // 适用于大多数浏览器，以及IE7和IE更高版本 try&#123; xmlHttp = new XMLHttpRequest(); &#125; catch (e) &#123; // 适用于IE6 try &#123; xmlHttp = new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123; // 适用于IE5.5，以及IE更早版本 try&#123; xmlHttp = new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; 实现流程步骤1: 打开与服务器的连接（open方法）当得到XMLHttpRequest对象后，就可以调用该对象的open()方法打开与服务器的连接了。open()方法的参数如下： 1open(method, url, async)： method：请求方式，通常为GET或POST；url：请求的服务器地址，例如：/ajaxdemo1/AServlet，若为GET请求，还可以在URL后追加参数；async：这个参数可以不给，默认值为true，表示异步请求； 12var xmlHttp = createXMLHttpRequest();xmlHttp.open(&quot;GET&quot;, &quot;/ajax_get/&quot;, true); 步骤2: 发送请求当使用open打开连接后，就可以调用XMLHttpRequest对象的send()方法发送请求了。send()方法的参数为POST请求参数，即对应HTTP协议的请求体内容，若是GET请求，需要在URL后连接参数。 注意：若没有参数，需要给出null为参数！若不给出null为参数，可能会导致FireFox浏览器不能正常发送请求！ 1xmlHttp.send(null); 步骤3: 接收服务器响应当请求发送出去后，服务器端就开始执行了，但服务器端的响应还没有接收到。接下来我们来接收服务器的响应。 XMLHttpRequest对象有一个onreadystatechange事件，它会在XMLHttpRequest对象的状态发生变化时被调用。下面介绍一下XMLHttpRequest对象的5种状态： 0：初始化未完成状态，只是创建了XMLHttpRequest对象，还未调用open()方法；1：请求已开始，open()方法已调用，但还没调用send()方法；2：请求发送完成状态，send()方法已调用；3：开始读取服务器响应；4：读取服务器响应结束。 onreadystatechange事件会在状态为1、2、3、4时引发。 下面代码会被执行四次！对应XMLHttpRequest的四种状态！ 123xmlHttp.onreadystatechange = function() &#123; alert('hello'); &#125;; 但通常我们只关心最后一种状态，即读取服务器响应结束时，客户端才会做出改变。我们可以通过XMLHttpRequest对象的readyState属性来得到XMLHttpRequest对象的状态。 12345xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4) &#123; alert(&apos;hello&apos;); &#125; &#125;; 其实我们还要关心服务器响应的状态码是否为200，其服务器响应为404，或500，那么就表示请求失败了。我们可以通过XMLHttpRequest对象的status属性得到服务器的状态码。 最后，我们还需要获取到服务器响应的内容，可以通过XMLHttpRequest对象的responseText得到服务器响应内容。 12345xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; alert(xmlHttp.responseText); &#125; &#125;; if 发送POST请求需要设置请求头：1xmlHttp.setRequestHeader(“Content-Type”, “application/x-www-form-urlencoded”)； 注意 :form表单会默认这个键值对不设定，Web服务器会忽略请求体的内容。 在发送时可以指定请求体了：xmlHttp.send(“username=yuan&amp;password=123”) 测试代码 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;h1&gt;AJAX&lt;/h1&gt;&lt;button onclick="send()"&gt;测试&lt;/button&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;script&gt; function createXMLHttpRequest() &#123; try &#123; return new XMLHttpRequest();//大多数浏览器 &#125; catch (e) &#123; try &#123; return new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123; return new ActiveXObject("Microsoft.XMLHTTP"); &#125; &#125; &#125; function send() &#123; var xmlHttp = createXMLHttpRequest(); xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; var div = document.getElementById("div1"); div.innerText = xmlHttp.responseText; div.textContent = xmlHttp.responseText; &#125; &#125;; xmlHttp.open("POST", "/ajax_post/", true); //post: xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); xmlHttp.send(null); //post: xmlHttp.send("b=B"); &#125;&lt;/script&gt; #--------------------------------views.py from django.views.decorators.csrf import csrf_exemptdef login(request): print('hello ajax') return render(request,'index.html')@csrf_exempt ＃csrf防御def ajax_post(request): print('ok') return HttpResponse('helloyuanhao') 基于jquery的ajax所有方法详情查看菜单中的附录。 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123;% load staticfiles %&#125;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="&#123;% static 'JS/jquery-3.1.1.js' %&#125;"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button class="send_Ajax"&gt;send_Ajax&lt;/button&gt;&lt;script&gt; //$.ajax的两种使用方式: //$.ajax(settings); //$.ajax(url,[settings]); $(".send_Ajax").click(function()&#123; $.ajax(&#123; url:"/handle_Ajax/", type:"POST", data:&#123;username:"Yuan",password:123&#125;, success:function(data)&#123; alert(data) &#125;, //=================== error============ error: function (jqXHR, textStatus, err) &#123; // jqXHR: jQuery增强的xhr // textStatus: 请求完成状态 // err: 底层通过throw抛出的异常对象，值与错误类型有关 console.log(arguments); &#125;, //=================== complete============ complete: function (jqXHR, textStatus) &#123; // jqXHR: jQuery增强的xhr // textStatus: 请求完成状态 success | error console.log('statusCode: %d, statusText: %s', jqXHR.status, jqXHR.statusText); console.log('textStatus: %s', textStatus); &#125;, //=================== statusCode============ statusCode: &#123; '403': function (jqXHR, textStatus, err) &#123; console.log(arguments); //注意：后端模拟errror方式：HttpResponse.status_code=500 &#125;, '400': function () &#123; &#125; &#125; &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $.ajax方法这里仅介绍重点的几个参数，详细的参数，可以点开隐藏的参数表。点击查看参数表 参数表 名称 值/描述 async 布尔值，表示请求是否异步处理。默认是 true。 beforeSend(xhr) 发送请求前运行的函数。 cache 布尔值，表示浏览器是否缓存被请求页面。默认是 true。 complete(xhr,status) 请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。 contentType 发送数据到服务器时所使用的内容类型。默认是：”application/x-www-form-urlencoded”。 context 为所有 AJAX 相关的回调函数规定 “this” 值。 data 规定要发送到服务器的数据。 dataFilter(data,type) 用于处理 XMLHttpRequest 原始响应数据的函数。 dataType 预期的服务器响应的数据类型。 error(xhr,status,error) 如果请求失败要运行的函数。 global 布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。 ifModified 布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。 jsonp 在一个 jsonp 中重写回调函数的字符串。 jsonpCallback 在一个 jsonp 中规定回调函数的名称。 password 规定在 HTTP 访问认证请求中使用的密码。 processData 布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。 scriptCharset 规定请求的字符集。 success(result,status,xhr) 当请求成功时运行的函数。 timeout 设置本地的请求超时时间（以毫秒计）。 traditional 布尔值，规定是否使用参数序列化的传统样式。 type 规定请求的类型（GET 或 POST）。 url 规定发送请求的 URL。默认是当前页面。 username 规定在 HTTP 访问认证请求中使用的用户名。 xhr 用于创建 XMLHttpRequest 对象的函数。 请求参数 data当前ajax请求要携带的数据，是一个json的object对象，ajax方法就会默认地把它编码成某种格式(urlencoded:?a=1&amp;b=2)发送给服务端；此外，ajax默认以get方式发送请求。 1234567function testData() &#123; $.ajax(&quot;/test&quot;,&#123; //此时的data是一个json形式的对象 data:&#123; a:1, b:2 &#125; &#125;); //?a=1&amp;b=2 processData声明当前的data数据是否进行转码或预处理，默认为true，即预处理；if为false，那么对data：{a:1,b:2}会调用json对象的toString()方法，即{a:1,b:2}.toString() ,最后得到一个［object，Object］形式的结果。 contentType默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。用来指明当前请求的数据编码格式；urlencoded:?a=1&amp;b=2；如果想以其他方式提交数据，比如contentType:”application/json”，即向服务器发送一个json字符串： 12345678910$.ajax(&quot;/ajax_get&quot;,&#123; data:JSON.stringify(&#123; a:22, b:33 &#125;), contentType:&quot;application/json&quot;, type:&quot;POST&quot;, &#125;); //&#123;a: 22, b: 33&#125; 注意：contentType:”application/json”一旦设定，data必须是json字符串，不能是json对象 traditional一般是我们的data数据有数组时会用到 ：data:{a:22,b:33,c:[&quot;x&quot;,&quot;y&quot;]},traditional为false会对数据进行深层次迭代； 响应参数 dataType预期服务器返回的数据类型,服务器端返回的数据会根据这个值解析后，传递给回调函数。默认不需要显性指定这个属性，ajax会根据服务器返回的content Type来进行转换；比如我们的服务器响应的content Type为json格式，这时ajax方法就会对响应的内容进行一个json格式的转换，if转换成功，我们在success的回调函数里就会得到一个json格式的对象；转换失败就会触发error这个回调函数。如果我们明确地指定目标类型，就可以使用data Type。 -dataType的可用值1html｜xml｜json｜text｜script dataType实例 点击查看代码 1234567891011121314151617181920212223242526272829303132333435from django.shortcuts import render,HttpResponsefrom django.views.decorators.csrf import csrf_exempt# Create your views here.import jsondef login(request): return render(request,'Ajax.html')def ajax_get(request): l=['alex','little alex'] dic=&#123;"name":"alex","pwd":123&#125; #return HttpResponse(l) #元素直接转成字符串alexlittle alex #return HttpResponse(dic) #字典的键直接转成字符串namepwd return HttpResponse(json.dumps(l)) return HttpResponse(json.dumps(dic))# 传到前端的是json字符串,要想使用,需要JSON.parse(data)//--------------------------------------------------- function testData() &#123; $.ajax('ajax_get', &#123; success: function (data) &#123; console.log(data); console.log(typeof(data)); //console.log(data.name); //JSON.parse(data); //console.log(data.name); &#125;, //dataType:"json", &#125; )&#125; 注解:Response Headers的content Type为text/html,所以返回的是String;但如果我们想要一个json对象,设定dataType:&quot;json&quot;即可,相当于告诉ajax方法把服务器返回的数据转成json对象发送到前端.结果为object。当然，return HttpResponse(json.dumps(a),content_type=&quot;application/json&quot;)这样就不需要设定dataType:&quot;json&quot;了。content_type=&quot;application/json&quot;和content_type=&quot;json&quot;是一样的！ 实例-用户名是否已被注册功能介绍在注册表单中，当用户填写了用户名后，把光标移开后，会自动向服务器发送异步请求。服务器返回true或false，返回true表示这个用户名已经被注册过，返回false表示没有注册过。 客户端得到服务器返回的结果后，确定是否在用户名文本框后显示“用户名已被注册”的错误信息！ 案例分析页面中给出注册表单；在username表单字段中添加onblur事件，调用send()方法；send()方法获取username表单字段的内容，向服务器发送异步请求，参数为username；django 的视图函数：获取username参数，判断是否为“yuan”，如果是响应true，否则响应false 参考代码 点击展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script type=&quot;text/javascript&quot;&gt; function createXMLHttpRequest() &#123; try &#123; return new XMLHttpRequest(); &#125; catch (e) &#123; try &#123; return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e) &#123; return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; &#125; &#125; function send() &#123; var xmlHttp = createXMLHttpRequest(); xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; if(xmlHttp.responseText == &quot;true&quot;) &#123; document.getElementById(&quot;error&quot;).innerText = &quot;用户名已被注册！&quot;; document.getElementById(&quot;error&quot;).textContent = &quot;用户名已被注册！&quot;; &#125; else &#123; document.getElementById(&quot;error&quot;).innerText = &quot;&quot;; document.getElementById(&quot;error&quot;).textContent = &quot;&quot;; &#125; &#125; &#125;; xmlHttp.open(&quot;POST&quot;, &quot;/ajax_check/&quot;, true, &quot;json&quot;); xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); var username = document.getElementById(&quot;username&quot;).value; xmlHttp.send(&quot;username=&quot; + username); &#125;&lt;/script&gt;//--------------------------------------------------index.html&lt;h1&gt;注册&lt;/h1&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;用户名：&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;send()&quot;/&gt;&lt;span id=&quot;error&quot;&gt;&lt;/span&gt;&lt;br/&gt;密 码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;&lt;/form&gt;//--------------------------------------------------views.pyfrom django.views.decorators.csrf import csrf_exemptdef login(request): print(&apos;hello ajax&apos;) return render(request,&apos;index.html&apos;) # return HttpResponse(&apos;helloyuanhao&apos;)@csrf_exemptdef ajax_check(request): print(&apos;ok&apos;) username=request.POST.get(&apos;username&apos;,None) if username==&apos;yuan&apos;: return HttpResponse(&apos;true&apos;) return HttpResponse(&apos;false&apos;) 附录jquery的ajax所有方法 方法 描述 $.ajax() 执行异步 AJAX 请求 $.ajaxPrefilter() 在每个请求发送之前且被 $.ajax() 处理之前，处理自定义 Ajax 选项或修改已存在选项 $.ajaxSetup() 为将来的 AJAX 请求设置默认值 $.ajaxTransport() 创建处理 Ajax 数据实际传送的对象 $.get() 使用 AJAX 的 HTTP GET 请求从服务器加载数据 $.getJSON() 使用 HTTP GET 请求从服务器加载 JSON 编码的数据 $.getScript() 使用 AJAX 的 HTTP GET 请求从服务器加载并执行 JavaScript $.param() 创建数组或对象的序列化表示形式（可用于 AJAX 请求的 URL 查询字符串） $.post() 使用 AJAX 的 HTTP POST 请求从服务器加载数据 ajaxComplete() 规定 AJAX 请求完成时运行的函数 ajaxError() 规定 AJAX 请求失败时运行的函数 ajaxSend() 规定 AJAX 请求发送之前运行的函数 ajaxStart() 规定第一个 AJAX 请求开始时运行的函数 ajaxStop() 规定所有的 AJAX 请求完成时运行的函数 ajaxSuccess() 规定 AJAX 请求成功完成时运行的函数 load() 从服务器加载数据，并把返回的数据放置到指定的元素中 serialize() 编码表单元素集为字符串以便提交 serializeArray() 编码表单元素集为names和values的数组]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度]]></title>
    <url>%2F2018%2F04%2F01%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度。 算法的效率虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率。 算法的效率主要由以下两个复杂度来评估：时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。 空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。 时间复杂度时间频度一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 时间复杂度前面提到的时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。 大O表示法像前面用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。算法复杂度可以从最理想情况、平均情况和最坏情况三个角度来评估，由于平均情况大多和最坏情况持平，而且评估最坏情况也可以避免后顾之忧，因此一般情况下，我们设计算法时都要直接估算最坏情况的复杂度。大O表示法O(f(n)中的f(n)的值可以为1、n、logn、n²等，因此我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶，那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。 推导大O阶推导大O阶，我们可以按照如下的规则来进行推导，得到的结果就是大O表示法： 1.用常数1来取代运行时间中所有加法常数。2.修改后的运行次数函数中，只保留最高阶项3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。 常数阶先举了例子，如下所示。 123sum ,n = 0, 100 # 执行一次 sum = (1+n)*n/2 # 执行一次 print(sum) # 执行一次 上面算法的运行的次数的函数为f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为O(1)。如果sum = （1+n）*n/2这条语句再执行10遍，因为这与问题大小n的值并没有关系，所以这个算法的时间复杂度仍旧是O(1)，我们可以称之为常数阶。 线性阶线性阶主要要分析循环结构的运行情况，如下所示。 12for i in range(0, n): ... # 时间复杂度为O(1)的算法 上面算法循环体中的代码执行了n次，因此时间复杂度为O(n)。 对数阶接着看如下代码： 1234number=1while(number&lt;n): number=number*2 ... # 时间复杂度为O(1)的算法 可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。 平方阶下面的代码是循环嵌套： 123for i in range(0, n): for j in range(0, n): ... # 时间复杂度为O(1)的算法 内层循环的时间复杂度在讲到线性阶时就已经得知是O(n)，现在经过外层循环n次，那么这段算法的时间复杂度则为O(n²)。接下来我们来算一下下面算法的时间复杂度：123for i in range(0, n): for j in range(i, n): ... # 时间复杂度为O(1)的算法 需要注意的是内循环中i到n，而不是0到n。当i=0时，内循环执行了n次；i=1时内循环执行了n-1次，当i=n-1时执行了1次，我们可以推算出总的执行次数为： 123456n+(n-1)+(n-2)+(n-3)+……+1 =(n+1)+[(n-1)+2]+[(n-2)+3]+[(n-3)+4]+…… =(n+1)+(n+1)+(n+1)+(n+1)+…… =(n+1)n/2 =n(n+1)/2 =n²/2+n/2 根据此前讲过的推导大O阶的规则的第二条：只保留最高阶，因此保留n²/2。根据第三条去掉和这个项的常数，则去掉1/2,最终这段代码的时间复杂度为O(n²)。 其他常见复杂度除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度： f(n) 时间复杂度 描述 f(n)=nlogn O(nlogn) 称为nlogn阶 f(n)=n³ O(n³) 称为立方阶 f(n)=2ⁿ O(2ⁿ) 称为指数阶 f(n)=n! O(n!) 称为阶乘阶 f(n)=√n O(√n) 称为平方根阶 复杂度的比较下面将算法中常见的f(n)值根据几种典型的数量级来列成一张表，根据这种表，我们来看看各种算法复杂度的差异。 n logn √n nlogn n² 2ⁿ n! 5 2 2 10 25 32 120 10 3 3 30 100 1024 3628800 50 5 7 250 2500 约10^15 约3.0*10^64 100 6 10 600 10000 约10^30 约9.3*10^157 1000 9 31 9000 1000 000 约10^300 约4.0*10^2567 从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。 下面给出一个更加直观的图： 其中x轴代表n值，y轴代表T(n)值（时间复杂度）。T(n)值随着n的值的变化而变化，其中可以看出O(n!)和O(2ⁿ)随着n值的增大，它们的T(n)值上升幅度非常大，而O(logn)、O(n)、O(nlogn)随着n值的增大，T(n)值上升幅度则很小。常用的时间复杂度按照耗费的时间从小到大依次是： O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!) 声明本篇原文来自刘望舒先生的专栏，略作改动，将代码改为python，并重新排版。 访问原文请点击这里。]]></content>
      <categories>
        <category>Algorithm Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>时间复杂度</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis初识及使用]]></title>
    <url>%2F2018%2F03%2F30%2FRedis%E5%88%9D%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Redis是目前最火爆的内存数据库之一，通过在内存中读写数据，大大提高了读写速度，可以说Redis是实现网站高并发不可或缺的一部分。 Redis简介Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、 list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。与Memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave同步。 Redis的出现，很大程度补偿了Memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便,Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。 Redis操作导入1import redis 连接方式redis模块提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类 123r = redis.Redis(host='192.168.0.110', port=6379,db=0)r.set('name', 'zhangsan') #添加print (r.get('name')) #获取 连接池redis模块使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数 Redis，这样就可以实现多个Redis实例共享一个连接池。1234pool = redis.ConnectionPool(host='192.168.0.110', port=6379)r = redis.Redis(connection_pool=pool)r.set('name', 'zhangsan') #添加print (r.get('name')) #获取 发布和订阅首先定义一个RedisHelper类，连接Redis，定义频道为monitor，定义发布(publish)及订阅(subscribe)方法。 定义类1234567891011121314class RedisHelper(object): def __init__(self): self.__conn = redis.Redis(host='192.168.0.110',port=6379)#连接Redis self.channel = 'monitor' #定义名称 def publish(self,msg):#定义发布方法 self.__conn.publish(self.channel,msg) return True def subscribe(self):#定义订阅方法 pub = self.__conn.pubsub() pub.subscribe(self.channel) pub.parse_response() return pub 发布者12345#发布from RedisHelper import RedisHelper obj = RedisHelper()obj.publish('hello')#发布 订阅者123456789#订阅from RedisHelper import RedisHelper obj = RedisHelper()redis_sub = obj.subscribe()#调用订阅方法 while True: msg= redis_sub.parse_response() print (msg)]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django中Admin的使用]]></title>
    <url>%2F2018%2F03%2F29%2FDjango%E4%B8%ADAdmin%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[admin是django强大功能之一，它能从数据库中读取数据，呈现在页面中，进行管理。 创建超级用户在你所在的django项目路径下，输入代码： 1python manage.py createsupersuer 接下来，按照提示填写用户名，邮箱(可以为空)，密码，确认密码，这样我们就成功的创建好了一个超级用户。 之后，我们运行我们的项目： 1python mannage.py runserver 4000 这时在你的浏览器输入localhost:4000/admin/,就会弹出这样的界面。在里面输入你的账号密码，就可以进入django的管理界面：我们发现django已经给我们写好了用户组和用户的数据库，在这个页面可以用来添加用户和用户组。 注册数据库到admin使用register方法首先，在admin.py下导入所有的数据库 1from blog.models import * 接下来，将想要显示在admin中的数据库注册到admin 12admin.site.register(UserInfo1)admin.site.register(UserType1) 使用register装饰器在你自定义的子类上面添加装饰器，表明这里的自定义内容时对应你的哪张表的。123@admin.register(UserInfo1)class MyAdmin(admin.ModelAdmin): pass 刷新我们的网页，就可以看到我们自己建的数据库了 添加其他功能修改表单显示默认这里显示的都是UserInfo1，根本看不出，更不谈管理，那么我们如何修改这里显示的内容呢 很简单，在我们在models中创建表格的时候，自定义一个__str__函数，就可以自定义显示字段。 12def __str__(self): return self.username 修改表单显示多个字段这需要我们在admin中创建一个admin.ModelAdmin的子类，然后在注册表单的时候，将这个参数加上就可以了。 1234class MyAdmin(admin.ModelAdmin): list_display = ("username", "age", "user_type")admin.site.register(UserInfo1, MyAdmin) 刷新页面，发现我们想要的已经显示出来了 添加搜索功能数据量不大的时候，找想要的很方便，但数据量增大的时候，查找功能就必不可少了。添加方法，和上面一样在子类里面添加 1search_fields = ("username","user_type") 右侧的参数，则是添加查找内容的范围。 添加筛选功能1list_filter = ('username', ) 其他需求修改语言为中文在settings里面将LANGUAGE_CODE字段的值改为zh-hans 1LANGUAGE_CODE = 'zh-hans' 用户权限控制定制加载的列表, 根据不同的人显示不同的内容列表。 例如：如果是超级管理员就列出所有的，如果不是，就仅列出访问者自己相关的。 1234567class MyModelAdmin(admin.ModelAdmin): def get_queryset(self, request): qs = super(MyModelAdmin, self).get_queryset(request) if request.user.is_superuser: return qs else: return qs.filter(author=request.user) ——— 未完待续 ———]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调用CMD方法]]></title>
    <url>%2F2018%2F03%2F28%2F%E8%B0%83%E7%94%A8CMD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python调用cmd的各种实现方法及优点与缺点。 使用os.system(“cmd”)这是最简单的一种方法，特点是执行的时候程序会打出cmd在linux上执行的信息。使用前需要import os。 1os.system("ls") 使用Popen模块产生新的process现在大部分人都喜欢使用Popen。Popen方法不会打印出cmd在linux上执行的信息。的确，Popen非常强大，支持多种参数和模式。使用前需要from subprocess import Popen, PIPE。 Popen函数缺陷它是一个阻塞的方法。如果运行cmd时产生的内容非常多，函数非常容易阻塞住。 解决办法：是不使用wait()方法，但是也不能获得执行的返回值了。 语法1subprocess.Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0) 点击这里，查看具体参数 参数 描述 args 可以是字符串或者序列类型（如：list，元组），用于指定进程的可执行文件及其参数。如果是序列类型，第一个元素通常是可执行文件的路径。我们也可以显式的使用executeable参数来指定可执行文件的路径。 bufsize 指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲(全缓冲) stdin, stdout, stderr 分别表示程序的标准输入、输出、错误句柄。他们可以是PIPE，文件描述符或文件对象，也可以设置为None，表示从父进程继承。 preexec_fn 只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用。 Close_sfs 在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。我们不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。 shell 设为true，程序将通过shell来执行。 cwd 用于设置子进程的当前目录 env 是字典类型，用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。 Universal_newlines 不同操作系统下，文本的换行符是不一样的。如：windows下用’/r/n’表示换，而Linux下用’/n’。如果将此参数设置为True，Python统一把这些换行符当作’/n’来处理。startupinfo与createionflags只在windows下用效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 startupinfo，createionflags 只在windows下有效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 subprocess.PIPE在创建Popen对象时，subprocess.PIPE可以初始化stdin, stdout或stderr参数，表示与子进程通信的标准流。 subprocess.STDOUT创建Popen对象时，用于初始化stderr参数，表示将错误通过标准输出流输出。 Popen的方法Popen.poll()用于检查子进程是否已经结束。设置并返回returncode属性。 Popen.wait()等待子进程结束。设置并返回returncode属性。 1Popen.communicate(input=None) 与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。 Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如 果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。 Popen.send_signal(signal)向子进程发送信号。 Popen.terminate()停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程。 Popen.kill()杀死子进程。 Popen.stdin()如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。 Popen.stdout()如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。 Popen.stderr ()如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。 Popen.pid()获取子进程的进程ID。 Popen.returncode ()获取进程的返回值。如果进程还没有结束，返回None。 123456p = Popen("cp -rf a/* b/", shell=True, stdout=PIPE, stderr=PIPE) p.wait() if p.returncode != 0: print ("Error.") return -1 END 使用commands.getstatusoutput方法这个方法也不会打印出cmd在linux上执行的信息。这个方法唯一的优点是，它不是一个阻塞的方法。即没有Popen函数阻塞的问题。使用前需要import commands。 12import commandsstatus, output = commands.getstatusoutput("ls") 还有只获得output和status的方法： 12commands.getoutput("ls") commands.getstatus("ls")]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM的F与Q查找]]></title>
    <url>%2F2018%2F03%2F28%2FORM%E4%B8%ADF%E4%B8%8EQ%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[有时候靠单一的关键字参数查询已经很难满足查询要求，此时就需要ORM的F和Q查询。 导入12from django.db.models import Ffrom django.db.models import Q F查询 F查询——专门取对象中某列值的操作，不可使用__双下划线 12# 对于book表中每本书的价格都在原价格的基础上增加20元models.Book.objects.update(price=F("price")+20) 取到Book书中price一列值，并对每个值进行＋20的操作 Q查询 Q查询——对对象的复杂查询 filter() 等方法中的关键字参数查询都是相当于进行“AND” 操作的。 如果你需要执行更复杂的查询（例如OR语句），你可以使用Q对象。 关键字封装123#1 Q对象可以对关键字参数进行封装，从而更好地应用多个查询q1=models.Book.objects.filter(Q(title__startswith='P')).all()print(q1)#[&lt;Book: Python&gt;, &lt;Book: Perl&gt;] 使用操作符12345# 可以组合使用&amp;,|操作符，当一个操作符是用于两个Q的对象,它产生一个新的Q对象。Q(title__startswith='P') | Q(title__startswith='J')# Q对象可以用~操作符放在前面表示否定，也可允许否定与不否定形式的组合Q(title__startswith='P') | ~Q(pub_date__year=2015) 可使用Q对象的方法 filter() exclude() get() 注意事项Q对象可以与关键字参数查询一起使用，不过一定要把Q对象放在关键字参数查询的前面。 12345678# 正确：Book.objects.get( Q(pub_date=date(2015, 5, 2)) | Q(pub_date=date(2005, 5, 6)), title__startswith='P')# 错误：Book.objects.get( question__startswith='P', Q(pub_date=date(2015, 5, 2)) | Q(pub_date=date(2005, 5, 6)))]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM分组与聚合查询]]></title>
    <url>%2F2018%2F03%2F27%2FORM%E5%88%86%E7%BB%84%E4%B8%8E%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[详解ORM的分组查询和聚合查询。 导入1from django.db.models import Avg,Min,Sum,Max 方法 描述 Avg 平均值 Min 最小值 Sum 求和 Max 最大值 聚合查询1aggregate(*args,**kwargs) 通过对QuerySet进行计算，返回一个聚合值的字典。aggregate()中每一个参数都指定一个包含在字典中的返回值。即在查询集上生成聚合。 比如，你想要计算所有在售书的平均价钱。首先拿到所有的书的QuerySet对象，使用aggregate()函数直接拿到平均值。12&gt;&gt;&gt; Book.objects.all().aggregate(Avg('price'))&#123;'price__avg': 34.35&#125; aggregate()子句的参数描述了我们想要计算的聚合值，在这个例子中，是Book模型中price字段的平均值。 aggregate()是QuerySet 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。 当然我们也可以自己定义键名： 12&gt;&gt;&gt; Book.objects.aggregate(average_price=Avg('price'))&#123;'average_price': 34.35&#125; 并且从上面的语法看，这个方法是可以接受多个方法参数的，也就是说，我们可以同时使用最大值，最小值，总和等方法作为参数： 12&gt;&gt;&gt; Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))&#123;'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')&#125; 分类查询语法1annotate(*args,**kwargs): 可以通过计算查询结果中每一个对象所关联的对象集合，从而得出总计值(也可以是平均值或总和)，即为查询集的每一项生成聚合。 假设我们现在的需求是按照作者的名字分组： 1234&gt;&gt;&gt; Book.objects.values('authors__name').annotate(Max('price'))&lt;QuerySet [&#123;'authors__name': 'x1', 'price__max': Decimal('100.00')&#125;,&#123;'authors__name': 'x2', 'price__max': Decimal('100.00')&#125;,&#123;'authors__name': 'x3', 'price__max': Decimal('100.00')&#125;]&gt; 总结 聚合是aggreate()，通过QuerySet 进行计算。做求值运算的时候使用。 分组是annotate()，括号里是条件，遇到每什么什么的时候就要分组。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八种常用排序算法]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%85%AB%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基于python实现了冒泡排序、希尔排序、插入排序、快速排序、直接选择排序、堆排序、归并排序、基数排序。 冒泡排序描述重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 代码实现12345678# 冒泡排序def bubble_sort(lists): count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: lists[i], lists[j] = lists[j], lists[i] return lists 插入排序描述插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。 代码实现123456789101112# 插入排序def insert_sort(lists): count = len(lists) for i in range(1, count): key = lists[i] j = i - 1 while j &gt;= 0: if lists[j] &gt; key: lists[j + 1] = lists[j] lists[j] = key j -= 1 return lists 希尔排序描述希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 12345678910111213141516171819# 希尔排序def shell_sort(lists): count = len(lists) step = 2 group = count / step while group &gt; 0: for i in range(0, group): j = i + group while j &lt; count: k = j - group key = lists[j] while k &gt;= 0: if lists[k] &gt; key: lists[k + group] = lists[k] lists[k] = key k -= group j += group group /= step return lists 快速排序描述通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 代码实现123456789101112131415161718# 快速排序def quick_sort(lists, left, right): if left &gt;= right: return lists key = lists[left] low = left high = right while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 lists[right] = lists[left] lists[right] = key quick_sort(lists, low, left - 1) quick_sort(lists, left + 1, high) return lists 直接选择排序描述基本思想：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。 代码实现12345678910def select_sort(lists): # 选择排序 count = len(lists) for i in range(0, count): min = i for j in range(i + 1, count): if lists[min] &gt; lists[j]: min = j lists[min], lists[i] = lists[i], lists[min] return lists 堆排序描述堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。 代码实现1234567891011121314151617181920212223def adjust_heap(lists, i, size): lchild = 2 * i + 1 rchild = 2 * i + 2 max = i if i &lt; size / 2: if lchild &lt; size and lists[lchild] &gt; lists[max]: max = lchild if rchild &lt; size and lists[rchild] &gt; lists[max]: max = rchild if max != i: lists[max], lists[i] = lists[i], lists[max] adjust_heap(lists, max, size)def build_heap(lists, size): for i in range(0, (size/2))[::-1]: adjust_heap(lists, i, size)def heap_sort(lists): size = len(lists) build_heap(lists, size) for i in range(0, size)[::-1]: lists[0], lists[i] = lists[i], lists[0] adjust_heap(lists, 0, i) 归并排序描述归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。 代码实现12345678910111213141516171819202122def merge(left, right): i, j = 0, 0 result = [] while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return resultdef merge_sort(lists): # 归并排序 if len(lists) &lt;= 1: return lists num = len(lists) / 2 left = merge_sort(lists[:num]) right = merge_sort(lists[num:]) return merge(left, right) 基数排序描述基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。 代码实现123456789101112import mathdef radix_sort(lists, radix=10): k = int(math.ceil(math.log(max(lists), radix))) bucket = [[] for i in range(radix)] for i in range(1, k+1): for j in lists: bucket[j/(radix**(i-1)) % (radix**i)].append(j) del lists[:] for z in bucket: lists += z del z[:] return lists 声明本文来自十三号线上的蝼蚁，仅作整理学习，后续会添加每一种排序的详解。 访问原文请点击这里。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django数据库操作]]></title>
    <url>%2F2018%2F03%2F25%2FDjango%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在这里介绍了ORM的概念和优缺点，和基于ORM的数据库操作之增删改查。以及一对一操作，一对多操作，多对多操作。 ORM的概念 点击查看详细介绍 ORM：Object Relational Mapping(对象关系映射) 让我们从O/R开始。字母O起源于”对象”(Object),而R则来自于”关系”(Relational)。几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。 当你开发一个应用程序的时候(不使用O/R Mapping),你可能会写不少数据访问层的代码，用来从数据库保存，删除，读取对象信息，等等。你在DAL中写了很多的方法来读取对象数据，改变状态对象等等任务。而这些代码写起来总是重复的。 ORM解决的主要问题是对象关系的映射。域模型和关系模型分别是建立在概念模型的基础上的。域模型是面向对象的，而关系模型是面向关系的。一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。 ORM技术特点 提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。 ORM的缺点ORM的缺点是会牺牲程序的执行效率和会固定思维模式。从系统结构上来看,采用ORM的系统一般都是多层系统，系统的层次多了，效率就会降低。ORM是一种完全的面向对象的做法，而面向对象的做法也会对性能产生一定的影响。 但ORM是一种工具，工具确实能解决一些重复，简单的劳动。这是不可否认的。 在models里面创建一张表，下面的都是基于这张表的操作。 1234class UserInfo(models.Model): username = models.CharField(max_length=64) sex = models.CharField(max_length=64) mail = models.CharField(max_length=64) 导入1from blog import models ORM之增(create,save)这里推荐使用第三种方式12345678910# 增 # 第一种方式 models.UserInfo.objects.create(username=&apos;zsy1&apos;, sex=&apos;girl&apos;, mail=&apos;love.com&apos;) # 第二种方式 obj = models.UserInfo(username=&apos;zsy2&apos;, sex=&apos;girl&apos;, mail=&apos;love.com&apos;) obj.save() # 第三种方式 user1 = &#123;&apos;username&apos;: &apos;zsy3&apos;, &apos;sex&apos;: &apos;girl&apos;, &apos;mail&apos;: &apos;love.com&apos;&#125; models.UserInfo.objects.create(**user1) return HttpResponse(&quot;已增加&quot;) ORM之删123456# 删 # 删除所有 models.UserInfo.objects.all().delete() # 删除id=11的项 models.UserInfo.objects.filter(id=11).delete() return HttpResponse(&quot;已删除&quot;) ORM之改推荐使用update12345678910# 改 # 方式1 update() models.UserInfo.objects.all().update(mail=8888) models.UserInfo.objects.filter(id=12).update(mail=888888) # 方式2 obj.save() user2 = models.UserInfo.objects.get(id=12) user2.sex = &apos;woman&apos; user2.save() return HttpResponse(&quot;已修改&quot;) ORM之查1234567891011# 查 # 查询所有，为QuerySet类型，可理解成列表 result = models.UserInfo.objects.all() # 条件查询：filter 相当于where查询条件，里面的&quot;，&quot;会组成and条件 result = models.UserInfo.objects.filter(username=&quot;zsy2&quot;) # 查看Query执行过程： print(result.query) # 循环打印，点号取属性值 for row in result: # 打印查询到数据。 print(row.id, row.username, row.sex) return HttpResponse(&quot;已查找&quot;) 上面的一对一翻篇了，接下来我们学习下一对多和多对多，而我们又可以把一对多，多对多，分为正向和反向查找两种方式。这里我们创建了两张表，在models中： 1234567class UserType1(models.Model): caption = models.CharField(max_length=32) class UserInfo1(models.Model): username = models.CharField(max_length=32) age = models.IntegerField() user_type = models.ForeignKey(&apos;UserType&apos;)#外键 之后再命令行执行：12python manage.py makemigrationspython manage.py migrate 这样我们就创建了两张空表： 正查与反查这里ForeignKey在 UserInfo表中正向查找：如果从UserInfo表开始向其他的表进行查询，这个就是正向查询。反向查询：如果从UserType表去查询其他的表这个就是反向操作。 ORM之一对多增加数据这里对user_type赋值，有两种方法：第一种方式：再次查询数据库，不推荐 1user_type = models.UserInfo1.objects.filter(id=1).first() 第二种方式：通过 外键字段_id 1user_tyoe_id = 1 所以我们使用第二种创建数据： 123dic = &#123;'username': 'mosson', 'age': 18, 'user_type_id': 1&#125;models.UserInfo1.objects.create(**dic)return HttpResponse('OK') 查询数据获取到的数据类型本质上都是 queryset类型，类似于列表，内部有3种表现形式（对象，字典，列表） 12# &lt;QuerySet [&lt;表名: 表 object&gt;, &lt;表名: 表 object&gt;]&gt;modle.UserInfo1.objects.all() 注意：这里使用双下划线跨表取键值 12# &lt;QuerySet [&#123;&apos;xx&apos;: &apos;xx&apos;, &apos;xx&apos;: x&#125;, &#123;&apos;xx&apos;: &apos;x&apos;, &apos;xx&apos;: x&#125;]&gt;modle.UserInfo1.objects.values(&apos;当前表键名&apos;，&apos;跨表__键名&apos;) 12# &lt;QuerySet [(&apos;xx&apos;, x), (&apos;xx&apos;, x)]&gt;modle.UserInfo1.objects.values_list(&apos;当前表键名&apos;，&apos;跨表__键名&apos;) 正向查询例子通过UserInfo1查询：12345ret = models.UserInfo1.objects.filter(user_type__caption=&apos;COO&apos;)print(ret)for item in ret: print(item,item.username,item.age,item.user_type.caption)return HttpResponse(&quot;OK&quot;) 反向查询通过UserType1查询：方法一：123ret = models.UserType.objects.filter(caption=&apos;COO&apos;).values(&apos;userinfo__username&apos;) for item in ret: print(item,type(item)) 123ret = models.UserType.objects.filter(caption=&apos;COO&apos;).first() for item in ret.userinfo_set.all(): print(item.username) 总结 正向查找： filter（跨表的时候，应该是对象__跨表的字段） 获取这个值的时候，拿到了一行数据的时候 line.对象.跨表的字段 反向查找： filter（关联这个表的表明） 自动创建和表明相同的对象，通过这个对象__跨表的字段 line.自动创建和表明相同的对象_set.方法 ORM之多对多首先需要说明的是： 多对多和一对多没有任何关系 创建 方式一：自定义关系表 123class HostToApp(models.Model): hobj = models.ForeignKey(to=&apos;Host&apos;,to_field=&apos;nid&apos;) aobj = models.ForeignKey(to=&apos;Application&apos;,to_field=&apos;id&apos;) 方式二：自动创建关系表表中添加 ManyToManyField 123class Application(models.Model): name = models.CharField(max_length=32) d = models.ManyToManyField(&quot;Host&quot;) ——— 未完待续 ———]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django数据库配置]]></title>
    <url>%2F2018%2F03%2F24%2FDjango%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于Django配置数据库的过程和配置python3配置mysql中需要注意的事情。 数据库选择django默认支持sqlite，mysql, oracle,postgresql数据库。 sqlitedjango默认使用sqlite的数据库，默认自带sqlite的数据库驱动引擎名称：django.db.backends.sqlite3 mysql引擎名称：django.db.backends.mysql mysql驱动程序 MySQLdb(mysql python) mysqlclient MySQL PyMySQL(纯python的mysql驱动程序) 数据库的设置sqlite设置在django的项目中会默认使用sqlite数据库，在settings里有如下设置： 123456DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125; mysql设置如果我们想要更改数据库为mysql，需要在settings中修改如下： 12345678910DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;mydatabase&apos;, &apos;USER&apos;: &apos;mydatabaseuser&apos;, &apos;PASSWORD&apos;: &apos;mypassword&apos;, &apos;HOST&apos;: &apos;127.0.0.1&apos;, &apos;PORT&apos;: &apos;3306&apos;, &#125; &#125; 配置表 参数 描述 NAME 指定的数据库名，如果是sqlite的话，就需要填数据库文件的绝对位置 USER 数据库登录的用户名，mysql一般都是root PASSWORD 登录数据库的密码，必须是USER用户所对应的密码 HOST 由于一般的数据库都是C/S结构的，所以得指定数据库服务器的位置，我们一般数据库服务器和客户端都是在一台主机上面，所以一般默认都填127.0.0.1 PORT 数据库服务器端口，mysql默认为3306,注意类型为str. HOST和PORT都可以不填，使用默认的配置，但是如果你有更改默认配置的话，就需要填入更改后的 遇到的坑设置完后，再启动我们的Django项目前，我们需要激活我们的mysql。 然后，启动项目，会报错： 1no module named MySQLdb 这是因为django默认你导入的驱动是MySQLdb，可是MySQLdb对于py3有很大问题，所以我们需要的驱动是PyMySQL.所以，我们只需要找到项目名文件下的init,在里面写入： 12import pymysqlpymysql.install_as_MySQLdb() 对了，还有个坑要说下，windows安装mysql需要visual c++ redistributable packages for visual studio 2013组件，否则mysql server是装不上的。vc++ 2013 redistributable 官方下载地址需要注意的是：x86和x64组件都需要安装！ 如果已经你电脑以前安装过，但还是不能安装，下载完成后，双击运行点击修复。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django模板语言]]></title>
    <url>%2F2018%2F03%2F22%2FDjango%E6%A8%A1%E6%9D%BF%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[Django模板是一个string文本，它用来分离一个文档的展现和数据。模板定义了placeholder和表示多种逻辑的tags来规定文档如何展现，通常模板用来输出HTML，但是Django模板也能生成其它基于文本的形式。 ◇◆◇◆◇ 变量变量的引用1&#123;&#123; 变量名 &#125;&#125; Template和Context对象点击这里，查看例子 1234567891011121314151617181920&gt;&gt;&gt; python manage.py shell (进入该django项目的环境)&gt;&gt;&gt; from django.template import Context, Template&gt;&gt;&gt; t = Template(&apos;My name is &#123;&#123; name &#125;&#125;.&apos;)&gt;&gt;&gt; c = Context(&#123;&apos;name&apos;: &apos;Stephane&apos;&#125;)&gt;&gt;&gt; t.render(c)&apos;My name is Stephane.&apos;# 同一模板，多个上下文，一旦有了模板对象，你就可以通过它渲染多个context，无论何时我们都可以# 像这样使用同一模板源渲染多个context，只进行 一次模板创建然后多次调用render()方法渲染会# 更为高效：# Lowfor name in (&apos;John&apos;, &apos;Julie&apos;, &apos;Pat&apos;): t = Template(&apos;Hello, &#123;&#123; name &#125;&#125;&apos;) print t.render(Context(&#123;&apos;name&apos;: name&#125;))# Goodt = Template(&apos;Hello, &#123;&#123; name &#125;&#125;&apos;)for name in (&apos;John&apos;, &apos;Julie&apos;, &apos;Pat&apos;): print t.render(Context(&#123;&apos;name&apos;: name&#125;)) 变量的查找我们通过 context 传递的简单参数值主要是字符串，然而，模板系统能够非常简洁地处理更加复杂的数据结构，例如list、dictionary和自定义的对象。在 Django 模板中遍历复杂数据结构的关键是句点字符 .点击这里，查看例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 首先，句点可用于访问列表索引，例如：&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; t = Template('Item 2 is &#123;&#123; items.2 &#125;&#125;.')&gt;&gt;&gt; c = Context(&#123;'items': ['apples', 'bananas', 'carrots']&#125;)&gt;&gt;&gt; t.render(c)'Item 2 is carrots.'#假设你要向模板传递一个 Python 字典。 要通过字典键访问该字典的值，可使用一个句点：&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; person = &#123;'name': 'Sally', 'age': '43'&#125;&gt;&gt;&gt; t = Template('&#123;&#123; person.name &#125;&#125; is &#123;&#123; person.age &#125;&#125; years old.')&gt;&gt;&gt; c = Context(&#123;'person': person&#125;)&gt;&gt;&gt; t.render(c)'Sally is 43 years old.'#同样，也可以通过句点来访问对象的属性。 比方说， Python 的 datetime.date 对象有#year 、 month 和 day 几个属性，你同样可以在模板中使用句点来访问这些属性：&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; import datetime&gt;&gt;&gt; d = datetime.date(1993, 5, 2)&gt;&gt;&gt; d.year&gt;&gt;&gt; d.month&gt;&gt;&gt; d.day&gt;&gt;&gt; t = Template('The month is &#123;&#123; date.month &#125;&#125; and the year is &#123;&#123; date.year &#125;&#125;.')&gt;&gt;&gt; c = Context(&#123;'date': d&#125;)&gt;&gt;&gt; t.render(c)'The month is 5 and the year is 1993.'# 这个例子使用了一个自定义的类，演示了通过实例变量加一点(dots)来访问它的属性，这个方法适# 用于任意的对象。&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; class Person(object):... def __init__(self, first_name, last_name):... self.first_name, self.last_name = first_name, last_name&gt;&gt;&gt; t = Template('Hello, &#123;&#123; person.first_name &#125;&#125; &#123;&#123; person.last_name &#125;&#125;.')&gt;&gt;&gt; c = Context(&#123;'person': Person('John', 'Smith')&#125;)&gt;&gt;&gt; t.render(c)'Hello, John Smith.'# 点语法也可以用来引用对象的方法。 例如，每个 Python 字符串都有 upper() 和 isdigit()# 方法，你在模板中可以使用同样的句点语法来调用它们：&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; t = Template('&#123;&#123; var &#125;&#125; -- &#123;&#123; var.upper &#125;&#125; -- &#123;&#123; var.isdigit &#125;&#125;')&gt;&gt;&gt; t.render(Context(&#123;'var': 'hello'&#125;))'hello -- HELLO -- False'&gt;&gt;&gt; t.render(Context(&#123;'var': '123'&#125;))'123 -- 123 -- True'# 注意这里调用方法时并* 没有* 使用圆括号 而且也无法给该方法传递参数；你只能调用不需参数的 标签if/else 标签1234567&#123;% if condition1 %&#125; ... display 1&#123;% elif condiiton2 %&#125; ... display 2&#123;% else %&#125; ... display 3&#123;% endif %&#125; if 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not ).注意： if 标签不允许在同一个标签中同时使用 and 和 or ，因为逻辑上可能模糊的，这样的代码是不合法的： 1&#123;% if athlete_list and coach_list or cheerleader_list %&#125; 系统不支持用圆括号来组合比较操作。 如果你确实需要用到圆括号来组合表达你的逻辑式，考虑将它移到模板之外处理，然后以模板变量的形式传入结果吧。 或者，仅仅用嵌套的if标签替换. for 标签 for 允许我们在一个序列上迭代，循环语法是 for X in Y ，Y是要迭代的序列而X是在每一个特定的循环中使用的变量名称。每一次循环中，模板系统会渲染在 for 和 endfor 之间的所有内容。 12345 &lt;ul&gt;&#123;% for athlete in athlete_list %&#125; &lt;li&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 反向迭代给标签增加一个 reversed 使得该列表被反向迭代：1&#123;% for athlete in athlete_list reversed %&#125; empty分句for 标签支持一个可选的empty 分句，通过它我们可以定义当列表为空时的输出内容。 12345&#123;% for athlete in athlete_list %&#125; &lt;p&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/p&gt;&#123;% empty %&#125; &lt;p&gt;There are no athletes. Only computer programmers.&lt;/p&gt;&#123;% endfor %&#125; 退出循环Django不支持退出循环操作。 如果我们想退出循环，可以改变正在迭代的变量，让其仅仅包含需要迭代的项目。 同理，Django也不支持continue语句，我们无法让当前迭代操作跳回到循环头部。 forloop变量在每个for循环里有一个称为forloop 的模板变量。这个变量有一些提示循环进度信息的属性。forloop 变量仅仅能够在循环中使用。 在模板解析器碰到endfor标签后，forloop就不可访问了。 forloop.counter 总是一个表示当前循环的执行次数的整数计数器。 这个计数器是从1开始的，所以在第一次循环时forloop.counter 将会被设置为1。123&#123;% for item in todo_list %&#125; &lt;p&gt;&#123;&#123; forloop.counter &#125;&#125;: &#123;&#123; item &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125; forloop.counter0 类似于forloop.counter ，但是它是从0计数的。 第一次执行循环时这个变量会被设置为0。 forloop.revcounter 是表示循环中剩余项的整型变量。 在循环初次执行时forloop.revcounter 将被设置为序列中项的总数。 最后一次循环执行中，这个变量将被置1。 forloop.revcounter0 类似于forloop.revcounter ，但它以0做为结束索引。在第一次执行循环时，该变量会被置为序列的项的个数减1。 forloop.first 是一个布尔值，如果该迭代是第一次执行，那么它被置为True. forloop.last 是一个布尔值；在最后一次执行循环时被置为True。 一个常见的用法是在一系列的链接之间放置管道符|，另一个常见的用途是为列表的每个单词的加上逗号。 1&#123;% for link in links %&#125;&#123;&#123; link &#125;&#125;&#123;% if not forloop.last %&#125; | &#123;% endif %&#125;&#123;% endfor %&#125; 上面的模板可能会产生如下的结果： 1Link1 | Link2 | Link3 | Link4 ifequal/ifnotequal 标签ifequal 标签比较两个值，当他们相等时，显示在 ifequal 和 endifequal 之中所有的值。 下面的例子比较两个模板变量 user 和 currentuser : 12345&#123;% ifequal user currentuser %&#125; &lt;h1&gt;Welcome!&lt;/h1&gt;&#123;% else %&#125; &lt;h1&gt;Sorry&lt;/h1&gt;&#123;% endifequal %&#125; 只有模板变量，字符串，整数和小数可以作为 ifequal 标签的参数。其他任何类型，例如Python的字典类型、列表类型、布尔类型，不能用在ifequal 中 注释标签单行注释1&#123;# 这是一个注释 #&#125; 用这种语法的注释不能跨越多行。 这个限制是为了提高模板解析的性能。 多行注释1234&#123;% comment %&#125;This is amulti-line comment.&#123;% endcomment %&#125; URL标签url的用法也很简单，只要在urlpatterns里使用它，附加一个name，如： 1url(r&apos;^article$&apos;,&apos;news_index&apos; ，name=&quot;news_index&quot;), Templates里 这样使用1&#123;%url &apos;name&apos;%&#125; 地址链接就能使用了。 name是全局的，你整个urlpatterns里只能一个唯一的name，这个道理应该好理解，就像网站的地址也是唯一性的。 csrf_token标签用于生成csrf_token的标签，用于防治跨站攻击验证。注意如果你在view的index里用的是render_to_response方法，不会生效。其实，这里是会生成一个input标签，和其他表单标签一起提交给后台的 引用路由配置的地址这里的参数来自urls.py中的定义的name=xxxx12345&lt;form action=&quot;&#123;% url &quot;xxxx&quot;%&#125;&quot; &gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot;value=&quot;提交&quot;&gt; &#123;%csrf_token%&#125;&lt;/form&gt; 禁止渲染123&#123;% verbatim %&#125; &#123;&#123; hello &#125;&#125;&#123;% endverbatim %&#125; 加载标签1&#123;% load xxxx %&#125; 过滤器过滤器通过管道符来实现。 add给value加上一个数值 1&#123;&#123; user.age | add:”5” &#125;&#125; capfirst第一个字母大写 1&#123;&#123; ‘good’| capfirst &#125;&#125; 返回”Good” center输出指定长度的字符串，把变量居中1&#123;&#123; “abcd”| center:”50” &#125;&#125; cut删除指定字符串 1&#123;&#123; “You are not a Englishman” | cut:”not” &#125;&#125; dictsort按某字段排序，变量必须是一个dictionary 1&#123;% for moment in moments | dictsort:”id” %&#125; default如果值不存在，则使用默认值代替 1&#123;&#123; value | default:”(N/A)” &#125;&#125; filesizeformat增加数字的可读性，转换结果为13KB,89MB,3Bytes等 1&#123;&#123; 1024 | filesizeformat &#125;&#125; 返回 1.0KB floatformat转换为指定精度的小数，默认保留1位小数 1&#123;&#123; 3.1415926 | floatformat:3 &#125;&#125; 返回 3.142 四舍五入 get_digit从个位数开始截取指定位置的数字 1&#123;&#123; 123456 | get_digit:’1’&#125;&#125; linebreaks用&lt;p&gt;或&lt;br&gt;标签包裹变量 1&#123;&#123; “Hi\n\nDavid”|linebreaks &#125;&#125; 返回&lt;p&gt;Hi&lt;/p&gt;&lt;p&gt;David&lt;/p&gt; ljust输出指定长度的字符串，变量左对齐 1&#123;&#123;‘ab’|ljust:5&#125;&#125; 返回 ‘ab ’ slice切片操作， 返回列表 12&#123;&#123;[3,9,1] | slice:’:2’&#125;&#125; 返回 [3,9]&#123;&#123; &apos;asdikfjhihgie&apos; | slice:&apos;:5&apos; &#125;&#125; 返回 ‘asdik’ slugify在字符串中留下减号和下划线，其它符号删除，空格用减号替换 1&#123;&#123; &apos;5-2=3and5 2=3&apos; | slugify &#125;&#125; 返回 5-23and5-23 truncatewords将字符串转换为省略表达方式 12&#123;&#123; &apos;This is a pen&apos; | truncatewords:2 &#125;&#125;返回 This is ... truncatewords_html同上，但保留其中的HTML标签 12&#123;&#123; &apos;&lt;p&gt;This is a pen&lt;/p&gt;&apos; | truncatewords:2 &#125;&#125;返回 &lt;p&gt;This is ...&lt;/p&gt; yesno将布尔变量转换为字符串yes, no 或maybe 123&#123;&#123; True | yesno &#125;&#125; yes&#123;&#123; False | yesno &#125;&#125; no &#123;&#123; None | yesno &#125;&#125; maybe 其他过滤器 过滤器 描述 upper 以大写方式输出 addslashes 单引号加上转义号 date 格式化日期 default_if_none 如果值为None, 则使用默认值代替 divisibleby 判断是否可以被数字整除 返回布尔类型 dictsortreversed 按某字段倒序排序，变量必须是dictionary escape 按HTML转义，比如将”&lt;”转换为”&amp;lt” first 返回列表的第1个元素，变量必须是一个列表 length 返回列表中元素的个数或字符串长度 linebreaksbr 用&lt;br/&gt;标签代替换行符 linenumbers 为变量中的每一行加上行号 lower 字符串变小写 length_is 检查列表，字符串长度是否符合指定的值 join 用指定分隔符连接列表 make_list 将字符串转换为列表 pluralize 根据数字确定是否输出英文复数符号 random 返回列表的随机一项 removetags 删除字符串中指定的HTML标记 rjust 输出指定长度的字符串，变量右对齐 stringformat 字符串格式化，语法同python time 返回日期的时间部分 timesince 以“到现在为止过了多长时间”显示时间变量 结果可能为 45days, 3 hours timeuntil 以“从现在开始到时间变量”还有多长时间显示时间变量 title 每个单词首字母大写 urlencode 将字符串中的特殊字符转换为url兼容表达方式 urlize 将变量字符串中的url由纯文本变为链接 wordcount 返回变量字符串中的单词数 ◇◆◇◆◇]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则整理]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[很多不太懂正则的朋友，在遇到需要用正则校验数据时，往往是在网上去找很久，结果找来的还是不很符合要求。所以我最近把开发中常用的一些正则表达式整理了一下，在这里分享一下。给自己留个底，也给朋友们做个参考。 ◇◆◇◆◇ 校验数字的表达式数字1^[0-9]*$ n位的数字1^\d&#123;n&#125;$ 至少n位的数字1^\d&#123;n,&#125;$ m-n位的数字1^\d&#123;m,n&#125;$ 零和非零开头的数字1^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字1^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 带1-2位小数的正数或负数1^(\-)?\d+(\.\d&#123;1,2&#125;)?$ 正数、负数、和小数1^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数1^[0-9]+(.[0-9]&#123;2&#125;)?$ 有1~3位小数的正实数1^[0-9]+(.[0-9]&#123;1,3&#125;)?$ 非零的正整数1^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$ 非零的负整数1^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$ 非负整数1^\d+$ 或 ^[1-9]\d*|0$ 非正整数1^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数1^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 非正浮点数1^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 正浮点数1^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数1^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数1^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ ◇◆◇◆◇ 校验字符的表达式汉字1^[\u4e00-\u9fa5]&#123;0,&#125;$ 英文和数字1^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ 长度为3-20的所有字符1^.&#123;3,20&#125;$ 由26个英文字母组成的字符串1^[A-Za-z]+$ 由26个大写英文字母组成的字符串1^[A-Z]+$ 由26个小写英文字母组成的字符串1^[a-z]+$ 由数字和26个英文字母组成的字符串1^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串1^\w+$ 或 ^\w&#123;3,20&#125;$ 中文、英文、数字包括下划线1^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号1^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$ 可以输入含有^%&amp;’,;=?$\”等字符1[^%&amp;&apos;,;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+ ◇◆◇◆◇ 特殊需求的表达式Email地址1^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名1[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? InternetURL1[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 手机号码1^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$ 电话号码1^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ 国内电话号码(0511-4405222、021-87888822)1\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125; 身份证号(15位、18位数字)1^\d&#123;15&#125;|\d&#123;18&#125;$ 短身份证号码(数字、字母x结尾)1^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)1^[a-zA-Z]\w&#123;5,17&#125;$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)1^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 日期格式1^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125; 一年的12个月(01～09和1～12)1^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)1^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件1^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式1[\u4e00-\u9fa5] 双字节字符1[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式1\n\s*\r (可以用来删除空白行) HTML标记的正则表达式1&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式1^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号1[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始) 中国邮政编码1[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字) IP地址1\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) IP地址1((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 钱的输入格式 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”： 1^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式 1^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号： 1^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分： 1^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的： 1^[0-9]+(.[0-9]&#123;2&#125;)?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样： 1^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样： 1^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须： 1^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 声明本篇文章源于一篇zxin博主的博文，仅作整理。 点击这里查看原文]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django路由和视图]]></title>
    <url>%2F2018%2F03%2F21%2FDjango%E8%B7%AF%E7%94%B1%E5%92%8C%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这篇主要介绍了Django中urls.py与views.py的配置，HttpRequest对象和HttpResponse对象属性和方法。 路由系统URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表；你就是以这种方式告诉Django，对于不同URL分别调用的代码是什么。 123urlpatterns = [ url(正则表达式, views视图函数，参数，别名),] 参数： 一个正则表达式字符串 一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串 可选的要传递给视图函数的默认参数（字典形式） 一个可选的name参数 视图函数views.py中的函数是用来编写与路由系统绑定函数，用于处理hhtp请求。在http请求中两个核心对象： http请求：HttpRequest对象 http响应：HttpResponse对象 1234567891011121314def userinfo(request): # 第一次为Get不执行if submit之后method为POST print(request.method) if request.method == "POST": username = request.POST.get("username", None) sex = request.POST.get("sex", None) mail = request.POST.get("mail", None) models.UserInfo.objects.create( username=username, sex = sex, mail = mail ) print(username,sex,mail) 我们这里用到的参数request就是HttpRequest 检测方法：isinstance(request,HttpRequest) HttpRequest对象的属性和方法属性 属性 描述 path 请求页面的全路径，不包括域名 method 请求中使用的HTTP方法的字符串表示。全大写表示。 例子：12345if req.method == &quot;GET&quot;: do_something()elseif req.method == &quot;POST&quot;: do_something_else() 服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用if req.POST来判断是否使用了HTTP POST 方法；应该使用 if req.method==”POST” 属性 描述 GET 包含所有HTTP GET参数的类字典对象 POST 包含所有HTTP POST参数的类字典对象 COOKIES 包含所有cookies的标准Python字典对象；keys和values都是字符串。 FILES： 包含所有上传文件的类字典对象； FILES中的每一个Key都是&lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;标签中name属性的值，FILES中的每一个value同时也是一个标准的python字典对象，包含下面三个Keys： filename： 上传文件名，用字符串表示 content_type: 上传文件的Content Type content： 上传文件的原始内容 属性 描述 user 一个django.contrib.auth.models.User对象，代表当前登陆的用户。 如果访问用户当前没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你可以通过user的is_authenticated()方法来辨别用户是否登陆。if req.user.is_authenticated()只有激活Django中的AuthenticationMiddleware时该属性才可用。 属性 描述 session 唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。 方法 方法 描述 get_full_path() 得到完整路径 比如：http://127.0.0.1:8000/index33/?name=123 req.get_full_path()得到的结果： /index33/?name=123 req.path得到的结果: /index33 HttpResponse对象对于HttpRequest对象来说，是由django自动创建的，但是HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。 HttpResponse类在django.http.HttpResponse 在HttpResponse对象上扩展的常用方法： 方法 描述 页面渲染 render()（推荐）; render_to_response() 页面跳转 redirect(“路径”) locals() 可以直接将函数中所有的变量传给模板]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyinstaller模块]]></title>
    <url>%2F2018%2F03%2F19%2Fpyinstaller%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[写好脚本经常想要进行打包成exe，这篇文章简单的介绍下，如何使用pyinstaller进行打包写好的脚本。 安装1pip install pyinstaller 使用安装好的pyinstaler，会在你的python目录的scrip里，嗯，就是你pip的目录，如果你之前配置好了pip到环境变量，那么安装好之后，可以直接在命令提示行里直接执行命令。 1pyinstaller -F 路径/xxxx.py 直接进行打包你的脚本，成功之后你生成的可执行文件会在C:\Users\xxx\dist路径下，xxx为你的用户名。 感觉是不是so easy，但其实这个模块还有其他的参数，便于你做一些其他的修改。 参数 参数 描述 -F 制作独立的可执行程序 -D 制作出的档案存放在同一个文件夹下（默认值） -K 包含TCL/TK（对于使用了TK的，最好加上这个选项，否则在未安装TK的电脑上无法运行） -w 制作窗口程序 -c 制作命令行程序（默认） -X 制作使用UPX压缩过的可执行程序（推荐使用这个选项，需要下载UPX包，解压后upx.exe放在Python(非PyInstaller)安装目录下，下载upx308w.zip） -o DIR 指定输出SPEC文件路径（这也决定了最后输出的exe文件路径） –icon=[ICO文件路径] 指定程序图标 -v [指定文件] 指定程序版本信息 -n [指定程序名] 指定程序名称]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eval实现计算器]]></title>
    <url>%2F2018%2F03%2F19%2Feval%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[上次介绍了eval这个函数，也说了可以用来实现计算器，那么这次来实践一下，利用eval来实现一个功能较为完善的计算器，支持加减乘除与指数运算，支持长表达式计算，实现连续计算功能。 明确需求整体上需要的就是这一个强大的函数，就可以实现一个基本功能的计算器。12while True: print(str(eval(input("输入表达式:\n"))) 对，基本功能已经实现了，但是这并不是一个功能完备的计算器，我们需要对其做一些功能和安全方向的完善。上篇文章讲了eval函数的危险，那我们首先需要做的就是语法检查，这里就引出了需要的re模块，回顾re模块的请点击这里. 其次，我们还需要进行异常处理。 对了，我们还需要有连续计算的能力。 到这里，需求基本上也就都明确了，明确了需求，我们就按照这三大块，对我们的程序进行完善，看看最终的两行函数，离我们最终的成品还差多远。 语法检查导入模块1import re 检查点1–是否含有非法字符如果输入的表达式含有字母和非运算符，那么这个表达式就是不合法的，对这样的表达式我们拒绝它执行，并且给与他友好性的提示，提示输入正确的表达式，并返回-1并表示表达式非法。 123456def CharErrorCheck(str_in): if re.findall(r'[&amp;a-zA-Z&lt;&gt;,?~!@#$%";:]', str_in): # 正则表达式校验输入字符串的合法性 print('错误：表达式包含非法字符，请重新输入\n') return 1 else: return -1 检查点2–括号是否平衡确保括号成对出现，如不符合，给与友好型提示。返回-1表示表达式不合法。123456789101112def BracketUnbalanceCheck(str_in): num = 0 for i in str_in: if i == '(': num += 1 elif i == ')': num -= 1 if num != 0: # 括号不平衡 print("错误：输入的括号不平衡，请重新输入\n") return 1 else: # 括号平衡 return -1 进行语法检查后，就要开始计算了，那么这里首先就要加上继续计算的功能，就是上一次计算结束后的结果进行保留，可以继续使用上一次的结果作为输入。 继续计算功能其实。要添加这个功能不难，仅仅需要一个标志位来判断是不是继续上一次的计算。这时候就可能有人要问了，怎么判断是不是想要继续计算呢？ 很简单，如果继续计算的话，那么他新输入的第一个字符就是运算符，如果不是运算符，那么就是开启了一个新的运算式。 判断是否为继续计算如果判定为继续计算，那么返回&#39;continue&#39;，否则返回 &#39;new&#39;123456789def InputExpression(): global exprs while not (CharErrorCheck(exprs) == -1 and BracketUnbalanceCheck(exprs) == -1): # 直到得到一个合法的表达式 exprs = input("继续输入表达式:\n") m = re.match(r'^[\^/\*+\-\\]\w*', exprs) # 匹配输入字符串的第一个字符是否是运算符，判断继续运算还是开始新计算 if m: return 'continue' else: return 'new' 开始计算与异常处理根据全局变量flag，适当修改计算式。如果含有几次方的计算,将^修改为**使用eval函数进行计算接着使用try语句块进行处理，语法错误或是0当作除数，给与友好型提示。1234567891011121314def Compute(flag): global exprs global sum exprs = exprs.replace('^', '**') # 将^替换为** if flag == 'continue': exprs = str(sum) + exprs try: sum = eval(exprs) print(exprs) print("=" + str(sum)) except SyntaxError: print("错误：继续计算时出现语法错误，程序返回\n") except ZeroDivisionError: print("错误：除数不能为0，程序返回\n") 锦上添花至此所有的需求都已经实现，在主函数里面串起来即可。当然还可以添加一些锦上添花的功能，比如添加版权信息或是使用pyinstaller进行函数打包成exe都是可以的。具体怎么优化就看你了。 附录-源码完整源码请点击这里获取。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>eval</tag>
        <tag>计算器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eval函数]]></title>
    <url>%2F2018%2F03%2F17%2Feval%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在Python中有个神级函数，没错，神级函数，就是eval，它可以实现一些非常牛逼的操作。 语法它可以将字符串str当成有效的表达式来求值并返回计算结果。 1eval(expression，globals=None, locals=None) 参数 参数 描述 expression 一个参与计算的python表达式 globals 可选的参数，如果设置属性不为None的话，就必须是dictionary对象了 locals 一个可选的对象，如果设置属性不为None的话，可以是任何map对象了 用法既然说是神级函数，那么他到底有什么用呢？ 类型转化可以把list,tuple,dict和string相互转化。 str转换成list12345a = "[[1,2], [3,4], [5,6], [7,8], [9,0]]"b = eval(a)print(b)print(type(b)) 12[[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]&lt;class 'list'&gt; str转换成dict12345a = "&#123;1: 'a', 2: 'b'&#125;"b = eval(a)print(b)print(type(b)) 12&#123;1: 'a', 2: 'b'&#125;&lt;class 'dict'&gt; 用于计算可以直接输入计算的表达式，就可以直接返回结果，所以用这个函数来写计算器函数是非常好写的，仅仅几行就可以写一个计算器的基本功能。 12345if __name__ == '__main__': while True : result = eval(input("请输入计算式：")) print(type(result)) print(result) 123请输入计算式：3*7+9&lt;class 'int'&gt;30 使用eval实现完整功能的计算器，请点击这里 插曲-变量寻址123456789101112x = 1y = 1num1 = eval("x+y")print(num1)def func(): x = 2 y = 2 num2 = eval("x+y") print(num2) num3 = eval("x+y", globals()) # num3 = eval("x+y", locals()) print(num3) 上面的x，y为全局变量，函数func内的为局部变量。在使用eval函数是可以定义要寻找变量的类型。重点看下上面代码的num3的值，如果是设定找的是全局变量，那么会返回2，设定局部变量表达式会返回4.如果并没有设定，默认先寻找local(), 123456789# 搜索变量的优先级顺序是：L &gt; E &gt; G &gt; B# L：local 局部作用域，即函数中的变量# E：enclosing，嵌套的父级函数的作用域，即，此函数的上级函数的局部作用域，但不是全聚德# G：global：全局变量，就是米会计别定义的变量# B：build-in 系统固定模块里面的变量，如int byte等 存在的问题与解决办法存在的问题就是安全问题了，当然就自己在本地跑脚本玩，也没什么问题， 如果python写的cgi程序中如果使用eval()而非int()来转换诸如年龄这样的输入框中的内容时是非常危险的。不仅可以看见列出系统的全部文件，还可以执行删除文件，察看文件源代码等危险操作！ 解决办法1.法1 eval接受3个参数: eval(source[, globals[, locals]]) -&gt; value 只要将2个命名空间置空即可隔绝上下文的代码进行安全执行表达式。 1eval('&#123;1:2&#125;',&#123;&#125;,&#123;&#125;) 不过！ 通过builtins内置的方法仍有可能绕过:import(‘os’).system(‘dir’)、 eval(“globals()”, {}, {})。 2.法2 ast模块就是帮助Python应用来处理抽象的语法解析的。而该模块下的literal_eval()函数：则会判断需要计算的内容计算后是不是合法的python类型，如果是则进行运算，否则就不进行运算。 比如说上面的计算操作，及危险操作，如果换成了ast.literal_eval()，都会拒绝执行。 嗯，如果使用这个函数做计算器是没戏的。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>内置函数</tag>
        <tag>eval</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头信息自动添加]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%A4%B4%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[每次写Header部分真的很烦，即使每次都只是从原来写好的模板上复制过来改一改，都是一件很麻烦的事情，时间浪费在这种琐碎的事情上真的很不值得。这篇记录自己平时使用Pycharm的一个小技巧吧，如何在创建文件时候自动添加文件信息，时间，工程信息还有个人的一些信息，希望能节省下大家一些宝贵的时间。 这种小技巧，可能真的很简单，可是真的非常有用，还有必要分享一下。 操作按照下面的顺序操作： Pycharm →→ File→→Settings→→Editor→→File and code Templates 在右侧的选项中找到Python Script，如下图： 在右侧输入你想要的模板格式，拿我的举例，实现了自动添加文件名称，时间自动填充： 如果每天手打这些东西是真的很累，即使是复制，日积月累的工作量也并不小的。 语法1$ &#123;&lt;variable_name&gt;&#125; 预定义变量下面列举下IDE中预先定义好的变量。 12345678910111213$&#123;PROJECT_NAME&#125; - the name of the current project.$&#123;NAME&#125; - the name of the new file which you specify in the New File dialog box during the file creation.$&#123;USER&#125; - the login name of the current user.$&#123;DATE&#125; - the current system date.$&#123;TIME&#125; - the current system time.$&#123;YEAR&#125; - the current year.$&#123;MONTH&#125; - the current month.$&#123;DAY&#125; - the current day of the month.$&#123;HOUR&#125; - the current hour.$&#123;MINUTE&#125; - the current minute.$&#123;PRODUCT_NAME&#125; - the name of the IDE in which the file will be created.$&#123;MONTH_NAME_SHORT&#125; - the first 3 letters of the month name. Example: Jan, Feb, etc.$&#123;MONTH_NAME_FULL&#125; - full name of a month. Example: January, February, etc. 更改预变量预定义变量也是可以自己进行更改的，当然自己创建变量再引用也是完全OK的，但有什么必要呢，直接写死不就好了。1#set($USER = "Handsome") Hearder还是很重要的，我的头格式仅仅对大家当作一个参考，内容不多，希望对大家能有所帮助。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pycharm</tag>
        <tag>头信息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌套列表合并为一维列表]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E7%BB%B4%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[今天看到一个题，觉得很有意思，就是一个列表里面嵌套了几层列表，那么如何将他们全部转换到一个列表里？可能应用有限，但确实很有趣，实现方式也很多，适合用来拓展下思维。 需求我们有一个嵌套列表，他是这个样子的： 1a = [[1, 2], 3, [4, 5], &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 然后需要将其转为一维列表：1a_new = [1, 2, 3, 4, 5, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 方法一：递归最简单的办法，就是递归。 把列表传进去 定义一个列表用来接收新的列表元素 开始循环遍历列表 如果当前元素不是列表，就直接附到新列表后面 如果当前元素为列表，进行递归操作 遍历结束后，返回新列表1234567def expand_list1(nested_list, em=[]): for x in nested_list: if type(x) != list: em.append(x) else: expand_list1(x) return em 方法二：生成器+递归在上面递归的思想下，在使用生成器的方法，不是列表和元组的直接使用yield语法糖，是列表或元组的直接递归即可。1234567def expand_list2(nested_list): for item in nested_list: if isinstance(item, (list, tuple)): for sub_item in expand_list1(item): yield sub_item else: yield item 方法三：字符串替换可能这种是最好理解的，但不是最容易想到的。惯性思维下，都会先考虑列表的操作。思路就是：先转成字符串，匹配两端的方括号，再替换里面的方括号12def expand_list2(nested_list): return eval(&apos;[%s]&apos; % repr(nested_list).replace(&apos;[&apos;, &apos;&apos;).replace(&apos;]&apos;, &apos;&apos;)) 方法四：列表推导式说实话，这是第一种想到的办法，毕竟这个列表嵌套最多就有两层，但是失败了！看了报错，恍然大悟。我们的列表中，有个单独的int类型，他并不是一个可迭代对象。 1a = [[1, 2], 3, [4, 5], &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 12def expand_list4(nested_list): return [i for item in nested_list for i in item] 其实即使没有单独的int类型，还是可以实现需求的，但是，这样的话就会将字符串进行迭代，就是说如果有个单独的“abc”，也会被拆分成单独的字母。显然，这不是我们想要的效果。 这个题其实限制还是有点多，如果是单纯的数字，没有字符串的话，其实解法话有很多。 123import itertoolsa = [[1,2,3],[4,5,6], [7], [8,9]]out = list(itertools.chain.from_iterable(a)) 123import numpy as npa = [[1,2,3], [5, 2, 8], [7,8,9]]out = list(np.ravel(a)) 还有什么好方法，请猛戳这里告诉我]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>列表</tag>
        <tag>迭代</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML标签元素]]></title>
    <url>%2F2018%2F03%2F14%2FHTML%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[接触web难免会用到一些HTML语法，这里记录了一些常用的标签的用法，更多的再用到的时候再更新到这里。还有一点想说的是markdown是兼容这些语法的，如果有些想要实现的markdown不支持，完全可以使用HTML来代替，也算个小技巧吧。 HTML基本语法XHTML文档的扩展名通常是.html或者.htm。XHTML元素使用XHTML标记定义，每个标记都出现一对尖括号中&lt;&gt;，第一个标记为开始标记，后一个标记为结束标记。在开始标记与结束标记之间的内容叫元素内容。 HTML总体结构所有的XHTML文档都有三个文档级的元素：html、head和body。 html元素的标记之间是XHTML文档的内容，这个元素告诉客户端浏览器文档的开头和结尾； head元素定义XHTML文档的标题部分； meta标签声明字符编码集； body标记定义网页正文部分。 在一个XHTML文档中，html、head、body元素必须出现，且head元素中必须包含有title标签. HTML文档正文正文标题XHTML提供了六个标题标签，h1、h2、h3、h4、h5、h6，分别代表六个级别的标题，其重要性依次递减。123456&lt;h1&gt;h1标记，表示一级标题&lt;/h1&gt;&lt;h2&gt;h2标记，表示二级标题&lt;/h2&gt;&lt;h3&gt;h3标记，表示三级标题&lt;/h3&gt;&lt;h4&gt;h4标记，表示四级标题&lt;/h4&gt;&lt;h5&gt;h5标记，表示五级标题&lt;/h5&gt;&lt;h6&gt;h6标记，表示六级标题&lt;/h6&gt; 定义段落XHTNL文档中p标签表示一个段落（Paragraph）1&lt;p&gt;这是p标记，它表示一个段落。&lt;/p&gt; 引用文本在XHTML文档中使用&lt;blockquote&gt;标签界定引用文本块。 这里是引用文本区域 定义列表有序列表：用ol标签（Ordered Lis）1234&lt;ol&gt; &lt;li&gt;有序标记，每个列表以数字形式标识&lt;/li&gt; &lt;li&gt;有序标记，每个列表以数字形式标识&lt;/li&gt; &lt;/ol&gt; 有序标记，每个列表以数字形式标识 有序标记，每个列表以数字形式标识 无序列表：用ul标签（Unordered List）1234&lt;ul&gt; &lt;li&gt;无序标记，每个列表以小黑点标识&lt;/li&gt; &lt;li&gt;无序标记，每个列表以小黑点标识&lt;/li&gt; &lt;/ul&gt; 无序标记，每个列表以小黑点标识 无序标记，每个列表以小黑点标识 定义列表：用dl标签（Defined List）1234&lt;dl&gt; &lt;dt&gt;猫&lt;/dt&gt; &lt;dd&gt;一种可爱的动物&lt;/dd&gt; &lt;/dl&gt;` 猫 一种可爱的动物 预排文本在XHTML中有时我们需要保持文本原来的格式，于是我们需要用到pre标签。 1234567&lt;pre&gt; 2.9+ 1.2—————— 4.1&lt;/pre&gt; 分块或分节&lt;div&gt; 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。如果用 id 或 class 来标记 &lt;div&gt;，那么该标签的作用会变得更加有效。 123&lt;div style=&quot;color:#00FF00&quot;&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/div&gt; This is a paragraph. 组合行内元素1&lt;p&gt;这是&lt;span style=&quot;color:blue;&quot;&gt;一行中&lt;/span&gt;的文字&lt;/p&gt; 这是一行中的文字]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django框架和基本命令]]></title>
    <url>%2F2018%2F03%2F14%2FDjango%E6%A1%86%E6%9E%B6%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这篇记录了web框架的简单介绍，django的结构和基本django命令，一切才刚刚开始，新的一天也要有新的收获。愿时光不负以往。 web框架即framework，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构，使用框架可以帮你快速开发特定的系统，简单地说，就是你用别人搭建好的舞台来做表演。 对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。 如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。 正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口，让我们专心用Python编写Web业务。 这个接口就是WSGI：Web Server Gateway Interface。下面是一个简单的框架，可以了解一下。 点击这里，查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from wsgiref.simple_server import make_serverimport timedef f1(req): print(req) print(req["QUERY_STRING"]) f1 = open("index1.html", "rb") data1 = f1.read() return [data1]def f2(req): f2 = open("index2.html", "rb") data2 = f2.read() return [data2]def f3(req): # 模版以及数据库 f3 = open("index3.html", "rb") data3 = f3.read() times = time.strftime("%Y-%m-%d %X", time.localtime()) data3 = str(data3, "utf8").replace("!time!", str(times)) return [data3.encode("utf8")]def routers(): urlpatterns = ( ('/person1', f1), ('/person2', f2), ("/cur_time", f3) ) return urlpatternsdef application(environ, start_response): print(environ['PATH_INFO']) path = environ['PATH_INFO'] start_response('200 OK', [('Content-Type', 'text/html')]) urlpatterns = routers() func = None for item in urlpatterns: if item[0] == path: func = item[1] break if func: return func(environ) else: return ["&lt;h1&gt;404&lt;/h1&gt;".encode("utf8")]httpd = make_server('', 8518, application)print('Serving HTTP on port 8084...')# 开始监听HTTP请求:httpd.serve_forever() MVC和MTV模式Django的MTV模式本质是各组件之间为了保持松耦合关系,Django的MTV分别代表： Model(模型)：负责业务对象与数据库的对象(ORM) Template(模版)：负责如何把页面展示给用户 View(视图)：负责业务逻辑，并在适当的时候调用Model和Template 此外，Django还有一个url分发器，它的作用是将一个个URL的页面请求分发给不同的view处理，view再调用相应的Model和Template。 Django命令有些坑要说在创建之前，你需要先安装sqlite，在创建应用，不然你会掉进坑里的， 创建django project在你想创建项目的路径下：1django-admin.py startproject [project name] [project name] 填写你的项目名称 当然这里可能会遇到一个问题，为什么我这里什么都没有啊，两个问题：一就是你没有将django的目录放进环境变量；二就是你的默认打开.py文件的不是python。 其实还有另一种解决方案：如果你是Django 3.x，完全可以不加.py: 1django-admin startproject [project name] 以生成mysite为例，目录结构是这样的： manage.py —– Django项目里面的工具，通过它可以调用django shell和数据库等。 settings.py —- 包含了项目的默认设置，包括数据库信息，调试标志以及其他一些工作的变量。 urls.py —– 负责把URL模式映射到应用程序。 创建应用在mysite目录下创建应用，比如blog: 1python manage.py startapp blog 启动项目这样我们的django就启动起来了！当我们访问：http://127.0.0.1:4000/时就可以看到我们的效果。当然，你访问localhost:4000也是一样的。1python manage.py runserver 4000 同步更改数据库表或字段12python manage.py makemigrationspython manage.py migrate 这种方法可以创建表，当你在models.py中新增了类时，运行它就可以自动在数据库中创建表了，不用手动创建。 清空数据库1python manage.py flush 此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。 创建超级管理员12python manage.py createsuperuser # 按照提示输入用户名和对应的密码就好了邮箱可以留空，用户名和密码必填 修改用户密码1python manage.py changepassword username 环境终端1python manage.py shell 这个命令和 直接运行 python 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据的测试非常方便。 1python manage.py dbshell Django 会自动进入在settings.py中设置的数据库，如果是 MySQL 或 postgreSQL,会要求输入数据库用户密码。 在这个终端可以执行数据库的SQL语句 查看所有命令1python manage.py]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map实现并行]]></title>
    <url>%2F2018%2F03%2F13%2Fmap%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[在Python中有个两个库包含了map函数：multiprocessing和它鲜为人知的子库dummy。它是multiprocessing模块的完整克隆，唯一的不同在于multiprocessing作用于进程，而dummy模块作用于线程（因此也包括了Python所有常见的多线程限制）。所以选择使用这两个库异常容易。你可以针对IO密集型任务和CPU密集型任务来选择不同的库。 导入12from multiprocessing import Poolfrom multiprocessing.dummy import Pool as ThreadPool 实例化Pool 对象有一些参数，这里我所需要关注的只是它的第一个参数：processes. 这一参数用于设定线程池中的线程数。其默认值为当前机器 CPU 的核数。 一般来说，执行 CPU 密集型任务时，调用越多的核速度就越快。但是当处理网络密集型任务时，事情有有些难以预计了，通过实验来确定线程池的大小才是明智的。 1pool = ThreadPool(4) # Sets the pool size to 4 线程数过多时，切换线程所消耗的时间甚至会超过实际工作时间。对于不同的工作，通过尝试来找到线程池大小的最优值。创建好 Pool 对象后，并行化的程序 多线程例子1234567891011121314151617181920212223242526272829import timeimport urllib.requestfrom multiprocessing.dummy import Pool as ThreadPoolurls = [ &apos;http://www.python.org&apos;, &apos;http://www.python.org/about/&apos;, &apos;http://www.python.org/doc/&apos;, &apos;http://www.python.org/download/&apos;, &apos;http://www.python.org/getit/&apos;, &apos;http://www.python.org/community/&apos;, &apos;https://wiki.python.org/moin/&apos;, &apos;http://planet.python.org/&apos;, &apos;https://wiki.python.org/moin/LocalUserGroups&apos;, &apos;http://www.python.org/psf/&apos;, &apos;http://docs.python.org/devguide/&apos;, &apos;http://www.python.org/community/awards/&apos; # etc..]pool_num = 4start_time = time.time()# 实例化线程池，并规定线程池大小pool = ThreadPool(pool_num)# 打开每个网站在线程中results = pool.map(urllib.request.urlopen, urls)pool.close()pool.join() # 等待进程结束end_time = time.time()print(&quot;pool=%s总用时：&quot; % pool_num, end_time - start_time, &quot;s&quot;) 为了找到最优的线程池大小，通过修改pool_num大小得到的总时间对比，当然这种方法比较笨，需要每次修改，完全可以写进循环for i in range(min=0,max=8):，再将 i 赋值给pool_num,当然这里就不改了，也比较简单。 12345pool=2总用时： 7.664671182632446 spool=3总用时： 5.713357210159302 spool=4总用时： 5.139662504196167 spool=5总用时： 7.917045593261719 spool=6总用时： 23.377182006835938 s 从数据上验证了，上面的说法，并不是线程池越大，用时最短。 多进程例子生成图片的缩略图，这是一个 CPU 密集型的任务，并且十分适合进行并行化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import os, timefrom multiprocessing import Poolfrom PIL import ImageSIZE = (75, 75)SAVE_DIRECTORY = 'thumbs'def get_image_paths(folder): return (os.path.join(folder, f) for f in os.listdir(folder) if 'jpg' in f)def create_thumbnail(filename): im = Image.open(filename) im.thumbnail(SIZE, Image.ANTIALIAS) base,fname = os.path.split(filename) print(fname) save_path = os.path.join(base, SAVE_DIRECTORY, fname) im.save(save_path)if __name__ == '__main__': pool_num = 4 start_time = time.time() folder = os.path.realpath(r'C:\Users\Liu\Pictures\最近') try: # 查看是否已存在相同文件夹 os.mkdir(os.path.join(folder, SAVE_DIRECTORY)) except FileExistsError: pass # 注意这里返回的不再是列表,而是迭代器 images = get_image_paths(folder) # 列表化 images = list(images) print(images) try: pool = Pool(pool_num) pool.map(create_thumbnail, images) pool.close() pool.join() except: pass end_time = time.time() print("pool=%s总用时：" % pool_num, end_time - start_time, "s") 这里同上面的例子一样可以进行寻找最优的pool_num,这里就不找了，想要实验的可以直接把代码copy过去，改个路径，python3直接可以运行。 总结在生产环境中，我们可以为 CPU 密集型任务和 IO 密集型任务分别选择多进程和多线程库来进一步提高执行速度——这也是解决死锁问题的良方。此外，由于 map 函数并不支持手动线程管理，反而使得相关的 debug 工作也变得异常简单。 声明本篇文章来自这里(点击这里查看原文)，并根据python3与python2的区别对代码做了适当修改，python2的代码请参考原文。还有一点要注意的是python3中大多数原来返回列表的已经改为返回迭代器，查看网上资料的时候，一不小心就会被坑一下。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
        <tag>多进程</tag>
        <tag>map</tag>
        <tag>multiprocessing.dummy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F03%2F12%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[虽然Python多线程有缺陷，总被人说成是鸡肋，但也不是一无用处，它很适合用在IO密集型任务中。I/O密集型执行期间大部分是时间都用在I/O上，如数据库I/O，较少时间用在CPU计算上。因此该应用场景可以使用Python多线程，当一个任务阻塞在IO操作上时，我们可以立即切换执行其他线程上执行其他IO操作请求。 导入1import threading Python中使用线程有两种方式：函数或者用类来包装线程对象。 基于函数线程调用 threading 模块中的Thread()函数来产生新线程。语法如下: 1threading.Thread( function, args[, kwargs] ) 参数说明: 参数 描述 function 线程函数。 args 传递给线程函数的参数,他必须是个tuple类型。 kwargs 可选参数。 下面来看一个实例： 123456789101112131415161718192021222324252627import threading, timedef test(s): print("线程%d开始" % s) start_time = time.time() time.sleep(3) print("线程%d结束" % s) end_time = time.time() print("线程%d花费的时间为：" % s, end_time - start_time)if __name__ == '__main__': threads_list = [] # 定义一个线程空列表 start = time.time() # 总的开始时间 for i in range(0, 4): # 生成四个线程实例，并将他们存到列表里 t = threading.Thread(target=test, args=(i,)) threads_list.append(t) for t in threads_list: # 循环遍历列表，启动每一个线程 t.start() for t in threads_list: # 循环遍历列表，等待每一个线程结束 t.join() end = time.time() # 总的结束时间 print("总共花费的时间：", end - start) 运行结果：12345678910111213线程0开始线程1开始线程2开始线程3开始线程1结束线程1花费的时间为： 3.000976085662842线程0结束线程2结束线程0花费的时间为： 3.000976085662842线程2花费的时间为： 3.000976085662842线程3结束线程3花费的时间为： 3.0009756088256836总共花费的时间： 3.0027308464050293 四个线程，每个线程单独完成的时间基本上一样，但是经过多线程的处理，总共的运行时间也才3秒多一点，可见多线程IO阻塞情况下还是可以大大提高我们的运行效率的。 基于类的线程将上面的例子，改为基于类实现，方便对比： 123456789101112131415161718192021222324252627282930class Test(threading.Thread): def __init__(self, name=0): # 继承父类的两种方式 # super().__init__() threading.Thread.__init__(self) self.name = name def run(self): print(&quot;线程%s开始&quot; % self.name) start_time = time.time() time.sleep(3) print(&quot;线程%s结束&quot; % self.name) end_time = time.time() print(&quot;线程%s花费的时间为：&quot; % self.name, end_time - start_time)if __name__ == &apos;__main__&apos;: threads_list = [] # 定义一个线程空列表 start = time.time() # 总的开始时间 for i in range(0, 4): # 生成四个线程实例，并将他们存到列表里 t = Test(name=i) threads_list.append(t) for t in threads_list: # 循环遍历列表，启动每一个线程 t.start() for t in threads_list: # 循环遍历列表，等待每一个线程结束 t.join() end = time.time() # 总的结束时间 print(&quot;总共花费的时间：&quot;, end - start) 两者实现的效果相同，条条大路通罗马，只是走的路不同而已。 线程模块中其他方法 方法名 描述 run() 用以表示线程活动的方法。 start() 启动线程活动。 join([time]) 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。 isAlive() 返回线程是否活动的。 getName() 返回线程名。 setName() 设置线程名。 线程锁如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要保证每次只有一个线程对其修改，这就需要用到我们的线程锁。 Thread 对象的 Lock 和 Rlock 可以实现这样的功能，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。 看个例子，使用十个线程对同一个全局变量进行修改：1234567891011121314151617import threading, timeglobal_num = 0lock = threading.RLock() # 获得锁def show(): lock.acquire() # 上锁 global global_num time.sleep(1) global_num += 1 print(global_num) lock.release() # 解锁if __name__ == &apos;__main__&apos;: for i in range(10): # 启动十个线程 t = threading.Thread(target=show) t.start() 上面说了Lock和RLock方法都可以获得锁，那么两者的区别是什么呢？ Lock和RLock的区别 RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。注意：如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的琐。 Condition方法在threading中除了Lock和RLock，还可以使用Condition(条件)方法达到想要的效果。可以把Condiftion理解为一把高级的琐，它提供了比Lock, RLock更高级的功能，允许我们能够控制复杂的线程同步问题。threadiong.Condition在内部维护一个琐对象（默认是RLock），可以在创建Condigtion对象的时候把琐对象作为参数传入。Condition也提供了acquire, release方法，其含义与琐的acquire, release方法一致，其实它只是简单的调用内部琐对象的对应的方法而已。 Condition还提供了如下方法(注意：这些方法只有在占用琐(acquire)之后才能调用，否则将会报RuntimeError异常。)： Condition.wait([timeout]): wait方法释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。 Condition.notify(): 唤醒一个挂起的线程（如果存在挂起的线程）。注意：notify()方法不会释放所占用的琐。 Condition.notifyAll()： 唤醒所有挂起的线程（如果存在挂起的线程）。注意：这些方法不会释放所占用的琐。 处于waiting状态的线程只能通过notify方法唤醒，所以notifyAll的作用在于防止有线程永远处于沉默状态。 附上经典的消费者与生产者模型：2个生成者生产products ，而接下来的10个消费者将会消耗products。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import threading, timecondition = threading.Condition()products = 0class Producer(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global condition, products while True: if condition.acquire(): if products &lt; 10: products += 1 print("Producer(%s):deliver one, now products:%s" % (self.name, products)) condition.notify() else: print("Producer(%s):already 10, stop deliver, now products:%s" % (self.name, products)) condition.wait(); condition.release() time.sleep(2)class Consumer(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global condition, products while True: if condition.acquire(): if products &gt; 1: products -= 1 print( "Consumer(%s):consume one, now products:%s" % (self.name, products)) condition.notify() else: print("Consumer(%s):only 1, stop consume, products:%s" % (self.name, products)) condition.wait() condition.release() time.sleep(2)if __name__ == "__main__": for p in range(0, 2): p = Producer() p.start() for c in range(0, 10): c = Consumer() c.start() Thread.Local方法当不想将变量共享给其他线程时，可以使用局部变量，但在函数中定义局部变量会使得在函数之间传递特别麻烦。ThreadLocal解决了全局变量需要枷锁，局部变量传递麻烦的两个问题。通过在线程中定义： 1local_school = threading.local() 此时这个local_school就变成了一个全局变量，但这个全局变量只在该线程中为全局变量，对于其他线程来说是局部变量，别的线程不可更改。 1def process_thread(name):# 绑定ThreadLocal的student: local_school.student = name 这个student属性只有本线程可以修改，别的线程不可以。 123456789local = threading.local()def func(name): print(&apos;current thread:%s&apos; % threading.currentThread().name) local.name = name print(&quot;%s in %s&quot; % (local.name,threading.currentThread().name))t1 = threading.Thread(target=func,args=(&apos;haibo&apos;,))t2 = threading.Thread(target=func,args=(&apos;lina&apos;,))t1.start()t2.start()]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPMITOOL指令]]></title>
    <url>%2F2018%2F03%2F12%2FIPMITOOL%2F</url>
    <content type="text"><![CDATA[IPMITOOL是一种可用在 Linux/Unix 系统下的基于命令行方式的 ipmi 平台管理工具。利用它可以实现获取传感器的信息、显示系统日志内容、网络远程开关机等功能。其主要功能包括读取和显示传感器数据（SDR），显示System Evernt Log（SEL）的内容，显示打印Field Replaceable Unit（FRU）信息，读取和设置BMC模块的LAN配置，远程控制服务器主机的电源。 开关机，重启1. 查看开关机状态：1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) power status 2. 开机：1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) power on 3. 关机：1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) power off 4. 重启：1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) power reset 用户管理 [ChannelNo] 字段是可选的，ChannoNo为1或者8；BMC默认有2个用户：user id为1的匿名用户，user id为2的ADMIN用户；&lt;&gt;字段为必选内容；&lt;privilege level&gt; 2为user权限，3为Operator权限，4为Administrator权限； 1. 查看用户信息1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) user list [ChannelNo] 2. 增加用户1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) user set name &lt;user id&gt; &lt;username&gt; 3. 设置密码1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) user set password &lt;user id&gt; &lt;password&gt; 4. 设置用户权限1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) user priv &lt;user id&gt; &lt;privilege level&gt; [ChannelNo] 5. 启用/禁用用户1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) user enable/disable &lt;user id&gt; Watchdog配置1. 查看当前的watchdog信息1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc watchdog get 2. 设置，开启watchdog1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc watchdog get 设置一个OS WDT的watchdog, 超时时间为60秒（自己看IPMI 2.0手册,351页的27.6 Set Watchdog Timer Command）(60x10=600 = 0x258) 1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x06 0x24 0x04 0x01 0x00 0x10 0x58 0x2 1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc watchdog get 开启该watchdog 1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc watchdog reset 1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc watchdog get 禁止watchdog动作(Hard reset-&gt; no action)1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x06 0x24 0x04 0x00 0x00 0x10 0x58 0xFF 上面的命令把时间改为非常大，提示第1个0x00表示没有动作，0x04表示是SMS/OS的watchdog, 0xFF58是超时的时间，单位为100ms。 IP网络设置 [ChannelNo] 字段是可选的，ChannoNo为1(Share Nic网络)或者8（BMC独立管理网络）；设置网络参数，必须首先设置IP为静态，然后再进行其他设置； 1. 查看网络信息1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) lan print [ChannelNo] 2. 修改IP为静态还是DHCP模式1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) lan set &lt;ChannelNo&gt; ipsrc &lt;static/dhcp&gt; 3. 修改IP1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) lan set &lt;ChannelNo&gt; ipaddr &lt;IPAddress&gt; 4. 修改子网掩码1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) lan set &lt;ChannelNo&gt; netmask &lt;NetMask&gt; 5. 修改默认网关1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) lan set &lt;ChannelNo&gt; defgw ipaddr &lt;默认网关&gt; SOL功能 &lt;9.6/19.2/38.4/57.6/115.2&gt;其中115.2代表115200，即*1000是表示的波特率。 1. 设置SOL串口波特率1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sol set volatile-bit-rate &lt;9.6/19.2/38.4/57.6/115.2&gt; 2. 打开SOL功能1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sol activate 3. 关闭SOL功能1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sol deactivate SEL日志查看1. 查看当前的SEL summary信息12ipmitool -H (IP) -I lanplus -U (用户) -P (密码) selipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel info 2. 列示所有SEL记录详细信息12ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel listipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel list 10 3. 删除指定的SEL记录1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel delete 1 4. 清除所有的SEL记录1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel clear 5. 获取和修改SEL当前时钟12ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel time getipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel time set &quot;04/24/2018 18:44:44&quot; 6. 以RAW方式查看制定的SEL数据1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0xa 0x43 0 0 111 0 0 0xFF 0xa 0x43为Get SEL Entry Command； 0 0 保留值，111 0 表示取第112条记录（从0开始），0 为offset，保留；0xFF为读取的字节数，FF表示取整条记录 FRU信息查看1. 查看FRU信息1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) fru list SDR，Sensor信息查看1. 查看SDR Sensor信息1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sdr 2. 查看Sensor信息1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sensor list mc状态和控制1. 重启动BMC1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc reset &lt;warm/cold&gt; 设置BMC的iptables防火墙1. 设置某一段IP可以访问BMC1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x01 0x01 ip1(0xa 0xa 0xa 0xa) ip2(0xb 0xb 0xb 0xb) 1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x09 2. 设置某个IP可以访问BMC1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x00 0x01 ip1(0xa 0xa 0xa 0xa) 1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x09 3. 取消设置1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x08 4．获取防火墙设置1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x77 0x01 0x00 5. 阻止/开启某个端口1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x02 0x00/0x01 0x00 (portno)0x22 0x00 6. 取消某个端口的设置（6是5的对应取消操作）1ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x06 0x00/0x01 0x00 (portno)0x22 0x00 附录ipimitool 使用规则：1ipmitool [options...] &lt;command&gt; 参数 参数 描述 -h 帮助 -V 显示版本信息 -v 详细（可以使用多次） -c 以逗号分隔格式显示输出 -d 指定要使用的/ dev / ipmiN设备（默认值= 0） -I 要使用的接口 -H LAN接口的远程主机名 -p 远程RMCP端口[默认= 623] -U 远程会话用户 -f 从文件读取远程会话密码 -z 通信通道（OEM）的尺寸更改大小 -S 使用本地文件进行远程SDR缓存 -D ttyb[:s]指定要使用的串行设备，波特率并且可选地指定该接口是系统接口 -a 提示输入远程密码 -Y 提示用于IPMIv2身份验证的Kg密钥 -e 设置SOL转义字符 -C 加密套件将被lanplus接口使用 -k 使用Kg键进行IPMIv2身份验证 -y 使用十六进制编码的Kg密钥进行IPMIv2身份验证 -L 远程会话权限[默认=管理员] 附加一个’+’以在RAKP1中使用名称/特权查找 -A 强制使用auth type NONE，PASSWORD，MD2，MD5或OEM -P 远程会话密码 -E 从IPMI_PASSWORD环境变量读取密码 -K 从IPMI_KGKEY环境变量中读取kgkey -m 设置本地IPMB地址 -b 通道为桥接请求设置目标通道 -t 将桥接请求发送到远程目标地址 -B 为桥接请求设置传输通道（双桥） -T 设置桥接请求的传输地址（双桥） -l 设置原始命令的目的地lun -o OEM设置（使用’list’查看可用的OEM类型） -O 将文件用于OEM SEL事件描述 -N 指定lan [default = 2] / lanplus [default = 1]接口的超时时间 -R 设置lan / lanplus接口的重试次数[默认= 4] Interfaces 接口 描述 open Linux OpenIPMI Interface [default] imb Intel IMB Interface lan IPMI v1.5 LAN Interface lanplus IPMI v2.0 RMCP+ LAN Interface serial-terminal Serial Interface, Terminal Mode serial-basic Serial Interface, Basic Mode Commands 命令 描述 raw Send a RAW IPMI request and print response i2c Send an I2C Master Write-Read command and print response spd Print SPD info from remote I2C device lan Configure LAN Channels chassis Get chassis status and set power state power Shortcut to chassis power commands event Send pre-defined events to MC mc Management Controller status and global enables sdr Print Sensor Data Repository entries and readings sensor Print detailed sensor information fru Print built-in FRU and scan SDR for FRU locators gendev Read/Write Device associated with Generic Device locators sdr sel Print System Event Log (SEL) pef Configure Platform Event Filtering (PEF) sol Configure and connect IPMIv2.0 Serial-over-LAN tsol Configure and connect with Tyan IPMIv1.5 Serial-over-LAN isol Configure IPMIv1.5 Serial-over-LAN user Configure Management Controller users channel Configure Management Controller channels session Print session information dcmi Data Center Management Interface sunoem OEM Commands for Sun servers kontronoem OEM Commands for Kontron devices picmg Run a PICMG/ATCA extended cmd fwum Update IPMC using Kontron OEM Firmware Update Manager firewall Configure Firmware Firewall delloem OEM Commands for Dell systems exec Run list of commands from file set Set runtime variable for shell and exec hpm Update HPM components using PICMG HPM.1 file ekanalyzer run FRU-Ekeying analyzer using FRU files ime Update Intel Manageability Engine Firmware]]></content>
      <categories>
        <category>BMC Study Notes</category>
      </categories>
      <tags>
        <tag>BMC</tag>
        <tag>IPMI</tag>
        <tag>IPMITOOL</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPMI笔记]]></title>
    <url>%2F2018%2F03%2F12%2FIPMI%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[IPMI是一种协议，也是一种对外的接口的标准 。IPMI协议被广泛用于服务器监控中，包括采集CPU温度、风扇转速、主板温度，以及远程开关机等等。而且IPMI独立于硬件和操作系统，无论是CPU、BIOS，还是OS出现故障，都不会影响IPMI的工作。因为IPMI的硬件设备BMC(Baseboard Management Controller)是一个独立的板卡，独立供电。 IPMI的模式本地本地安装： IPMI驱动（硬件设备被操作系统识别）ipmitool或其他工具（通过驱动获取服务器信息） 远程 只需要在客户端安装ipmitool或其他工具 远程模式下，IPMI使用RMCP，RMCP基于UDP协议实现。 远程监控也就是基于UDP的网络通信。 服务器IPMI使用的端口一般是623。 IPMI的原理IPMI的核心是一个专用芯片/控制器(叫做服务器处理器或基板管理控制器(BMC))，其并不依赖于服务器的处理器、BIOS或操作系统来工作，可谓非常地独立，是一个单独在系统内运行的无代理管理子系统，只要有BMC与IPMI固件其便可开始工作，而BMC通常是一个安装自爱服务器主板上的独立的板卡，现在也有服务器主板提供对IPMI支持的。IPMI良好的自治特性便克服了以往基于操作系统的管理方式所受的限制，例如操作系统不响应或未加载的情况下其仍然可以进行开关机、信息提取等操作。在工作时，所有的IPMI功能都是向BMC发送命令来完成的，命令使用IPMI规范中规定的指令，BMC接收并在系统事件日志中记录事件消息，维护描述系统中传感器情况的传感器数据记录。在需要远程访问系统时，IPMI新的LAN上串行(SOL)特性很有用。SOL改变IPMI会话过程中本地串口传送方向，从而提供对紧急管理服务、Windows专用管理控制台或Linux串行控制台的远程访问。BMC通过在LAN上改变传送给串行端口的信息的方向来做到这点，提供了一种与厂商无关的远程查看启 动、操作系统加载器或紧急管理控制台来诊断和维修故障的标准方式。 IPMI的功能  开机，关机，重启，查看机器当前的通电状态  安装系统。有些服务器的IPMI，没有内置iKVM，无法实现系统的安装。这个估计和成本有关  修改IPMI的网络和IP地址  获取一些硬件监控指标，监控数据，例如风扇转速，电源电压，cpu温度等  修改bios设置，可以通过IPMI进入bios  设置Raid。 IPMI的接口IPMI SYSTEM INTERFACE KCS: KEYBOARD CONTROLLER STYLE 键盘控制 SMIC: SYSTEM MANAGEMENT INTERFACE CHIP 系统管理界面芯片 BT: BLOCK TRANSFER 块传输 SMBUS: SYSTEM INTERFACE 系统接口 OTHER MESSAGING INTERFACE LAN (局域网) SERIAL (串口)/ MODEM(调制解调器) ICMB: INTELLIGENT CHASSIS MANAGEMENT BUS (智能机箱管理总线) PCI MANAGEMENT BUS IPMITOOL关于IPMITOOL指令的相关，请点击这里。 附录KEYWORD]]></content>
      <categories>
        <category>BMC Study Notes</category>
      </categories>
      <tags>
        <tag>BMC</tag>
        <tag>IPMI</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。异常是Python对象，表示一个错误。发生异常时我们需要捕获处理它，否则程序会终止执行。[TOC]异常在python中，按分法，将错误分成语法错误和异常。 错误常见的语法错误有很多，这里将缩进错误单独提出来，是因为太常见，报错也很容易分辨，也很容易犯这个错误。 缩进错误12a=10 print(a) 这里的print缩进错误，导致程序无法运行。1IndentationError: unexpected indent 语法错误12for i in range(10) print(i) 这里的for循环缺少个冒号，造成语法错误，报错如下：1SyntaxError: invalid syntax 异常即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。大多数的异常都不会被程序处理，都以错误信息的形式展现在这里: 1print(1/0) 1ZeroDivisionError: division by zero 异常以不同的类型出现，这些类型都作为信息的一部分打印出来,这里不多举例，常见异常及含义见附录。 异常处理其实异常处理都是套路，将可能发生异常的语句块放进try：，except捕获异常即可，看下面的例子，尝试将一个输入转换为int类型：1234try: x = int(input("Please enter a number: "))except ValueError: print("Oops! That was no valid number. Try again") try语句按照如下方式工作； 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束。 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。 处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。12except (RuntimeError, TypeError, NameError): pass else子句try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。 但是,真的并不推荐！！！ 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。 finally子句不管 try 子句里面有没有发生异常，finally 子句都会执行。 如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。12345678910111213def divide(x, y): try: result = x / y except ZeroDivisionError: print("division by zero!") else: print("result is", result) finally: print("executing finally clause")if __name__ == '__main__': divide(1, 0) 无论是否接住了异常，finally语句依旧执行。12division by zero!executing finally clause 抛出异常使用 raise 语句抛出一个指定的异常。 1raise NameError('名字错了') 附录 -python异常表 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>异常</tag>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BMC测试]]></title>
    <url>%2F2018%2F03%2F10%2FBMC%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[BMC测试的主要内容。 Web：通过浏览器用BMC IP 访问BMC 登录方式：http://xx.xx.xx.xx BMC的IP地址。 查看BMC 的版本等一些基本信息 查看sensor的读值，threshold及状态 查看、删除SEL 设置BMC Network，如IP的获取方式，enable/disable VLAN等。 设置Trap、Email、LDAP等 查看、修改BMC 用户 连接iKVM远程监控 其他设置 IOL: 利用ipmitool或者其他软件通过LAN访问BMC. ipmitool连接方式： 1ipmitool –I lanplus(lan) –H 192.x.x .x -U admin -P admin –L administrator(operator/user) raw &lt;NetFn&gt; &lt;cmd&gt; &lt;data&gt; 可以通过IOL连接对BMC发送命令对BMC进行设置，如设置BMC IP的获取方式，重启BMC，重启/关闭系统等。 SOL: Serial Over Lan SOL 提供了一种机制，使得远程管理系统的串口控制器通过基于IP网络的IPMI会话能够重定向到本地。 串口是修复系统故障和BIOS异常不可或缺的工具。当机器发生故障时，系统管理人员可以通过串口进行BIOS、操作系统和网络的相关配置，修复系统。在以往的情况下,管理人员不得不回到嘈杂的机房,重新接入串口,再进行修复工作。 SOL为管理人员提供了基于IPIP的远程系统串口的访问,只要机房内网络不出现故障，管理人员便可以通过任何一台支持SOL的主机访问发生故障的机器的串口 SOL 被设计为RMCP+协议负载的一种 Serial：通过串口连接BMC 超级终端或者其他软件通过串口与BMC进行连接 可以进入BMC linux通过命令查看、设置BMC的相关内容，如查看SEL，查看网络配置，重启BMC等。 Sensor测试 对每一个sensor创造条件，使其产生对应的事件，查看LED、SEL、Trap、Mail、PEF等。 PEF/Trap/Email测试 创造满足PEF条件的事件，查看BMC是否会根据PEF的设置做出相应的反应，如记录log，重启或者关闭系统，发送alert trap及mail等。 Command测试 验证BMC Spec中定义的command是否可用正确运行并返回正确的值。]]></content>
      <categories>
        <category>BMC Study Notes</category>
      </categories>
      <tags>
        <tag>BMC</tag>
        <tag>IPMI</tag>
        <tag>IPMITOOL</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高阶函数]]></title>
    <url>%2F2018%2F03%2F09%2F%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这篇博文主要介绍下python中特别重要的内置高阶函数filter()，map()，reduce()，以及它们的应用。其中也涉及了一些它们在python2与python3中的不同。 filter()函数filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。注意，在python2.x返回的是列表，在python3中返回为迭代器，有惰性运算的特性, 相对python2提升了性能, 可以节约内存。 语法1filter(function, iterable) 该函数接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素保留。 参数 function – 判断函数。 iterable – 可迭代对象。 返回值返回迭代器。 应用1234567def is_odd(n): return n % 2 == 1new = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])print(new)print(new.__next__())print(list(new)) # 列表化 1231&lt;filter object at 0x04EA22F0&gt;[3, 5, 7, 9] 上面的例子很好的看出，filter函数将偶数过滤掉，返回了一个迭代器类型。 map()函数map() 会根据提供的函数对指定序列做映射。 语法第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。1map(function, iterable, ...) 参数 function 函数，有两个参数 iterable 一个或多个序列 返回值 Python 2.x 返回列表。 Python 3.x 返回迭代器。 应用先定义一个函数，用来计算平方数12def square(x): # 计算平方数 return x ** 2 使用map函数计算一个列表的每个元素的平方数，并返回对应迭代器。123m1=map(square, [1, 2, 3, 4, 5])print(m1)print(m1.__next__()) 12&lt;map object at 0x051922F0&gt;1 使用 lambda 匿名函数，实现上面的功能。123m2=map(lambda x: x ** 2, [1, 2, 3, 4, 5])print(m2)print(m2.__next__()) 12&lt;map object at 0x05209490&gt;1 提供了两个列表，对相同位置的列表数据进行相加12m3=map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])print(list(m3)) 1[3, 7, 11, 15, 19] 如果，两个列表长度不同，则返回长度为短的那个。 reduce()函数reduce() 函数会对参数序列中元素进行累积。 函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给reduce中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。 在python3中不在内置，不可以直接调用，需要先进行导入。 导入1from functools import reduce 语法1reduce(function, iterable[, initializer]) 参数 function – 函数，有两个参数 iterable – 可迭代对象 initializer – 可选，初始参数 应用123先定义个函数def add(x, y): # 两数相加 return x + y 调用reduce计算累加和1234reduce(add, [1,2,3,4,5]) # 计算列表和：1+2+3+4+5&gt;&gt;&gt;15 使用 lambda 匿名函数，计算累乘1reduce(lambda x, y: x*y, [1,2,3,4,5])]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>map</tag>
        <tag>filter</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在Python中，lambda作为一个关键字，作为引入表达式的语法。想比较def函数，lambda是单一的表达式，而不是语句块.[TOC] 匿名函数的特点所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 匿名函数的语法lambda 函数的语法只包含一个语句，如下：123lambda [arg1 [,arg2,.....argn]]:expression# lambda 参数列表：return [表达式] 变量# 由于lambda返回的是函数对象（构建的是一个函数对象），所以需要定义一个变量去接收 匿名函数的优点 使用Python写一些脚本时，使用lambda可以省去定义函数的过程，让代码更加精简。 对于一些抽象的，不会被别的地方再重复使用的函数，有时候函数起个名字也是个难题，使用lambda不需要考虑命名的问题 使用lambda在某些时候然后代码更容易理解 匿名函数的应用定义简单函数1234# sum加法函数sum = lambda arg1, arg2: arg1 + arg2# 调用sum函数print("结果为 : %0.1f" %sum(10, 20)) 1结果为 : 30.0 排序中的应用123456789infors = [&#123;"name":"宋长武","age":23&#125;,&#123;"name":"刘洋","age":22&#125;, &#123;"name":"施名阳","age":24&#125;,&#123;"name":"马云伟","age":23&#125;]# 使用匿名函数,根据age对字典排序infors.sort(key=lambda x:x['age'])print(infors) # 或者使用sorted函数# infors_new=sorted(infors,key=lambda x:x['age'])# print(infors_new) 1[&#123;'name': '刘洋', 'age': 22&#125;, &#123;'name': '宋长武', 'age': 23&#125;, &#123;'name': '马云伟', 'age': 23&#125;, &#123;'name': '施名阳', 'age': 24&#125;] 函数当作变量123456def test(a,b,func): result = func(a,b) return result# 调用num = test(11,22,lambda x,y:x+y)print('结果为:%.1f'%num) 1结果为 : 33.0]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>匿名函数</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器本质上是可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用.[TOC] 装饰器的写法比如说，我们有两个函数，它们分别实现了一个功能,但是其中一个模块的函数出了问题,需要为每个函数添加debug信息,方便找到问题,下方是两个函数:12def say_hello(): print("hello") 12def say_world(): print("world") 以及想要实现的效果:1234[DEBUG]: enter say_hello()hello[DEBUG]: enter say_world()world 那么,你可能会想,不就是在每个函数加入个print的事嘛,但是我的老哥们,这仅仅是两个函数,这要是几百个函数,那岂不是得累死,所以我们不能这么干. 这时候我们的装饰器就闪亮登场了.先来看下代码.12345def debug(func): def wrapper(*args, **kwargs): print("[DEBUG]: enter &#123;&#125;()".format(func.__name__)) return func() return wrapper 我们来看下这个装饰器函数,他的执行过程是什么样的呢 首先,它接受的参数是个函数 然后将接受的函数进行包装,即,为其添加了一些新的功能特性 最后返回了一个新的包装好的函数 最后执行这个函数 好的,装饰器的执行过程我们知道了,那么我们如何调用这个装饰器为我们服务呢?很简单,直接使用python的@语法糖就可以调用了,我们看下面的例子.123@debugdef say_hello(): print("hello") 看看这样的实现过程,是不是很简单,很实用,而且很优雅. 带参数装饰器有小伙伴就可能要问了,我们debug完成了,难道我们还让他是输出debug字样的log嘛?是不是很不好(low)啊,这时候有的同学就要说了,很简单啊,在重新写个装饰器不就好了,可以是可以,但是改来改去的,你不会觉得很麻烦嘛?这是我们想到了给装饰器加个参数,如果正常运行的时候就让他显示[执行]xxx,调试的时候我们就让他显示[debug]xxx,这样是不是就舒服多了.123456789def logging(level): def wrapper(func): def inner_wrapper(*args, **kwargs): print ("[&#123;level&#125;]: enter function &#123;func&#125;()".format( level=level, func=func.__name__)) return func(*args, **kwargs) return inner_wrapper return wrapper 这样我们就定义好了一个带参数的装饰器,其实也就是加了一层嵌套,传了一个参数进去.这样我们只要指定level的值就可以了,完全不用再写一个参数,也更方便后期维护.123@logging(level='执行')def say_hello(): print("hello") 类装饰器前面讲的都是基于函数去实现一个装饰器,下面讲讲如何通过类来实现装饰器。回到装饰器上的概念上来，装饰器要求接受一个callable对象，并返回一个callable对象。那么用类来实现也是也可以的。我们可以让类的构造函数__init__()接受一个函数，然后重载__call__()并返回一个函数，也可以达到装饰器函数的效果。123456789101112class logging1(object): def __init__(self, level='默认'): self.level = level def __call__(self, func): # 接受函数 def wrapper(*args, **kwargs): print("[&#123;level&#125;]: enter function &#123;func&#125;()".format( level=self.level, func=func.__name__)) func(*args, **kwargs) return wrapper # 返回函数 调用还是使用@语法糖,这里就不多赘述了. 装饰器嵌套有的时候。我们并不是在原有的基础上增加一个功能，而是几个功能。那可不可以使用几个装饰器呢？Python告诉你，它是可以的。12345@A@B@Cdef xxx(...): ... 这样就可以实现装饰器的嵌套。实际上他的执行过程是这样的,先执行接近函数的那一个：1f = A(B(C(f))) # first C, seconds B, third A 内置装饰器内置的装饰器和普通的装饰器原理是一样的，只不过返回的不是函数，而是类对象,在Python中有三个内置的装饰器，都是跟class相关的：staticmethod、classmethod 和property。 staticmethod 是类静态方法，其跟成员方法的区别是没有 self 参数，并且可以在类不进行实例化的情况下调用 classmethod 与成员方法的区别在于所接收的第一个参数不是 self （类实例的指针），而是cls（当前类的具体类型） property 是属性的意思，表示可以通过通过类实例直接访问的信息 @propertyPython内置的@property装饰器是负责把一个方法变成属性调用的,这里其实查了很多资料但没有很好的讲解，我就查看了函数的内部，发现了里面给讲解了这个装饰器的使用，而且很形象。123456789101112class C(object): @property def x(self): return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x @property、x.setter x.deleter实现了属性的读取、赋值、和删除。上实例，便于理解,这里以一个学生的成绩修改进行操作。12345678910111213class Stu(object): @property def score(self): return self._score @score.setter def score(self, value): self._score = value @score.deleter def score(self): del self._score 12345678910if __name__ == '__main__': stu = Stu() #实例化 stu.score = 60 #赋值 print(stu.score) del stu.score #删除 print(stu.score) &gt;&gt;&gt;60AttributeError: 'Stu' object has no attribute '_score' @classmethod类方法,按照我的理解就是,可以在类的内部定义函数,并且将这个函数的返回值作为参数,传给这个类。听起来好像有点拗口，下面我们来看个实例：1234567891011121314151617181920212223242526class Date_test(object): day, month, year = 0, 0, 0 def __init__(self, year=0, month=0, day=0): self.day = day self.month = month self.year = year @classmethod def get_date(cls, string_date): # 这里第一个参数是cls， 表示调用当前的类名 year, month, day = map(int, string_date.split(&apos;-&apos;)) date1 = cls(year, month, day) # 返回的是一个初始化后的类 return date1 def out_date(self): print(&quot;日期: %4d年 %2d月 %2d日&quot; %(self.year, self.month, self.day))if __name__ == &apos;__main__&apos;: date = Date_test(2012, 6, 6) date.out_date() date1 = Data_test.get_date(&apos;2013-12-1&apos;) date1.out_date() 12日期: 2012年 6月 6日日期: 2013年 12月 1日 上面代码中的date1,就是将时间戳转换成该类可接受的参数,再重新调用这个class. @staticmethod静态方法，该方法不强制要求传递参数，也不需要实例化，可以直接调用。12345678class Foo: @staticmethod # 静态方法 def spam(x,y,z): print(x,y,z)if __name__ == '__main__': Foo.spam(1,2,3) 当然也可以实例化调用，这里就不演示了。 应用场景:编写类时需要采用很多不同的方式来创建实例，而我们只有一个__init__函数，此时静态方法就派上用场了. 1234567891011121314151617181920212223class Date: def __init__(self, year, month, day): self.year = year self.month = month self.day = day @staticmethod def now(): # 用Date.now()的形式去产生实例,该实例用的是当前时间 t = time.localtime() # 获取结构化的时间格式 return Date(t.tm_year, t.tm_mon, t.tm_mday) # 新建实例并且返回 @staticmethod def tomorrow(): # 用Date.tomorrow()的形式去产生实例,该实例用的是明天的时间 t = time.localtime(time.time() + 86400) return Date(t.tm_year, t.tm_mon, t.tm_mday) if __name__ == '__main__': a = Date('1987', 11, 27) # 自己定义时间 b = Date.now() # 采用当前时间 c = Date.tomorrow() # 采用明天的时间 print(a.year, a.month, a.day) print(b.year, b.month, b.day) print(c.year, c.month, c.day) 1231987 11 272018 3 92018 3 10]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器]]></title>
    <url>%2F2018%2F03%2F07%2F%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果，在每个结果之间挂起和继续它们的状态，来自动实现迭代协议。也就是说，yield是一个语法糖，内部实现支持了迭代器协议，同时yield内部是一个状态机，维护着挂起和继续的状态。[TOC] 简单使用我们先定义了一个生成器函数，函数返回一个生成器对象，然后就可以通过for语句或者next()进行迭代访问.这里我们直接让迭代器列表化打印.1234567891011121314def Lrange(n): i = 0 while i &lt; n : yield i i += 1lrange=Lrange(3)list_l = list(lrange)print(lrange)print(list_l)&gt;&gt;&gt;&lt;generator object Lrange at 0x0EAA3D80&gt;[0, 1, 2] 其实，生成器函数返回生成器的迭代器。 “生成器的迭代器”这个术语通常被称作”生成器”。要注意的是生成器就是一类特殊的迭代器。作为一个迭代器，生成器必须要定义一些方法，其中一个就是next()。如同迭代器一样，我们可以使用next()函数来获取下一个值。 执行过程 当调用生成器函数的时候，函数只是返回了一个生成器对象，并没有 执行。 当next()方法第一次被调用的时候，生成器函数才开始执行，执行到yield语句处停止 next()方法的返回值就是yield语句处的参数（yielded value） 当继续调用next()方法的时候，函数将接着上一次停止的yield语句处继续执行，并到下一个yield处停止；如果后面没有yield就抛出StopIteration异常 生成器推导式说到推导式,你可能首先会想到列表推导式,其实两者还是真的很相似.举个栗子,哈哈现在的需求是:我们要生成1到20的奇数一个列表.1[i for i in range(1,20) if i%2] 那么将这个列表元素不直接都存到列表里,而是以迭代器的方式,每次取一个.这样就是生成器了,是不是还是蛮好理解的.那么怎么将这个列表推导式改成生成器推导式呢?很简单,把方括号改成小括号就可以了,这时候我们返回的就不是一个列表,而是一个迭代器.123456789ge = (i for i in range(1,20) if i%2)ge2=[i for i in range(1,20) if i%2]print(ge)print(ge.__next__())print(ge2)&gt;&gt;&gt;&lt;generator object &lt;genexpr&gt; at 0x0E053D80&gt;1[1, 3, 5, 7, 9, 11, 13, 15, 17, 19] 这样的对比是不是直观多了. 那生成器是不是完全就是迭代器,当然不是,他还有其他的方法, send()方法Python 2.5中，yield语句变成了yield表达式，也就是说yield可以有一个值，而这个值就是send()方法的参数，所以send(None)和next()是等效的。同样，next()和send()的返回值都是yield语句处的参数（yielded value） 关于send()方法需要注意的是： 调用send传入非None值前，生成器必须处于挂起状态，否则将抛出异常。也就是说，第一次调用时，要用next()语句或send(None)，因为没有yield语句来接收这个值。 close()方法这个方法用于关闭生成器，对关闭的生成器后再次调用next或send将抛出StopIteration异常。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器]]></title>
    <url>%2F2018%2F03%2F07%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器指能够被内置函数 next调用并不断返回下一个值，直到最后抛出 StopIteration错误表示无法继续返回下一个值的对象称为迭代器( Iterator)。这里主要讲一下迭代器的特性，和如何简单的实现一个迭代器。 迭代器类型[TOC] 其实在 python中，没有内置迭代器类型的对象，但是可以通过内置函数 iter()将 str、 tuple、 list、 dict、 set等类型转换成一个迭代器类型。 简单的说，就是列表，字符串，元祖并不是迭代器类型，但可以转换成迭代器类型。 我们来看下代码。可能会更好理解。12345678910&gt;&gt;&gt; s = [1,2,3]&gt;&gt;&gt; next(s)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'list' object is not an iterator&gt;&gt;&gt; n="abc"&gt;&gt;&gt; next(n)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'str' object is not an iterator 从上面的报错可以很好地看出str和list并不是一个iterator,即迭代器.我们尝试使用iter()函数去将其转换成iterator12345&gt;&gt;&gt; it_n = iter(n)&gt;&gt;&gt; next(it_n)'a'&gt;&gt;&gt; next(it_n)'b' 很明显现在的字符串已经是一个迭代器对象了,我们使用type()函数来验证下我们的猜想.1234&gt;&gt;&gt; type(it_n)&lt;class 'str_iterator'&gt;&gt;&gt;&gt; type(n)&lt;class 'str'&gt; 很好,python已经很明确的告诉我们它已经是个str_iterator了已经弄懂了什么是迭代器,那么我们是否自己写一个迭代器呢? 实现一个迭代器思路: 定义一个类,用来表示我们的迭代器 定义初始化函数,初始化当前值,和最大迭代的次数 定义next()方法,用来实现迭代,如果没到最大迭代数就将当前次数加一,达到最大次数则抛出StopIteration停止迭代. 实例化我们的迭代器 123456789101112class My_iterator(): def __init__(self,max_value): self.current_value = 0 self.max_value= max_value def __next__(self): if self.current_value &lt; self.max_value: result = self.current_value self.current_value +=1 return result else: raise StopIteration 下面我们实例化我们的迭代器,来验证下是否成功实现了. 1234567if __name__ == '__main__': my_iter = My_iterator(3) print(next(my_iter)) print(next(my_iter)) print(next(my_iter)) print(next(my_iter)) print(next(my_iter)) 运行我们的代码python K:/hexo/source/_posts/迭代器.py123012 看起来好像已经实现了我们的效果,我们尝试使用list()函数将其封装到一个列表里l = list(my_iter)然后可怕的事情发生了,解释器抛出了一个异常1TypeError: 'My_iterator' object is not iterable 它说我们所写的并不是iterable,这我也一脸懵逼啊不过可以看出仅仅实现 next()方法的对象还不是迭代器，真正的迭代器还需要实现一个可迭代接口 Iterable。 通过查找资料: 迭代器类型 Iterator继承自可迭代类型 Iterable，可迭代 Iterable继承自 object基类，迭代器 Iterator类型包含 iter()和 next()方法，而可迭代类型 Iteratble仅仅包含 iter()。可迭代对象，通过 iter()返回一个迭代器对象，迭代器对象的 next()方法则实际用于被循环。 所以,我们只需要在我们类里再定义一个iter(),用来返回迭代器对象即可 12def __iter__(self): return self 导入模块检验下我们现在的my_iter是不是已经是迭代器类型1from collections import Iterator,Iterable 调用isinstance()函数进行比较,如果跟返回True,说明已经是一个迭代器类型12print(isinstance(my_iter,Iterator))print(isinstance(my_iter,Iterable)) 12TrueTrue 好了,我们已经完成了一个很基本的迭代器了. 总结笔记 凡是可作用于 for语句循环的对象都是 Iterable可迭代类型。 凡是可作用于 next()函数的对象都是 Iterator迭代器类型。 str、 tuple、 list、 dict、 set等类型是Iterable可迭代类型，但不是 Iterator迭代器；通过 Iterable可迭代类型的 iter()方法可以获得一个Iterator迭代器对象，从而使得它们可以被for语句循环。 Python的for循环本质上就是通过调用Iterable可迭代对象的 iter()方法获得一个 Iterator迭代器对象,然后不断调用 Iterator迭代器对象 next()方法实现的。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown没告诉你的]]></title>
    <url>%2F2018%2F03%2F06%2Fmarkdown%E6%B2%A1%E5%91%8A%E8%AF%89%E4%BD%A0%E7%9A%84%2F</url>
    <content type="text"><![CDATA[刚接触markdown，一下就被它的美和大气所吸引，最基本的这里就不多介绍，网上一抓一大把。这里主要记录下在使用markdown过程中遇到的问题和总结的一些小技巧，将其记录下来作为以后的一个参考。这篇文章将会持续更新，将每次碰到的问题都更新在这里。[TOC] 遇到的那些坑由于刚接触，这里总结下在使用markdown的时候出现的一些问题。 两个就近代码块“粘”在一起1# 代码1 1# 代码2 下面是在马克飞象上预览–完全ok!!!可当你发到博客上一看,傻眼了,粘在一起了.造成这种现象的原因可能就是你看不见的空格,很多人都会不自觉的敲上几个空格.下面划重点:在一个代码块结束的`后面不能有空格，直接换行 使用列表后内容不跟随缩进这样就会感觉很别扭，一点也不美观。其实原因就是列表与下面的内容（代码，注释，，，等）不要留有空行，不然解释器就会以为他们的不是一体的 转义问题在markdown语法中很多字符是含有特殊意义的，那我们要是想要在文章中看到这些字符怎么办呢？其实markdown是支持html语法的，所以我们就可以直接使用html里转义字符的方法。当碰到这些字符的时候，使用其转义字符即可。 没说的小技巧文字居中/左/右居中： &lt;center&gt;居中&lt;/center&gt; 左对齐： &lt;p align=”left”&gt;居左&lt;/p&gt; 右对齐： &lt;p align=”right”&gt;居右&lt;/p&gt; 空行 &lt;br&gt; 删除线在想要添加删除的内容始末两端分别加上~~ 效果：可恶，我被删掉了 反引号的使用在markdown里的&lt;br/&gt;是无法显示的 这时候在两端加上反引号就可以让其显示在你文本中 附录–马克飞象上的语法表]]></content>
      <categories>
        <category>Markdown Study Notes</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib绘图]]></title>
    <url>%2F2018%2F03%2F05%2Fmatplotlib%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍下如何使用matplotlib进行数据可视化绘图,解决了不能显示中文的问题.绘制了气泡散点图,七彩散点图,堆叠条形图,倒影条形图,水平条形图等.[TOC] 导入我先导入所需要的库:1234import matplotlibimport matplotlib.pyplot as pltimport numpy as npimport random 解决中文显示 先指定字体 2. 使用中文时,加上fontproperties=font参数12# 指定要使用的字体,防止出现中文乱码font=matplotlib.font_manager.FontProperties(fname=r"C:\Windows\Fonts\Deng.ttf") 散点图使用plt.scater()绘制散点图 七彩散点图 导入所需的库 所有的都需要导入上面的库,后面不在赘述 拿到所需要的x轴,y轴数据,我们这里选择直接生成,你可以把需要的数据添加进去. 1234# 输入横坐标x序列x=np.array([x for x in range(1,21)])# 输入y序列,或者y与x的关系y=x**2 之后我们生成一个颜色的列表 1colors=['red','green','gray','purple','yellow','orange','blue'] 然后调用随机数模块,进行随机抽取 1random_colors=random.sample(colors,7) 调用plt进行绘图,c=用来规定颜色,s=用来控制每个点的大小 123plt.scatter(x,y,s=100,c=random_colors,alpha=0.8)#- 最后我们来显示所画的图 plt.show() 气泡散点图 导入所需的库 所有的都需要导入上面的库,后面不在赘述 拿到所需要的x轴,y轴数据,我们这里选择直接生成,你可以把需要的数据添加进去. 12345N=80# 随机获取x&lt;1的数字八十个x=np.random.rand(N)# 随机获取y&lt;1的数字八十个y=np.random.rand(N) 同样我们生成一个颜色的列表 1colors=['red','green','gray','purple','yellow','orange','blue'] 然后调用随机数模块,进行随机抽取 12# 随机排列颜色random_colors=random.sample(colors,7) 然后这里我们加入一个随机生成点的大小 1area=np.pi * (np.random.rand(N)*10)**2 调用进行绘图,c=用来规定颜色,s=用来控制每个点的大小 1plt.scatter(x,y,c=random_colors,s=area) 最后我们来显示所画的图 1plt.show() 条形图使用plt.bar()进行条形图绘制 双层条形图 先生成一个画布 1fig=plt.figure() 生成数据,将两个x数据间隔开,宽度等于差值 1234x1=[x-0.2 for x in range(1,9)]y1=[n*2 for n in range(1,9)]x2=[x+0.2 for x in range(1,9)]y2=[x**2 for x in x2] 开始画条形图1 1l1=plt.bar(x1,y1,color='g',width=0.4) 开始画条形图2,使宽度等于x1,x2的差值 1l2=plt.bar(x2,y2,color='b',width=0.4) 添加x,y轴,和头部信息 123plt.xlabel('x轴信息',fontproperties=font)plt.ylabel('y轴信息',fontproperties=font)plt.title('双层条形图',fontproperties=font) 给图像加上注解信息 1plt.legend(handles = [l1, l2,], labels = ['去年', '今年'], loc = 'best',prop=font) 添加每个条形图的数据 123for x1,x2, y1, y2 in zip(x1,x2, y1, y2): plt.text(x1 , y1, '%.0f' % y1, ha='center', va='bottom') plt.text(x2 , y2, '%.0f' % y2, ha='center', va='bottom') 看看最终的效果图,是不是看起来很炫酷,当然后面的更炫酷. 1plt.show() 堆叠条形图 先生成一个画布 1fig=plt.figure() 生成数据 1234x1=[x for x in range(1,9)]y1=[n*2 for n in range(1,9)]x2=[x for x in range(1,9)]y2=[x**2 for x in x2] 开始画条形图2,先画数值大的,数值小的直接在原图覆盖 1l2=plt.bar(x2,y2,color='b',width=0.4) 开始画条形图1 1l1=plt.bar(x1,y1,color='g',width=0.4) 设置x标签 1plt.xlabel(u'x轴',fontproperties=font) 设置y轴标签 1plt.ylabel('y轴',fontproperties=font) 设置标题 1plt.title(u'堆叠柱状图',fontproperties=font) 设置注解狂 1plt.legend(handles = [l1, l2,], labels = ['去年', '今年'], loc = 'best',prop=font) 把确切数字显示出来 123for x1,x2, y1, y2 in zip(x1,x2, y1, y2): plt.text(x1 , y1, '%.0f' % y1, ha='center', va='bottom') plt.text(x2 , y2, '%.0f' % y2, ha='center') 显示 1plt.show() 看效果图 倒影条形图 先生成一个画布 1fig=plt.figure() 生成数据 123x1=[x-0.2 for x in range(1,9)]y1=[n*2 for n in range(1,9)]y2=[-x for x in y1] 画水平直方图 12l1=plt.bar(x1,y1,color='g')l2=plt.bar(x1,y2,color='b') 设置 1plt.title("倒影直方图",fontproperties=font) 设置x，y轴标签 12plt.xlabel('数量',fontproperties=font)plt.ylabel('产品',fontproperties=font) 设置刻度 12345plt.yticks([x for x in range(-18,21,4)])plt.xticks([y for y in range(0,9,1)])for x1, y1 in zip(x1, y1): # 添加文本时可添加偏移量使其显示更加美观 plt.text(x1, y1, '%.0f' % y1, ha='center', va='bottom') 显示 1plt.show() 水平条形图 先生成一个画布 1fig = plt.figure() 生成数据 1234x1 = [x for x in range(1, 9)]y1 = [n * 2 for n in range(1, 9)]x2 = [x for x in range(1, 9)]y2 = [x ** 2 for x in x2] 画水平条形图 12l2=plt.barh(x2,y2,color='b')l1=plt.barh(x1,y1,color='g') 设置头 1plt.title("水平条形图",fontproperties=font) 设置x，y轴标签 12plt.xlabel('数量',fontproperties=font)plt.ylabel('产品',fontproperties=font) 设置刻度 12plt.xticks([x for x in range(0,80,4)])plt.yticks([y for y in range(0,9,1)]) 设置注解图示 12345plt.legend(handles = [l1, l2,], labels = ['去年', '今年'], loc = 'best',prop=font)for x1,x2, y1, y2 in zip(x1,x2, y1, y2): # 添加文本时添加偏移量使其显示更加美观 plt.text(y1+1.5 , x1-0.25, '%.0f' % y1, ha='center', va='bottom') plt.text(y2+1.5 , x2-0.25, '%.0f' % y2, ha='center', va='bottom') 显示 1plt.show() 12 12]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F03%2F01%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。本文简单讲述了re模块的六大匹配方法和一些匹配模式。[TOC] 导入1import re 语法 有一点要注意Python的字符串本身也用’\’转义，所以要特别注意,一般我们都建议使用Python的r前缀，就不用考虑转义的问题了。 匹配位置的元字符 符号 符号 在正则中的含义 ^ 脱字符 匹配一行开头的字符 $ 美元符 匹配一行结束的位置 \b 单词分界 匹配单词的边界 匹配单个字符的元字符 符号 符号 在正则中的含义 . 点号 匹配单个任意字符 […] 字符组 匹配里面列出来的字符 [^…] 排除字符组 匹配非其中列出的字符 提供计数功能的元字符 符号 符号 在正则中的含义 ? 问号 可以匹配一次,但不必须匹配 * 星号 可以匹配任意次,但不必须匹配 + 加号 至少匹配一次,最多可以匹配任意次 {min,max} 区间 至少匹配min次,最多可匹配max次 模式更加详尽的模式请参考附录 匹配行的开头先说一个简单的例子：匹配以cat开头的1patt=re.compile(r'^cat') 表示匹配以c作为一行的第一个字符，后面跟着a,后面跟着t所以’vocative’就不会被匹配到，原因是因为cat在字符的里面 匹配行的结尾如何我们要是以某一个字符串结尾的,比如我们要查邮件是以BR或者Bestregards结尾的,如何匹配：我们用美元符号$来处理123456789101112import resentence='''Hi Jack:\n Python is a beautiful language\n BR'''patt=re.compile(r'(BR|Bestregards)$')m=re.search(patt,sentence)if m : print ('match')else: print ('not match')&gt;&gt;&gt;match 匹配单词的边界前面介绍了匹配行的开头和结尾，那么如何匹配单词的边界呢,正则里面有2个特殊字符\b and \B来匹配单词的边界 :\b 匹配的模式是一个单词的边界(不论这个单词的前面是有字符还是没有字符)\B 匹配出现在一个单词中间的模式例如:1234the #匹配包含有'the'的字符串\bthe #匹配任何以'the'开始的字符串\bthe\b #仅仅匹配单词'the'\Bthe #匹配任意包含'the'但不以'the'开头的单词 匹配字符组比如我们需要匹配’grey’或者’gray’的时候，怎么办,可以用正则的[]来表示,gr[ea]y,表示先找到g,然后找到r,然后找到e或者a,最后是一个y12345678910import reword='grey'patt=re.compile(r'gr[ea]y')m=re.match(patt,word)if m : print ('match')else: print ('not match')&gt;&gt;&gt;match 匹配中的多选模式我们可以用’|’来匹配任意子表达式,‘|’是一个非常简便的元字符,它的意思是”或”，通过它我们能把不同的子表达式组合成一个总的表达式,比如’am’|’pm’就是能够同时匹配其中任意一个的正则表达式,回头再看上面的例子’gr[ea]y’,其实能写成’grey|gray’,或者’gr(e|a)y’ 匹配中的可选匹配(非必需匹配)比如6月4号，这个6月可能写成’June’也可以写成’Jun’,而且日期也有可能写作’fourth’或者’4th’或者4,我们可以写成(June|Jun)(fourth|4th|4),但是有没有其他办法呢,可以用问号?表示可选项我们分步来处理:第一部分:(June|Jun)改为(June?),什么意思呢意思是说’?’出现在一个e后面，表示e是可选的第二部分:(fourth|4th|4)改为(fourth|4(th)?),什么意思呢意思是说’?’出现在一个括号后面,表示这个括号内的内容是可选的 最后这个复杂的(June|Jun)(fourth|4th|4)就可以变成了June?(fourth|4(th)?) 匹配重复出现的字符重复出现用+和*表示,但是二者有一些小的区别 加号(+)表示:前面紧邻的元素出现一次或者多次，也就是至少出现一次 星号(*)表示:前面紧邻的元素出现任意多次，或者不出现. 即:a*表示0个或者多个a,所以为0的时候，就是空字符 a+表示1个或者多个a,所以a至少要有1次 匹配重复出现n次的内容 比如我们想匹配前面的内容重复出现的次数，比如3次,或者是一个区间,比如1-3次,如何匹配: 12345678import renum_str='123aa45'patt=re.compile(r'([1-9]&#123;3&#125;)')m=re.match(patt,num_str)if m: print (m.group())&gt;&gt;&gt;123 为重复匹配次数设定一个区间 比如美国股票的代码，都是字符有大写的也有小写，基本都是在1到5个字母，如何用正则表达呢? [a-zA-Z]{1,5},就可以来匹配美国股票代码(1到5个字母) 匹配中去除不想匹配的字符比如我们想匹配除了1到6以外的任何字符串,怎么办，简单用[^1-6],这个字符组中开头的^表示”排除的意思”.有同学会说，你刚才不是说^表示开头吗，怎么现在变成排除型了? 下面就是我要解释的,正则的复杂性: 当^在字符组的外面的时候”表示一个行的开头” 当^在字符组的内部(而且是必须紧接着字符组的第一个方括号之后)，它就是一个元字符，表示排除型 例子:找出字母g后面的字母不是u的1234567891011import rewords=['gold','Google','Sogu','Guess']patt=re.compile(r'.*g[^u]')for w in words: m=re.match(patt,w) if m: print (w)&gt;&gt;&gt;goldGoogle 函数re.match方法re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回None 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 re.match例子1234567891011121314import reline = "Cats are smarter than dogs"matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)if matchObj: print ("matchObj.group() : ", matchObj.group()) print ("matchObj.group(1) : ", matchObj.group(1)) print ("matchObj.group(2) : ", matchObj.group(2))else: print ("No match!!")&gt;&gt;&gt;matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter re.search方法re.search 扫描整个字符串并返回第一个成功的匹配。 re.search(pattern, string, flags=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 匹配成功re.search方法返回一个匹配的对象，否则返回None。同样，可以用group()来获得结果. 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 re.search例子12345678910111213import reline = "Cats are smarter than dogs";searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)if searchObj: print "searchObj.group() : ", searchObj.group() print "searchObj.group(1) : ", searchObj.group(1) print "searchObj.group(2) : ", searchObj.group(2)else: print "Nothing found!!"&gt;&gt;&gt;searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter re.match和re.search的区别 match在只能str开头寻找,不匹配则返回None search则在str任意位置寻找re.sub方法Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。1re.sub(pattern, repl, string, count=0, flags=0) 参数 描述 pattern 正则中的模式字符串 repl 替换的字符串，也可为一个函数 string 要被查找替换的原始字符串 count 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配 re.sub例子1234567891011import rephone = "2004-959-559 # 这是一个国外电话号码" # 删除字符串中的 Python注释 num = re.sub(r'#.*$', "", phone)print ("电话号码是: ", num)# 删除非数字(-)的字符串 num = re.sub(r'\D', "", phone)print ("电话号码是 : ", num)&gt;&gt;&gt;电话号码是: 2004-959-559 电话号码是 : 2004959559 repl 参数是一个函数时以下实例中将字符串中的匹配的数字乘于 2：12345678910import re# 将匹配的数字乘于 2def double(matched): value = int(matched.group('value')) return str(value * 2)s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\d+)', double, s))&gt;&gt;&gt;A46G8HFD1134 re.compile方法ompile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： re.compile(pattern[, flags]) 参数 描述 pattern 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等 re.compile例子12345678910import repattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写m = pattern.match('Hello World Wide Web')&gt;&gt;&gt; m.group(1) # 返回第一个分组匹配成功的子串'Hello'&gt;&gt;&gt; m.span(1) # 返回第一个分组匹配成功的子串的索引(0, 5)&gt;&gt;&gt; m.groups() # 等价于 (m.group(1), m.group(2), ...)('Hello', 'World') re.finditer方法在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 re.finditer例子123456789import reit = re.finditer(r"\d+","12a32bc43jf3") for match in it: print (match.group() )&gt;&gt;&gt;12 32 43 3 re.split方法re.split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： re.split(pattern, string[, maxsplit=0, flags=0]) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 re.split例子12345&gt;&gt;&gt; re.split('\W+', ' runoob, runoob, runoob.', 1) #\W 匹配非字母数字及下划线,匹配一次['', 'runoob, runoob, runoob.'] &gt;&gt;&gt; re.split('a*', 'hello world') # 对于一个找不到匹配的字符串而言，split 不会对其作出分割['hello world'] 附录正则修饰符正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志flags修饰符: 参数 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则模式详表 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 匹配n个前面表达式。。例如，”o{2}”不能匹配”Bob”中的”o”，但是能匹配”food”中的两个o。 re{ n,} 精确匹配n个前面表达式。例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \w 匹配字母数字及下划线 \W 匹配非字母数字及下划线 \s 匹配任意空白字符，等价于 [\t\n\r\f]. \S 匹配任意非空字符 \d 匹配任意数字，等价于 [0-9]. \D 匹配任意非数字 \A 匹配字符串开始 \Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \z 匹配字符串结束 \G 匹配最后匹配完成的位置。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \n, \t, 匹配一个换行符。匹配一个制表符。等 \1…\9 匹配第n个分组的内容。 \10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 常用匹配字符类 实例 描述 [Pp]ython 匹配 “Python” 或 “python” rub[ye] 匹配 “ruby” 或 “rube” [aeiou] 匹配中括号内的任意一个字母 [0-9] 匹配任何数字。类似于 [0123456789] [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 [a-zA-Z0-9] 匹配任何字母及数字 [^aeiou] 除了aeiou字母以外的所有字符 [^0-9] 匹配除了数字外的字符 特殊字符类 实例 描述 . 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。 声明本文中的部分例子来自菜鸟教程。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这是我搭建博客的第一篇文章，很多的功能都是通过这篇文章进行测试，本想搭建完成就将其删除，仔细斟酌之后还是选择将其保留，仅当作留念。 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
</search>
