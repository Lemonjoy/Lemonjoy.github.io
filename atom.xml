<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Liu&#39;s Tech Blog</title>
  
  <subtitle>Python技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuyang0001.github.io/"/>
  <updated>2020-02-05T14:17:27.122Z</updated>
  <id>https://liuyang0001.github.io/</id>
  
  <author>
    <name>Liu Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>42-接雨水</title>
    <link href="https://liuyang0001.github.io/2020/02/05/42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://liuyang0001.github.io/2020/02/05/42-接雨水/</id>
    <published>2020-02-05T14:08:49.000Z</published>
    <updated>2020-02-05T14:17:27.122Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><a id="more"></a><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt=""></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>核心思路：使用双指针从两侧遍历,与当前的最大左右值相比，判断当前格子装了多少水。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: [int])</span> -&gt; int:</span></span><br><span class="line">        size = len(height)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">3</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, size - <span class="number">1</span></span><br><span class="line">        left_max, right_max = height[left], height[right]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt;= height[right]:</span><br><span class="line">                <span class="keyword">if</span> height[left] &gt; left_max:</span><br><span class="line">                    left_max = height[left]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += left_max - height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> height[right] &gt; right_max:</span><br><span class="line">                    right_max = height[right]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += right_max - height[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>41-缺失的第一个正数</title>
    <link href="https://liuyang0001.github.io/2020/02/04/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <id>https://liuyang0001.github.io/2020/02/04/41-缺失的第一个正数/</id>
    <published>2020-02-04T11:31:30.000Z</published>
    <updated>2020-02-04T14:21:02.501Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><a id="more"></a><p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：通过桶排序的思想，使得每个数字和其索引相对应</strong>。</p><p><strong>负数和大于数组长度的数跳过</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 3 应该放在索引为 2 的地方</span></span><br><span class="line">    <span class="comment"># 4 应该放在索引为 3 的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="comment"># 先判断这个数字是不是索引，然后判断这个数字是不是放在了正确的地方</span></span><br><span class="line">            <span class="comment"># i != nums[i]-1  这里外层套nums是防止[1,1]出现死循环</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span> &lt;= nums[i] &lt;= size <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]:</span><br><span class="line">                nums[nums[i]<span class="number">-1</span>], nums[i] = nums[i],nums[nums[i]<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> != nums[i]:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> size + <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/first-missing-positive" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个未排序的整数数组，找出其中没有出现的最小的正整数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>40-组合总和II</title>
    <link href="https://liuyang0001.github.io/2020/02/03/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/"/>
    <id>https://liuyang0001.github.io/2020/02/03/40-组合总和II/</id>
    <published>2020-02-03T14:04:04.000Z</published>
    <updated>2020-02-03T14:46:55.143Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><hr></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：回溯算法</strong></p></blockquote><blockquote><p><strong>关键点：去重，如果上一个数和当前数字相同，则跳过</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        begin, end = <span class="number">0</span>, len(candidates)</span><br><span class="line">        <span class="keyword">if</span> end == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, path = [], []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.helper(candidates, begin, end, target, path, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, candidates: List[int], begin: int, end: int, delta: int, path: List[int], res: List[int])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> delta == <span class="number">0</span>:</span><br><span class="line">            res.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(begin, end):</span><br><span class="line">            delta_new = delta-candidates[index]</span><br><span class="line">            <span class="keyword">if</span> delta_new &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> index != begin <span class="keyword">and</span> candidates[index<span class="number">-1</span>] == candidates[index]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(candidates[index])</span><br><span class="line">            <span class="comment"># 与上题的不同在于每个元素不能重复使用</span></span><br><span class="line">            <span class="comment"># 所以下一个区间为[index+1,end)</span></span><br><span class="line">            self.helper(candidates, index+<span class="number">1</span>, end, delta_new, path, res)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;
&lt;p&gt;candidates 中的每个数字在每个组合中只能使用一次。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>39-组合总和</title>
    <link href="https://liuyang0001.github.io/2020/02/03/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>https://liuyang0001.github.io/2020/02/03/39-组合总和/</id>
    <published>2020-02-03T14:03:46.000Z</published>
    <updated>2020-02-03T14:13:00.401Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字（包括 target）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p>核心思想：采用回溯算法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        begin, end = <span class="number">0</span>, len(candidates)</span><br><span class="line">        <span class="keyword">if</span> end == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 剪枝的前提是数组元素排序</span></span><br><span class="line">        <span class="comment"># 深度深的边不能比深度浅的边还小</span></span><br><span class="line">        <span class="comment"># 要排序的理由：1、前面用过的数后面不能再用；2、下一层边上的数不能小于上一层边上的数。</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="comment"># 在遍历的过程中记录路径，一般而言它是一个栈</span></span><br><span class="line">        path, res = [], []</span><br><span class="line">        <span class="comment"># 注意要传入 end ，在 range 中， end 取不到</span></span><br><span class="line">        self.helper(candidates, <span class="number">0</span>, end, path, res, target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, candidates, begin, end, path, res, target)</span>:</span></span><br><span class="line">        <span class="comment"># 先写递归终止的情况</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># Python 中可变对象是引用传递，因此需要将当前 path 里的值拷贝出来</span></span><br><span class="line">            <span class="comment"># 或者使用 path.copy()</span></span><br><span class="line">            res.append(path[:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(begin, end):</span><br><span class="line">            delta = target - candidates[index]</span><br><span class="line">            <span class="comment"># “剪枝”操作，不必递归到下一层，并且后面的分支也不必执行</span></span><br><span class="line">            <span class="keyword">if</span> delta &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            path.append(candidates[index])</span><br><span class="line">            <span class="comment"># 因为下一层不能比上一层还小，起始索引还从 index 开始</span></span><br><span class="line">            self.helper(candidates, index, end, path, res, delta)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/combination-sum" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;
&lt;p&gt;candidates 中的数字可以无限制重复被选取。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>38-外观数列</title>
    <link href="https://liuyang0001.github.io/2020/02/02/38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/"/>
    <id>https://liuyang0001.github.io/2020/02/02/38-外观数列/</id>
    <published>2020-02-02T07:50:50.000Z</published>
    <updated>2020-02-02T08:17:01.746Z</updated>
    
    <content type="html"><![CDATA[<p>外观数列是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">前五项如下：</span><br><span class="line"></span><br><span class="line">   1.     1</span><br><span class="line">   2.     11</span><br><span class="line">   3.     21</span><br><span class="line">   4.     1211</span><br><span class="line">   5.     111221</span><br><span class="line">   </span><br><span class="line">1  被读作  (&quot;一个一&quot;) , 即 11。</span><br><span class="line">11 被读作 (&quot;两个一&quot;）, 即 21。</span><br><span class="line">21 被读作（&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。</span><br></pre></td></tr></table></figure><p>   <strong>注意：整数序列中的每一项将表示为一个字符串。</strong></p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 1</span><br><span class="line">输出: &quot;1&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 4</span><br><span class="line">输出: &quot;1211&quot;</span><br><span class="line">解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：后一个序列是由前一个序列确定的，故采用递归法。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        <span class="comment"># 加上*，可以防止数组越界,不用考虑边界问题</span></span><br><span class="line">        num = self.countAndSay(n<span class="number">-1</span>)+<span class="string">"*"</span></span><br><span class="line">        nums_ls = list(num)</span><br><span class="line">        <span class="comment"># print(nums_ls)</span></span><br><span class="line">        count, res = <span class="number">1</span>, <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums_ls) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 计数重复的数值</span></span><br><span class="line">            <span class="keyword">if</span> nums_ls[i] == nums_ls[i+<span class="number">1</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums_ls[i] != nums_ls[i+<span class="number">1</span>]:</span><br><span class="line">                res += str(count) + nums_ls[i]</span><br><span class="line">                <span class="comment"># print(res)</span></span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/count-and-say" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;外观数列是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>36-有效的数独</title>
    <link href="https://liuyang0001.github.io/2020/02/02/36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <id>https://liuyang0001.github.io/2020/02/02/36-有效的数独/</id>
    <published>2020-02-02T06:29:23.000Z</published>
    <updated>2020-02-02T06:42:48.469Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><a id="more"></a><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li></ul><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p><strong>说明:</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>给定数独序列只包含数字 1-9 和字符 ‘.’ 。</li><li>给定数独永远是 9x9 形式的。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: false</span><br><span class="line">解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。</span><br><span class="line">     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：使用三个哈希表进行计数，三个表中所有的value均不大于1时，返回True。</strong></p></blockquote><blockquote><p><strong>如何计算Box的索引值?</strong></p></blockquote><p><img src="https://pic.leetcode-cn.com/2b141392e2a1811d0e8dfdf6279b1352e59fad0b3961908c6ff9412b6a7e7ccf-image.png" alt=""></p><p>按照上图将9x9的数独分成0-8共九个3x3：则索引值为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box_index = row//<span class="number">3</span>*<span class="number">3</span>+column//<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        rows_ls = [&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        columns_ls = [&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        boxes_ls = [&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                num = board[row][column]</span><br><span class="line">                <span class="keyword">if</span> num != <span class="string">"."</span>:</span><br><span class="line">                    num = int(num)</span><br><span class="line">                    box_index = row//<span class="number">3</span>*<span class="number">3</span>+column//<span class="number">3</span></span><br><span class="line">                    rows_ls[row][num] = rows_ls[row].get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    columns_ls[column][num] = columns_ls[column].get(</span><br><span class="line">                        num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    boxes_ls[box_index][num] = boxes_ls[box_index].get(</span><br><span class="line">                        num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># check valid</span></span><br><span class="line">                    <span class="keyword">if</span> rows_ls[row][num] &gt; <span class="number">1</span> <span class="keyword">or</span> columns_ls[column][num] &gt; <span class="number">1</span> <span class="keyword">or</span> boxes_ls[box_index][num] &gt; <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/valid-sudoku" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="哈希表" scheme="https://liuyang0001.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>35-搜索插入位置</title>
    <link href="https://liuyang0001.github.io/2020/02/02/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>https://liuyang0001.github.io/2020/02/02/35-搜索插入位置/</id>
    <published>2020-02-02T04:00:07.000Z</published>
    <updated>2020-02-02T04:16:06.122Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><a id="more"></a><ul><li>你可以假设数组中无重复元素。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="一行解法"><a href="#一行解法" class="headerlink" title="一行解法"></a>一行解法</h3><blockquote><p><strong>核心思想：将小于target的元素生成一个列表，计算长度即可</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 一行解法</span></span><br><span class="line">        <span class="keyword">return</span> len([ i <span class="keyword">for</span> i <span class="keyword">in</span> nums <span class="keyword">if</span> i&lt;target ])</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote><p><strong>核心思想：找到最大的不大于target的索引位置</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums_len = len(nums)</span><br><span class="line">        <span class="keyword">if</span> nums_len == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, nums_len<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target <span class="keyword">and</span> nums[mid<span class="number">-1</span>] &lt; target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/search-insert-position" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="https://liuyang0001.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>34-排序数组中查找元素的第一和最后一个位置</title>
    <link href="https://liuyang0001.github.io/2020/02/02/34-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>https://liuyang0001.github.io/2020/02/02/34-排序数组中查找元素的第一和最后一个位置/</id>
    <published>2020-02-02T02:56:00.000Z</published>
    <updated>2020-02-02T03:43:58.587Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><a id="more"></a><ul><li><p>你的算法时间复杂度必须是 O(log n) 级别。</p></li><li><p>如果数组中不存在目标值，返回 [-1, -1]。</p></li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：采用两次二分查找，一次确定左边界，一次确定右边界。</strong></p></blockquote><blockquote><p>为何要分两次？</p><p>因为有重复的target值，当mid==target时，需要判定向左递归还是向右递归。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        nums_len = len(nums)</span><br><span class="line">        <span class="keyword">if</span> nums_len == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> [self.getLeft(nums, <span class="number">0</span>,  nums_len<span class="number">-1</span>, target), self.getRight(nums, <span class="number">0</span>, nums_len<span class="number">-1</span>, target)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找左边界</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeft</span><span class="params">(self, nums: List[int], left: int, right: int, target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 递归出口</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">if</span> nums[left] == target <span class="keyword">else</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target <span class="keyword">and</span> nums[mid<span class="number">-1</span>] != target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment"># 递归入口</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> self.getLeft(nums, mid+<span class="number">1</span>, right, target)</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt;= target:  <span class="comment"># mid==target时取左侧，向左递归</span></span><br><span class="line">            <span class="keyword">return</span> self.getLeft(nums, left, mid<span class="number">-1</span>, target)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找右边界</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRight</span><span class="params">(self, nums: List[int], left: int, right: int, target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">if</span> nums[left] == target <span class="keyword">else</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target <span class="keyword">and</span> nums[mid+<span class="number">1</span>] != target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            <span class="keyword">return</span> self.getRight(nums, left, mid<span class="number">-1</span>, target)</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt;= target:  <span class="comment"># mid==target时取右侧，向右递归</span></span><br><span class="line">            <span class="keyword">return</span> self.getRight(nums, mid+<span class="number">1</span>, right, target)</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="https://liuyang0001.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode刷题笔记整理</title>
    <link href="https://liuyang0001.github.io/2020/01/31/%E7%BD%AE%E9%A1%B6-Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>https://liuyang0001.github.io/2020/01/31/置顶-Leetcode刷题笔记整理/</id>
    <published>2020-01-31T08:23:24.000Z</published>
    <updated>2020-01-31T08:38:06.922Z</updated>
    
    <content type="html"><![CDATA[<p>所有刷题笔记内容的汇总分类，与个人总结。【不间断更新】</p><a id="more"></a><hr><h2 id="按照问题分类"><a href="#按照问题分类" class="headerlink" title="按照问题分类"></a>按照问题分类</h2><ol><li><p><a href="https://liuyang0001.github.io/tags/字符串/">字符串</a></p></li><li><p><a href="https://liuyang0001.github.io/tags/数组/">数组问题</a></p></li><li><p><a href="https://liuyang0001.github.io/tags/链表/">链表问题</a></p></li></ol><hr><h2 id="按照解法分类"><a href="#按照解法分类" class="headerlink" title="按照解法分类"></a>按照解法分类</h2><ol><li><a href="https://liuyang0001.github.io/tags/栈/">栈</a></li><li><a href="https://liuyang0001.github.io/tags/队列/">队列</a></li><li><a href="https://liuyang0001.github.io/tags/双指针/">双指针</a></li><li><a href="https://liuyang0001.github.io/tags/哈希表/">哈希算法</a></li><li><a href="https://liuyang0001.github.io/tags/二分查找/">二分查找</a></li><li><a href="https://liuyang0001.github.io/tags/动态规划/">动态规划</a></li><li><a href="https://liuyang0001.github.io/tags/贪心算法/">贪心算法</a></li><li><a href="https://liuyang0001.github.io/tags/回溯法/">回溯思想</a></li></ol><hr><h2 id="按题号顺序分类"><a href="#按题号顺序分类" class="headerlink" title="按题号顺序分类"></a>按题号顺序分类</h2><table><thead><tr><th style="text-align:center">#</th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">博客文章</th></tr></thead><tbody><tr><td style="text-align:center">001</td><td style="text-align:center">两数之和</td><td style="text-align:center">简单</td><td style="text-align:center">数组；哈希表</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/02/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/">:memo:</a></td></tr><tr><td style="text-align:center">002</td><td style="text-align:center">两数相加</td><td style="text-align:center">中等</td><td style="text-align:center">链表；数学</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/03/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/">:memo:</a></td></tr><tr><td style="text-align:center">003</td><td style="text-align:center">无重复字符的最长子串</td><td style="text-align:center">中等</td><td style="text-align:center">字符串；滑动窗口</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/03/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">:memo:</a></td></tr><tr><td style="text-align:center">004</td><td style="text-align:center">寻找两个有序数组的中位数</td><td style="text-align:center">困难</td><td style="text-align:center">数组；分治算法</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/04/4-寻找两个有序数组的中位数/">:memo:</a></td></tr><tr><td style="text-align:center">005</td><td style="text-align:center">最长回文子串</td><td style="text-align:center">中等</td><td style="text-align:center">字符串；动态规划；中心扩展</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/05/5-最长回文子串/">:memo:</a></td></tr><tr><td style="text-align:center">006</td><td style="text-align:center">Z字形变换</td><td style="text-align:center">中等</td><td style="text-align:center">字符串</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/06/6-Z字形变换/">:memo:</a></td></tr><tr><td style="text-align:center">007</td><td style="text-align:center">整数反转</td><td style="text-align:center">简单</td><td style="text-align:center">数学</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/07/7-整数反转/">:memo:</a></td></tr><tr><td style="text-align:center">008</td><td style="text-align:center">字符串转换整数</td><td style="text-align:center">中等</td><td style="text-align:center">数学；字符串</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/08/8-字符串转换整数/">:memo:</a></td></tr><tr><td style="text-align:center">009</td><td style="text-align:center">回文数</td><td style="text-align:center">简单</td><td style="text-align:center">数学</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/09/9-回文数/">:memo:</a></td></tr><tr><td style="text-align:center">010</td><td style="text-align:center">正则表达式匹配</td><td style="text-align:center">困难</td><td style="text-align:center">字符串；动态规划；回溯算法</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/10/10-正则表达式匹配">:memo:</a></td></tr><tr><td style="text-align:center">011</td><td style="text-align:center">盛最多水的容器</td><td style="text-align:center">中等</td><td style="text-align:center">数组；双指针</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/11/11-盛最多水的容器/">:memo:</a></td></tr><tr><td style="text-align:center">012</td><td style="text-align:center">整数转罗马数字</td><td style="text-align:center">中等</td><td style="text-align:center">数学；字符串；贪心算法</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/12/12-整数转罗马数字/">:memo:</a></td></tr><tr><td style="text-align:center">013</td><td style="text-align:center">罗马数字转整数</td><td style="text-align:center">简单</td><td style="text-align:center">数学；字符串</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/13/13-罗马数字转整数/">:memo:</a></td></tr><tr><td style="text-align:center">014</td><td style="text-align:center">最长公共前缀</td><td style="text-align:center">简单</td><td style="text-align:center">字符串</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/14/14-最长公共前缀/">:memo:</a></td></tr><tr><td style="text-align:center">015</td><td style="text-align:center">三数之和</td><td style="text-align:center">中等</td><td style="text-align:center">数组；双指针</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/20/15-三数之和/">:memo:</a></td></tr><tr><td style="text-align:center">016</td><td style="text-align:center">最接近的三数之和</td><td style="text-align:center">中等</td><td style="text-align:center">数组；双指针</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/15/16-最接近的三数之和/">:memo:</a></td></tr><tr><td style="text-align:center">017</td><td style="text-align:center">电话号码的字母组合</td><td style="text-align:center">中等</td><td style="text-align:center">字符串；回溯算法</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/16/17-电话号码的组合/">:memo:</a></td></tr><tr><td style="text-align:center">018</td><td style="text-align:center">四数之和</td><td style="text-align:center">中等</td><td style="text-align:center">数组；哈希表；双指针</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/17/18-四数之和">:memo:</a></td></tr><tr><td style="text-align:center">019</td><td style="text-align:center">删除链表的倒数第N个结点</td><td style="text-align:center">中等</td><td style="text-align:center">链表；双指针</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/17/19-删除链表的倒数第N个结点/">:memo:</a></td></tr><tr><td style="text-align:center">020</td><td style="text-align:center">有效的括号</td><td style="text-align:center">简单</td><td style="text-align:center">栈；字符串</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/18/20-有效的括号/">:memo:</a></td></tr><tr><td style="text-align:center">021</td><td style="text-align:center">合并两个有序链表</td><td style="text-align:center">简单</td><td style="text-align:center">链表</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/18/21-合并两个有序链表/">:memo:</a></td></tr><tr><td style="text-align:center">022</td><td style="text-align:center">括号生成</td><td style="text-align:center">中等</td><td style="text-align:center">字符串；回溯算法</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/18/22-括号生成/">:memo:</a></td></tr><tr><td style="text-align:center">023</td><td style="text-align:center">合并K个排序链表</td><td style="text-align:center">困难</td><td style="text-align:center">队列；链表</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/19/23-合并K个排序链表/">:memo:</a></td></tr><tr><td style="text-align:center">024</td><td style="text-align:center">两两交换链表中的结点</td><td style="text-align:center">中等</td><td style="text-align:center">链表</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/20/24-两两交换链表中的结点/">:memo:</a></td></tr><tr><td style="text-align:center">025</td><td style="text-align:center">K个一组翻转链表</td><td style="text-align:center">困难</td><td style="text-align:center">链表</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">026</td><td style="text-align:center">删除排序数组中的重复项</td><td style="text-align:center">简单</td><td style="text-align:center">数组；双指针</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/20/26-删除排序数组中的重复项/">:memo:</a></td></tr><tr><td style="text-align:center">027</td><td style="text-align:center">移除元素</td><td style="text-align:center">简单</td><td style="text-align:center">数组；双指针</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/20/27-移除元素/">:memo:</a></td></tr><tr><td style="text-align:center">028</td><td style="text-align:center">实现strStr</td><td style="text-align:center">简单</td><td style="text-align:center">字符串；双指针</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/20/28-实现strStr/">:memo:</a></td></tr><tr><td style="text-align:center">029</td><td style="text-align:center">两数相除</td><td style="text-align:center">中等</td><td style="text-align:center">数学；二分查找</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/21/29-两数相除/">:memo:</a></td></tr><tr><td style="text-align:center">030</td><td style="text-align:center">串联所有单词的子串</td><td style="text-align:center">困难</td><td style="text-align:center">字符串；哈希表；双指针</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">031</td><td style="text-align:center">下一个排列</td><td style="text-align:center">中等</td><td style="text-align:center">数组</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/21/31-下一个排列/">:memo:</a></td></tr><tr><td style="text-align:center">032</td><td style="text-align:center">最长有效括号</td><td style="text-align:center">困难</td><td style="text-align:center">字符串；栈；动态规划</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/23/32-最长有效括号/">:memo:</a></td></tr><tr><td style="text-align:center">033</td><td style="text-align:center">搜索旋转排序数组</td><td style="text-align:center">中等</td><td style="text-align:center">数组；二分查找</td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/31/33-搜索旋转排列数组/">:memo:</a></td></tr><tr><td style="text-align:center">034</td><td style="text-align:center">在排序数组中查找元素的第一个和最后一个位置</td><td style="text-align:center">中等</td><td style="text-align:center">数组；二分查找</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">035</td><td style="text-align:center">搜索插入位置</td><td style="text-align:center">简单</td><td style="text-align:center">数组；二分查找</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有刷题笔记内容的汇总分类，与个人总结。【不间断更新】&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>33-搜索旋转排序数组</title>
    <link href="https://liuyang0001.github.io/2020/01/31/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://liuyang0001.github.io/2020/01/31/33-搜索旋转排序数组/</id>
    <published>2020-01-31T07:34:34.000Z</published>
    <updated>2020-01-31T07:54:02.373Z</updated>
    
    <content type="html"><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><a id="more"></a><blockquote><ol><li><p>你可以假设数组中不存在重复的元素。</p></li><li><p>你的算法时间复杂度必须是 O(log n) 级别。</p></li></ol></blockquote><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p>核心思路：使用<strong>二分法</strong>。关键点在与找到转折点T与mid点的关系，判断target是否在<strong>升序</strong>的那一部分中来更新left和right的值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        mid, left, right = <span class="number">0</span>, <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 二分法</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断mid点是否为所求点</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">    </span><br><span class="line">            <span class="comment"># 旋转点T在mid右区间</span></span><br><span class="line">            <span class="comment"># [left......mid....T....right]</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:  </span><br><span class="line">                <span class="comment"># target在[left,mid)的升序空间中</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="comment"># target在(mid,T]或者[T,right]中</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 旋转点T在mid左区间</span></span><br><span class="line">            <span class="comment"># [left...T...mid........right]</span></span><br><span class="line">            <span class="keyword">elif</span> nums[left] &gt; nums[mid]:</span><br><span class="line">                <span class="comment"># target在(mid,right]的升序空间中</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="comment"># target在[left,T]或者[T，mid)</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">        <span class="comment"># 未找到该点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。&lt;/p&gt;
&lt;p&gt;搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="https://liuyang0001.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>32-最长有效括号</title>
    <link href="https://liuyang0001.github.io/2020/01/23/32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <id>https://liuyang0001.github.io/2020/01/23/32-最长有效括号/</id>
    <published>2020-01-23T14:11:12.000Z</published>
    <updated>2020-01-23T15:11:57.715Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h3><p><strong>思路：</strong></p><ol><li>特判，若s为空，返回0</li><li>初试化栈<code>stack=[-1]</code>，和结果<code>res=0</code>。栈中元素表示上一不匹配位置索引。</li><li><p>遍历s：</p><ul><li><p>若<code>s[i]==&quot;(&quot;</code>，将当前位置索引加入<code>stack</code>。表示将当前左括号需要匹配，为不匹配索引。</p></li><li><p>若<code>s[i]==&quot;)&quot;</code>：<br>出栈，<code>stack.pop()</code>。表示将对应左括号索引出栈，或者当栈中只有 <code>)</code> 时，将上一 <code>)</code> 索引出栈。<br>若栈为空，表示之前的所有的 <code>(</code> 匹配成功，上一步出栈的是栈底的-1或者是前一个不匹配的 <code>)</code> 。则更新栈底为当前 <code>)</code> 的索引，表示不匹配的位置。</p></li><li><p>否则，说明和栈中的 <code>(</code> 匹配上了，此时更新最长序列<code>res=max(res,i−stack[−1])</code>。表示当前位置索引减去上一不匹配位置索引 和之前<code>res</code>中的较大值。</p></li></ul></li><li>更新res</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        stack = [<span class="number">-1</span>]  <span class="comment"># -1占位</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">"("</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">")"</span>:</span><br><span class="line">                stack.pop()  <span class="comment"># 弹出对应的左括号索引</span></span><br><span class="line">                <span class="comment"># 空栈表示已经出现不合法的括号，</span></span><br><span class="line">                <span class="comment"># 把索引值压进栈中</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># i-stack中倒数第一个的索引值</span></span><br><span class="line">                    <span class="comment"># 为当前合法的长度大小</span></span><br><span class="line">                    res = max(res, i - stack[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>思路：</strong></p><ol><li>特判，若s为空，返回0</li><li>初试化<code>dp=[0,...,0]</code>，长度为n。<code>dp[i]</code>表示到i位置的最长有效括号的长度。<br>显然，当<code>s[i]==(</code>时，<code>dp[i]=0</code></li><li><p>遍历字符串，遍历区间<code>[1,n)</code>：</p><ul><li>当<code>s[i]==)</code>时，若<code>s[i−1]==(</code>，说明这两个有效。则<code>dp[i]=dp[i-2]+2</code><br>否则<code>s[i-1]==)</code>，此时找到上一匹配字符串的上一位<code>i−dp[i−1]−1</code>：</li><li>若<code>s[i-dp[i-1]-1]==(</code>，说明s[i]s[i]可以和<code>s[i-dp[i-1]-1]</code>匹配：则<code>dp[i]=dp[i-1]+dp[i-dp[i-1]-2]+2</code>，表示当前位置的最长有效括号长度等于上一位有效括号的长度加上自身匹配的上一位的有效括号的长度加上2。</li></ul></li><li>更新res，<code>res=max(res,dp[i])</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> s):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="number">0</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">")"</span>):</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">"("</span>):</span><br><span class="line">                    dp[i] = dp[i<span class="number">-2</span>]+<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">")"</span> <span class="keyword">and</span> i-dp[i<span class="number">-1</span>]<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">"("</span>):</span><br><span class="line">                    dp[i] = dp[i<span class="number">-1</span>]+dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]+<span class="number">2</span></span><br><span class="line">                res = max(res, dp[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="栈" scheme="https://liuyang0001.github.io/tags/%E6%A0%88/"/>
    
      <category term="动态规划" scheme="https://liuyang0001.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>31-下一个排列</title>
    <link href="https://liuyang0001.github.io/2020/01/21/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>https://liuyang0001.github.io/2020/01/21/31-下一个排列/</id>
    <published>2020-01-21T13:17:55.000Z</published>
    <updated>2020-01-21T14:15:24.848Z</updated>
    
    <content type="html"><![CDATA[<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><a id="more"></a><p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure><p><hr></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p><strong>核心思想：</strong></p><ul><li><p>先找出最大的索引 <strong>k</strong> 满足 <strong>nums[k] &lt; nums[k+1]</strong>，如果不存在，就翻转整个数组；</p></li><li><p>再找出另一个最大索引 <strong>l</strong> 满足 <strong>nums[l] &gt; nums[k]</strong>；</p></li><li><p>交换 nums[l] 和 nums[k]；</p></li><li><p>最后翻转 nums[k+1:]。</p></li></ul><p>举个例子：</p><p>比如 nums = [1,2,7,4,3,1]，下一个排列是什么？</p><p>我们找到第一个最大索引是 nums[1] = 2，则firstIndex=1</p><p>再找到第二个最大索引是 nums[4] = 3，则secondIndex=4</p><p>交换nums[1]和nums[4]，nums = [1,3,7,4,2,1];</p><p>翻转[firstIndex+1:]，nums = [1,3,1,2,4,7] ，完毕!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化两个索引值</span></span><br><span class="line">        firstIndex, secondIndex = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># 找第一个最大索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                firstIndex = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 未找到则反转整个数组</span></span><br><span class="line">        <span class="keyword">if</span> firstIndex == <span class="number">-1</span>:</span><br><span class="line">            <span class="comment"># nums[:]为使得nums的地址不变</span></span><br><span class="line">            nums[:]=nums[::<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 找第二个索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, firstIndex, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[firstIndex]:</span><br><span class="line">                secondIndex = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[firstIndex], nums[secondIndex] = nums[secondIndex], nums[firstIndex]</span><br><span class="line">        nums[:]= nums[:firstIndex+<span class="number">1</span>]+nums[firstIndex+<span class="number">1</span>:][::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/next-permutation" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;p&gt;如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>29-两数相除</title>
    <link href="https://liuyang0001.github.io/2020/01/21/29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <id>https://liuyang0001.github.io/2020/01/21/29-两数相除/</id>
    <published>2020-01-21T11:57:55.000Z</published>
    <updated>2020-01-21T12:03:54.432Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: dividend = 10, divisor = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: dividend = 7, divisor = -3</span><br><span class="line">输出: -2</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明:</strong></p><p>被除数和除数均为 32 位有符号整数，且除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</p></blockquote><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：用减法代替除法操作，用左移来增大两倍，不断增大被除数来减少执行次数</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        sig = <span class="keyword">not</span> ((dividend&gt;=<span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>))       <span class="comment"># 判断二者相除是正or负（同或操作）</span></span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor) <span class="comment"># 将被除数和除数都变成正数</span></span><br><span class="line">        res = <span class="number">0</span>                                         <span class="comment"># 用来表示减去了多少个除数，也就是商为多少</span></span><br><span class="line">        <span class="keyword">while</span> divisor &lt;= dividend:                      <span class="comment"># 当被除数小于除数的时候终止循环</span></span><br><span class="line">            tmp_divisor, count = divisor, <span class="number">1</span>             <span class="comment"># 倍增除数初始化</span></span><br><span class="line">            <span class="keyword">while</span> tmp_divisor &lt;= dividend:              <span class="comment"># 当倍增后的除数大于被除数则变成最开始的除数</span></span><br><span class="line">                dividend -= tmp_divisor</span><br><span class="line">                res += count</span><br><span class="line">                count &lt;&lt;= <span class="number">1</span>                             <span class="comment"># 向左移动一位,扩大两倍</span></span><br><span class="line">                tmp_divisor &lt;&lt;= <span class="number">1</span>                       <span class="comment"># 更新除数(将除数扩大两倍)</span></span><br><span class="line">        res_value = res <span class="keyword">if</span> sig <span class="keyword">else</span> -res                <span class="comment"># 给结果加上符号</span></span><br><span class="line">        <span class="keyword">return</span> max(min(res_value, <span class="number">2147483647</span>), <span class="number">-2147483648</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/divide-two-integers" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。&lt;/p&gt;
&lt;p&gt;返回被除数 dividend 除以除数 divisor 得到的商。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分查找" scheme="https://liuyang0001.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>15-三数之和</title>
    <link href="https://liuyang0001.github.io/2020/01/20/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://liuyang0001.github.io/2020/01/20/15-三数之和/</id>
    <published>2020-01-20T12:15:57.000Z</published>
    <updated>2020-01-20T12:27:00.201Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><a id="more"></a><p>注意：答案中不可以包含重复的三元组。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><hr></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：固定一个点，利用双指针遍历</strong></p></blockquote><p><strong>关键点在去除不可能的情况：</strong></p><ul><li><strong>最小的大于0</strong></li><li><strong>总数小于三个</strong></li><li><strong>之前判别过的（low从i+1开始）</strong></li><li><strong>去除res中的重复答案</strong></li></ul><h3 id="利用set-去重"><a href="#利用set-去重" class="headerlink" title="利用set()去重"></a>利用set()去重</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        res = set()</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_nums<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> list(res)</span><br><span class="line">            low = i+<span class="number">1</span></span><br><span class="line">            high = len_nums<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                sumOfThree = nums[i]+nums[low]+nums[high]</span><br><span class="line">                <span class="keyword">if</span> sumOfThree == <span class="number">0</span>:</span><br><span class="line">                    res.add((nums[i], nums[low], nums[high]))</span><br><span class="line">                <span class="keyword">if</span> sumOfThree &lt; <span class="number">0</span>:</span><br><span class="line">                    low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sumOfThree &gt;= <span class="number">0</span>:</span><br><span class="line">                    high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> res:</span><br><span class="line">            l=list(l)</span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br></pre></td></tr></table></figure><h3 id="前项和后项相等时跳过"><a href="#前项和后项相等时跳过" class="headerlink" title="前项和后项相等时跳过"></a>前项和后项相等时跳过</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># 从小到大排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="comment"># 从左侧开始逐渐选取一个值为定值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="comment"># 避免重复项，如 [-4, -1, -1, 0, 1, 2] 中由于两个 -1 导致的两个 [-1, 0, 1]</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 减少无关计算，定值大于 0 后，后面的都大于 0，没必要进行计算了</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 左指针随着定值的移动而移动</span></span><br><span class="line">            l = i + <span class="number">1</span></span><br><span class="line">            r = length - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 获取右侧剩余的值中的与前面定值相加为 0 的两个值</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="comment"># 先求和，减少因 if 判断导致的重复计算和增加内存空间</span></span><br><span class="line">                s = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="comment"># 满足条件，添加</span></span><br><span class="line">                <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i], nums[l], nums[r]])</span><br><span class="line">                    <span class="comment"># 避免重复项</span></span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r) <span class="keyword">and</span> (nums[l+<span class="number">1</span>] == nums[l]):</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r) <span class="keyword">and</span> (nums[r<span class="number">-1</span>] == nums[r]):</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 满足后现指针均需移动，避免重复和无效计算</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 小于 0，左指针右移</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 大于 0，右指针左移</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>28-实现strStr</title>
    <link href="https://liuyang0001.github.io/2020/01/20/28-%E5%AE%9E%E7%8E%B0strStr/"/>
    <id>https://liuyang0001.github.io/2020/01/20/28-实现strStr/</id>
    <published>2020-01-20T08:35:21.000Z</published>
    <updated>2020-01-20T08:50:37.649Z</updated>
    
    <content type="html"><![CDATA[<p>实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><blockquote><p>说明:</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p></blockquote><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h4 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h4><blockquote><p><strong>核心思想：双指针ij分别用于对两个字符串的遍历，指针k用于记录遍历到母串的哪一位置</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        i,j,k=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        len_needle=len(needle)</span><br><span class="line">        len_haystack=len(haystack)</span><br><span class="line">        <span class="keyword">while</span> i&lt;len_haystack <span class="keyword">and</span> j&lt;len_needle:</span><br><span class="line">            <span class="keyword">if</span> haystack[i]==needle[j]:</span><br><span class="line">                i,j=i+<span class="number">1</span>,j+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i,j=k+<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> k <span class="keyword">if</span> j &gt;= len_needle <span class="keyword">else</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="调用字符串的库函数"><a href="#调用字符串的库函数" class="headerlink" title="调用字符串的库函数"></a>调用字符串的库函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python一行实现功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> haystack.find(needle)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者使用index()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = haystack.index(needle)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/implement-strstr" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>27-移除元素</title>
    <link href="https://liuyang0001.github.io/2020/01/20/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>https://liuyang0001.github.io/2020/01/20/27-移除元素/</id>
    <published>2020-01-20T07:18:11.000Z</published>
    <updated>2020-01-20T07:22:11.414Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><a id="more"></a><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line">注意:这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：采用双指针，一个用来遍历，一个确定新的表尾位置。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        len_nums = len(nums)  <span class="comment"># 这句写在判断里会每次都遍历一遍</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; len_nums:</span><br><span class="line">            <span class="keyword">if</span> nums[j] != val:</span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        nums = nums[:i]</span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>26-删除排序数组中的重复项</title>
    <link href="https://liuyang0001.github.io/2020/01/20/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://liuyang0001.github.io/2020/01/20/26-删除排序数组中的重复项/</id>
    <published>2020-01-20T06:59:30.000Z</published>
    <updated>2020-01-20T07:04:14.107Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><a id="more"></a><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p></blockquote><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：采用双指针，一个记录当前遍历的位置，另一个用来记录无重复的元素个数</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双指针解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i,j=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]!=nums[j]:</span><br><span class="line">                nums[i+<span class="number">1</span>]=nums[j]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># nums=nums[:i+1]</span></span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>24-两两交换链表中的结点</title>
    <link href="https://liuyang0001.github.io/2020/01/20/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <id>https://liuyang0001.github.io/2020/01/20/24-两两交换链表中的结点/</id>
    <published>2020-01-20T05:45:00.000Z</published>
    <updated>2020-01-20T05:58:18.414Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><a id="more"></a><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><ul><li><strong>设立新的头结点H的好处是：使得交换前两个结点时的操作和后面的完全一致，不用分开处理。</strong></li><li><strong>指针pre和p：分别指向要交换的两个结点，每次向后移动两个结点</strong></li><li><strong>指针rear：指向已经排好顺序的部分的尾端，初始指向头结点</strong></li><li><strong>结束条件：p指向位置为空</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非递归解法</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="keyword">None</span> <span class="keyword">or</span> head.next==<span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 创建一个不含任何信息的头结点，并添加到原链表的前面</span></span><br><span class="line">        H = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        H.next = head</span><br><span class="line">        rear =H <span class="comment">#指向已完成交换部分的尾结点，初始为头结点H</span></span><br><span class="line">        pre,p = head,head.next <span class="comment">#分别指向要交换的两个结点</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="comment"># 重新调整结点位置</span></span><br><span class="line">            pre.next = p.next</span><br><span class="line">            p.next = pre</span><br><span class="line">            rear.next = p</span><br><span class="line">            <span class="comment"># 更新指针</span></span><br><span class="line">            rear = pre</span><br><span class="line">            pre = pre.next</span><br><span class="line">            p = pre.next <span class="keyword">if</span> pre <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> H.next</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 结点数为0或1时</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 每次处理两个结点，head和N</span></span><br><span class="line">        N = head.next</span><br><span class="line">        <span class="comment"># head处理后变为后面的结点，</span></span><br><span class="line">        <span class="comment"># 需要和后面递归的首元素连接起来</span></span><br><span class="line">        head.next = self.swapPairs(N.next)</span><br><span class="line">        <span class="comment"># 原来后面的元素放到前面</span></span><br><span class="line">        N.next = head</span><br><span class="line">        <span class="comment"># 最后返回的是N（后面的变到了前面）</span></span><br><span class="line">        <span class="keyword">return</span> N</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>23-合并K个排序链表</title>
    <link href="https://liuyang0001.github.io/2020/01/19/23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://liuyang0001.github.io/2020/01/19/23-合并K个排序链表/</id>
    <published>2020-01-19T12:46:38.000Z</published>
    <updated>2020-01-19T15:57:43.018Z</updated>
    
    <content type="html"><![CDATA[<p>合并 k 个排序链表，返回合并后的排序链表。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><blockquote><p><strong>核心思想：将所有结点的数据域val加入列表中，在对其排序，生成结点加入新链表</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        new_List = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        p = new_List</span><br><span class="line">        nodes = []</span><br><span class="line">        <span class="comment"># 将每个结点的值都加入列表中</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> l != <span class="keyword">None</span>:</span><br><span class="line">                nodes.append(l.val)</span><br><span class="line">                l = l.next</span><br><span class="line">        <span class="comment"># 对列表进行排序，依次生成结点加入新链表</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> sorted(nodes):</span><br><span class="line">            p.next=ListNode(node)</span><br><span class="line">            p=p.next</span><br><span class="line">        <span class="keyword">return</span> new_List.next</span><br></pre></td></tr></table></figure><h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><blockquote><p><strong>核心思想：利用以数据域为优先级的队列，将每个未访问过得最前面的结点加入队列。这样出队的一定是当前数据域最小的结点，将其加入新链表中，并该节点的后继结点加入队列（如果存在的话）。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解法2:利用优先级队列</span></span><br><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)</span><br><span class="line">        q = PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                <span class="comment"># 根据结点的数据域val为优先级加入队列</span></span><br><span class="line">                q.put((l.val, l))</span><br><span class="line">        <span class="comment"># 每次取出最小的数据域的结点，</span></span><br><span class="line">        <span class="comment"># 再将取出的结点后继加入队列。</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            val, node = q.get()</span><br><span class="line">            point.next = ListNode(val)</span><br><span class="line">            point = point.next</span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                q.put((node.val, node))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="队列" scheme="https://liuyang0001.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>22-括号生成</title>
    <link href="https://liuyang0001.github.io/2020/01/18/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>https://liuyang0001.github.io/2020/01/18/22-括号生成/</id>
    <published>2020-01-18T07:57:43.000Z</published>
    <updated>2020-01-18T08:29:32.732Z</updated>
    
    <content type="html"><![CDATA[<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： n = 3</span><br><span class="line">输出：[ &quot;((()))&quot;, &quot;(()())&quot;,&quot;(())()&quot;, &quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><hr></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法-动态规划"><a href="#解法-动态规划" class="headerlink" title="解法-动态规划"></a>解法-动态规划</h3><blockquote><p><strong>核心思想：分治算法/动态规划</strong></p><p><strong>在求N个括号的排列组合时，把第N种情况（也就是N个括号排列组合）视为单独拿一个括号E出来，剩下的N-1个括号分为两部分，P个括号和Q个括号，P+Q=N-1，然后这两部分分别处于括号E内和括号E的右边，各自进行括号的排列组合。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> self.generateParenthesis(i):</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> self.generateParenthesis(n - <span class="number">1</span> - i):</span><br><span class="line">                    <span class="comment"># 先拿出一对括号</span></span><br><span class="line">                    <span class="comment"># 剩下的括号要么在这一组新增的括号内部，</span></span><br><span class="line">                    <span class="comment"># 要么在这一组新增括号的外部（右侧）。</span></span><br><span class="line">                    res.append(<span class="string">'(&#123;&#125;)&#123;&#125;'</span>.format(left, right))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="解法-回溯算法"><a href="#解法-回溯算法" class="headerlink" title="解法-回溯算法"></a>解法-回溯算法</h3><blockquote><p><strong>核心思想：类似深度优先，第一个结果，会是 <code>((()))</code> ,最后一个结果是 <code>()()()</code> 。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回溯法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, N: int)</span> -&gt; List[str]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(S = <span class="string">''</span>, left = <span class="number">0</span>, right = <span class="number">0</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(S) == <span class="number">2</span> * N:</span><br><span class="line">                ans.append(S)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; N:</span><br><span class="line">                backtrack(S+<span class="string">'('</span>, left+<span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                backtrack(S+<span class="string">')'</span>, left, right+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
