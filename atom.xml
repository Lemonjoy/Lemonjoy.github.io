<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Liu&#39;s Tech Blog</title>
  
  <subtitle>Python技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuyang0001.github.io/"/>
  <updated>2020-04-01T09:46:56.381Z</updated>
  <id>https://liuyang0001.github.io/</id>
  
  <author>
    <name>Liu Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>100-相同的树</title>
    <link href="https://liuyang0001.github.io/2020/04/01/100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>https://liuyang0001.github.io/2020/04/01/100-相同的树/</id>
    <published>2020-04-01T08:40:24.000Z</published>
    <updated>2020-04-01T09:46:56.381Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：两棵树同步递归遍历相比较即可。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 两个空结点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># 结点均非空且值相等</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> q <span class="keyword">and</span> p.val == q.val:</span><br><span class="line">            <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/same-tree/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/same-tree/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个二叉树，编写一个函数来检验它们是否相同。&lt;/p&gt;
&lt;p&gt;如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://liuyang0001.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>99-恢复二叉搜索树</title>
    <link href="https://liuyang0001.github.io/2020/04/01/99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://liuyang0001.github.io/2020/04/01/99-恢复二叉搜索树/</id>
    <published>2020-04-01T08:40:11.000Z</published>
    <updated>2020-04-01T09:45:12.751Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  /</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">输出: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：两次利用中序遍历该树，第一次遍历为扫描结点值，第二次遍历为把排序后的结点值依次填入。</strong></p><p><strong>注意：取排序后的列表值，不能使用pop()</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tree = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root,flag)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left,flag)</span><br><span class="line">            <span class="keyword">if</span> flag==<span class="string">"traverse"</span>:</span><br><span class="line">                tree.append(root.val)</span><br><span class="line">            <span class="keyword">elif</span> flag == <span class="string">"modify"</span>:</span><br><span class="line">                <span class="comment"># 注意:这里不能使用pop()</span></span><br><span class="line">                <span class="comment"># 排序不会改变pop的顺序</span></span><br><span class="line">                root.val = tree[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">del</span> tree[<span class="number">0</span>]</span><br><span class="line">            helper(root.right, flag)</span><br><span class="line">        <span class="comment"># 先遍历</span></span><br><span class="line">        helper(root, flag=<span class="string">"traverse"</span>)</span><br><span class="line">        <span class="comment"># 排序</span></span><br><span class="line">        tree.sort()</span><br><span class="line">        <span class="comment"># 再替换</span></span><br><span class="line">        helper(root, flag=<span class="string">"modify"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://liuyang0001.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>98-验证二叉搜索树</title>
    <link href="https://liuyang0001.github.io/2020/04/01/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://liuyang0001.github.io/2020/04/01/98-验证二叉搜索树/</id>
    <published>2020-04-01T08:17:41.000Z</published>
    <updated>2020-04-01T09:41:09.095Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><a id="more"></a><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：中序遍历该树，得到的数列有序即可证明是一颗二叉排序树</strong></p><p><strong>注意：得到的数列应该无重复字符</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        tree = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            tree.append(root.val)</span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="comment"># print(tree,sorted(tree))</span></span><br><span class="line">        <span class="comment"># 需判断是否存在重复结点</span></span><br><span class="line">        <span class="keyword">return</span> tree==sorted(tree) <span class="keyword">and</span> len(set(tree))==len(tree)</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://liuyang0001.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>96-不同的二叉搜索树</title>
    <link href="https://liuyang0001.github.io/2020/04/01/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://liuyang0001.github.io/2020/04/01/96-不同的二叉搜索树/</id>
    <published>2020-04-01T08:08:16.000Z</published>
    <updated>2020-04-01T09:37:45.057Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：卡特兰数问题，典型的dp解决</strong></p></blockquote><p><img src="https://github.com/Liuyang0001/liuyang0001.github.io/tree/master/images/image-98.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp_list = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp_list[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp_list[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                dp_list[i] += dp_list[j]*dp_list[i-j<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp_list[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，求以 1 … &lt;em&gt;n&lt;/em&gt; 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="动态规划" scheme="https://liuyang0001.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>95-不同的二叉搜索树-ii</title>
    <link href="https://liuyang0001.github.io/2020/04/01/95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-ii/"/>
    <id>https://liuyang0001.github.io/2020/04/01/95-不同的二叉搜索树-ii/</id>
    <published>2020-04-01T08:02:03.000Z</published>
    <updated>2020-04-01T09:28:14.345Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的<strong>二叉搜索树</strong>。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释:</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用二叉搜索树的性质，左子树只能比当前结点小，右子树只能比当前结点大。每个结点均有可能做为根结点。</strong></p><p><strong>技巧点：利用lru_cache收集每一个返回的值</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># Notice：返回值应为List[TreeNode]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 收集每次的返回值，组成缓存列表,None为动态调节大小</span></span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(start, end)</span>:</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                res.append(<span class="keyword">None</span>)</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 左子树均小于val</span></span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> helper(start, val - <span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 右子树均大于val</span></span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> helper(val + <span class="number">1</span>, end):</span><br><span class="line">                        <span class="comment"># 构建树节点</span></span><br><span class="line">                        root = TreeNode(val,left,right)</span><br><span class="line">                        res.append(root)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，生成所有由 1 … &lt;em&gt;n&lt;/em&gt; 为节点所组成的&lt;strong&gt;二叉搜索树&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="动态规划" scheme="https://liuyang0001.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>94-二叉树的中序遍历</title>
    <link href="https://liuyang0001.github.io/2020/04/01/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://liuyang0001.github.io/2020/04/01/94-二叉树的中序遍历/</id>
    <published>2020-04-01T07:56:56.000Z</published>
    <updated>2020-04-01T09:23:10.931Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用递归算法即可</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，返回它的&lt;em&gt;中序&lt;/em&gt; 遍历。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://liuyang0001.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>93-复原ip地址</title>
    <link href="https://liuyang0001.github.io/2020/04/01/93-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/"/>
    <id>https://liuyang0001.github.io/2020/04/01/93-复原ip地址/</id>
    <published>2020-04-01T07:52:04.000Z</published>
    <updated>2020-04-01T09:20:22.717Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;25525511135&quot;</span><br><span class="line">输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：回溯算法：利用分割4次之后剩余的字符串是否为空，来界定是不是有效的结果</strong></p><p><strong>count记录分割次数, ip记录当前的字符串, s记录剩余字符串</strong></p><p><strong>注意：分割一次加一个“.”，最后会多出一个点号</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># count记录分割次数, ip记录当前的字符串, s记录剩余字符串</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(count, ip, s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> s==<span class="string">""</span>: <span class="comment"># 最后面会有个点号</span></span><br><span class="line">                    res.append(ip[:<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">0</span>: <span class="comment"># 需考虑[0.0.0.0]的情况</span></span><br><span class="line">                backtrack(count + <span class="number">1</span>, ip + s[:<span class="number">1</span>] + <span class="string">"."</span>, s[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">"0"</span>:</span><br><span class="line">                backtrack(count + <span class="number">1</span>, ip + s[:<span class="number">2</span>] + <span class="string">"."</span>, s[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">2</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">"0"</span> <span class="keyword">and</span> int(s[:<span class="number">3</span>]) &lt; <span class="number">256</span>:</span><br><span class="line">                backtrack(count + <span class="number">1</span>, ip + s[:<span class="number">3</span>] + <span class="string">"."</span>, s[<span class="number">3</span>:])</span><br><span class="line">                </span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="string">""</span>, s)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/restore-ip-addresses/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>92-反转链表</title>
    <link href="https://liuyang0001.github.io/2020/04/01/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://liuyang0001.github.io/2020/04/01/92-反转链表/</id>
    <published>2020-04-01T07:49:17.000Z</published>
    <updated>2020-04-01T09:14:16.193Z</updated>
    
    <content type="html"><![CDATA[<p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p><a id="more"></a><p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：需要翻转的部分使用头插法即可</strong></p><p><strong>技巧：在原链表添加一个头部，更便于操作</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="comment"># 找到翻转链表部分的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="comment"># print("pre:", pre.val)</span></span><br><span class="line">        rear1 = pre <span class="comment"># 翻转部分的前一个结点</span></span><br><span class="line">        rear2 = pre.next <span class="comment"># 翻转部分的第一个结点，翻转后为尾结点</span></span><br><span class="line">        cur_node = pre.next</span><br><span class="line">        <span class="comment"># 翻转部分的头结点</span></span><br><span class="line">        dummy2 = ListNode(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n-m+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 头插法翻转链表</span></span><br><span class="line">            save_node = cur_node.next</span><br><span class="line">            cur_node.next = dummy2.next</span><br><span class="line">            dummy2.next = cur_node</span><br><span class="line">            cur_node = save_node</span><br><span class="line">        <span class="comment"># 拼接</span></span><br><span class="line">        rear2.next = cur_node</span><br><span class="line">        rear1.next = dummy2.next</span><br><span class="line">        <span class="comment"># head结点可能已经改变，返回头结点的下一节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转从位置 &lt;em&gt;m&lt;/em&gt; 到 &lt;em&gt;n&lt;/em&gt; 的链表。请使用一趟扫描完成反转。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>91-解码方法</title>
    <link href="https://liuyang0001.github.io/2020/04/01/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>https://liuyang0001.github.io/2020/04/01/91-解码方法/</id>
    <published>2020-04-01T07:31:17.000Z</published>
    <updated>2020-04-01T09:10:53.293Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包含数字的<strong>非空</strong>字符串，请计算解码方法的总数。</p><a id="more"></a><p>一条包含字母 <code>A-Z</code> 的消息通过以下方式进行了编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;12&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;226&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用动态规划的思想，利用前两位来更新当前位置</strong></p></blockquote><p><strong>算法设计如下：</strong></p><ul><li><p>特判，若s为空或者s[0]==”0”，返回0</p></li><li><p>初始化dp=[0,…,0]，长度为n+1，dp[0]=1,dp[1]=1。dp[1]=1表示第一位的解码方法，dp[0]的作用，在于两位时，如：”12”，dp[2]=dp[1]+dp[0]。</p></li><li><p>遍历s，遍历区间[1,n)：</p><ul><li>若s[i]==”0”：<ul><li>若<code>s[i-1]==&quot;1&quot; or s[i-1]==&quot;2&quot;</code>：<ul><li>此时，到当前位置的解码方法dp[i+1]和上上一位的相同，</li><li>因为上一位和本位置结合在了一起。dp[i+1]=dp[i-1]</li></ul></li><li>否则，返回0，表示无法解码</li></ul></li><li>否则：<ul><li>判断何时既可以自身解码也可以和前一位结合：</li><li>若上一位s[i-1]==”1”，则当前位既可以单独解码也可以和上一位结合。</li><li>或者上一位s[i]==”2”，则此时，若1”&lt;=s[i]&lt;=”6”，也是可以的。</li><li>综上，<code>s[i-1]==&quot;1&quot; or (s[i-1]==&quot;2&quot; and &quot;1&quot;&lt;=s[i]&lt;=&quot;6&quot;)</code>。</li><li>此时，dp[i+1]=dp[i]+dp[i-1]，等于上一位和上上位的解码方法之和。</li><li>否则，dp[i+1]=dp[i]</li></ul></li></ul></li><li><p>返回dp[n]</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">"0"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">"0"</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">"1"</span> <span class="keyword">or</span> s[i - <span class="number">1</span>] == <span class="string">"2"</span>:</span><br><span class="line">                    dp[i + <span class="number">1</span>] = dp[i - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">"1"</span> <span class="keyword">or</span> (s[i - <span class="number">1</span>] == <span class="string">"2"</span> <span class="keyword">and</span> <span class="string">"1"</span> &lt;= s[i] &lt;= <span class="string">"6"</span>):</span><br><span class="line">                    dp[i + <span class="number">1</span>] = dp[i] + dp[i - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i + <span class="number">1</span>] = dp[i]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/decode-ways/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/decode-ways/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个只包含数字的&lt;strong&gt;非空&lt;/strong&gt;字符串，请计算解码方法的总数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="动态规划" scheme="https://liuyang0001.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>90-子集II</title>
    <link href="https://liuyang0001.github.io/2020/03/30/90-%E5%AD%90%E9%9B%86II/"/>
    <id>https://liuyang0001.github.io/2020/03/30/90-子集II/</id>
    <published>2020-03-30T10:45:31.000Z</published>
    <updated>2020-03-30T15:37:01.540Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p><a id="more"></a><p><strong>说明：</strong>解集不能包含重复的子集。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用回溯算法，</strong></p><p><strong>关键点：去重—-&gt;【排序+当前值与上一个值判断】</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(index, tem)</span>:</span></span><br><span class="line">            res.append(tem)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, n):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                backtrack(i + <span class="number">1</span>, tem + [nums[i]])</span><br><span class="line">        backtrack(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/subsets-ii/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/subsets-ii/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个可能包含重复元素的整数数组 &lt;strong&gt;&lt;em&gt;nums&lt;/em&gt;&lt;/strong&gt;，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>89-格雷编码</title>
    <link href="https://liuyang0001.github.io/2020/03/30/89-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"/>
    <id>https://liuyang0001.github.io/2020/03/30/89-格雷编码/</id>
    <published>2020-03-30T10:43:52.000Z</published>
    <updated>2020-03-30T15:33:22.782Z</updated>
    
    <content type="html"><![CDATA[<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 <em>n</em>，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,3,2]</span><br><span class="line">解释:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br><span class="line"></span><br><span class="line">对于给定的 n，其格雷编码序列并不唯一。</span><br><span class="line">例如，[0,2,3,1] 也是一个有效的格雷编码序列。</span><br><span class="line"></span><br><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 0 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。</span><br><span class="line">     因此，当 n = 0 时，其格雷编码序列为 [0]。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：第n个格雷码：G(n) = (n&gt;&gt;1) OXR n，即最高位保留，其他位相异或</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span> ** n):</span><br><span class="line">            <span class="comment"># 最高位保留，其他位异或操作</span></span><br><span class="line">            res.append(i ^ (i &gt;&gt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/gray-code/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/gray-code/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。&lt;/p&gt;
&lt;p&gt;给定一个代表编码总位数的非负整数 &lt;em&gt;n&lt;/em&gt;，打印其格雷编码序列。格雷编码序列必须以 0 开头。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="https://liuyang0001.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>88-合并两个有序数组</title>
    <link href="https://liuyang0001.github.io/2020/03/30/88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://liuyang0001.github.io/2020/03/30/88-合并两个有序数组/</id>
    <published>2020-03-30T10:41:42.000Z</published>
    <updated>2020-03-30T12:29:49.129Z</updated>
    
    <content type="html"><![CDATA[<p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，请你将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>num1</em> 成为一个有序数组。</p><a id="more"></a><p><strong>说明:</strong></p><ul><li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em> 。</li><li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：先合并，在排序。</strong></p><p><strong>坑：有的0有效有的0无效，所以第一个列表有效部分直接取[:-m]</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums2)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        nums =nums1[:-n] + nums2</span><br><span class="line">        nums1[:] = sorted(nums)</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/merge-sorted-array/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你两个有序整数数组 &lt;em&gt;nums1&lt;/em&gt; 和 &lt;em&gt;nums2&lt;/em&gt;，请你将 &lt;em&gt;nums2&lt;/em&gt; 合并到 &lt;em&gt;nums1&lt;/em&gt; 中&lt;em&gt;，&lt;/em&gt;使 &lt;em&gt;num1&lt;/em&gt; 成为一个有序数组。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>86-分隔链表</title>
    <link href="https://liuyang0001.github.io/2020/03/30/86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://liuyang0001.github.io/2020/03/30/86-分隔链表/</id>
    <published>2020-03-30T10:38:20.000Z</published>
    <updated>2020-03-30T11:23:05.084Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：x为边界，拆分成两个链表处理，最后在合在一起即可。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        p = head</span><br><span class="line">        p1 = head1 = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p2 = head2 = ListNode(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">while</span> p != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; x:</span><br><span class="line">                p1.next = p</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.next = p</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        p1.next = head2.next</span><br><span class="line">        p2.next = <span class="keyword">None</span> <span class="comment"># 尾边界</span></span><br><span class="line">        <span class="keyword">del</span> head2</span><br><span class="line">        <span class="keyword">return</span> head1.next</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/partition-list/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/partition-list/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表和一个特定值 &lt;em&gt;x&lt;/em&gt;，对链表进行分隔，使得所有小于 &lt;em&gt;x&lt;/em&gt; 的节点都在大于或等于 &lt;em&gt;x&lt;/em&gt; 的节点之前。&lt;/p&gt;
&lt;p&gt;你应当保留两个分区中每个节点的初始相对位置。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>84-柱状图中的最大矩形</title>
    <link href="https://liuyang0001.github.io/2020/03/30/84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>https://liuyang0001.github.io/2020/03/30/84-柱状图中的最大矩形/</id>
    <published>2020-03-30T10:33:48.000Z</published>
    <updated>2020-03-30T11:21:35.307Z</updated>
    
    <content type="html"><![CDATA[<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="img"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="img"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：遍历寻找以第i根柱子为最高柱子所能延伸的最大面积</strong></p><p><strong>即   找栈顶左右两边第一个比栈顶小的元素，【利用“单调栈”】</strong></p><p><strong>巧妙地点：在两侧加上0柱子便于处理边界</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="comment"># 在原柱子两端加上两个高度为0的柱子，便于计算边界</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历：以第i根柱子为最高柱子所能延伸的最大面积</span></span><br><span class="line">        <span class="comment"># 即   找栈顶左右两边第一个比栈顶小的元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="comment"># print(stack)</span></span><br><span class="line">            <span class="comment"># 调整位置</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]] &gt; heights[i]:</span><br><span class="line">                tmp = stack.pop()</span><br><span class="line">                res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[tmp])</span><br><span class="line">            <span class="comment"># 当前元素无论如何也要放进去，不同的只是需不需要pop来调整位置</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
&lt;p&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="栈" scheme="https://liuyang0001.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>83-删除排序链表中的重复元素</title>
    <link href="https://liuyang0001.github.io/2020/03/30/83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://liuyang0001.github.io/2020/03/30/83-删除排序链表中的重复元素/</id>
    <published>2020-03-30T10:30:35.000Z</published>
    <updated>2020-03-30T11:17:49.963Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用双指针，跳过重复的结点</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">and</span> head.next:</span><br><span class="line">            pre = head</span><br><span class="line">            p = head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> pre.val == p.val:</span><br><span class="line">                pre.next = p.next</span><br><span class="line">                p = p.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = pre.next</span><br><span class="line">                p = p.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>82-删除排序链表中的重复元素II</title>
    <link href="https://liuyang0001.github.io/2020/03/30/82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>https://liuyang0001.github.io/2020/03/30/82-删除排序链表中的重复元素II/</id>
    <published>2020-03-30T10:24:14.000Z</published>
    <updated>2020-03-30T11:16:31.747Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">输出: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">输出: 2-&gt;3</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：1.转换成列表 2.利用counter()计数3.将计数为1的重新构建链表</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        ls = []</span><br><span class="line">        p = head</span><br><span class="line">        <span class="comment"># 先将所有结点值扫描进列表</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            ls.append(p.val)</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="comment"># 利用Counter进行计数</span></span><br><span class="line">        nums_dict = Counter(ls)</span><br><span class="line">        H = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p = H</span><br><span class="line">        <span class="comment"># 将所有value值为1的重新建立结点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums_dict.keys():</span><br><span class="line">            <span class="keyword">if</span> nums_dict[i] == <span class="number">1</span>:</span><br><span class="line">                p.next = ListNode(i)</span><br><span class="line">                p = p.next</span><br><span class="line">        <span class="keyword">return</span> H.next</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 &lt;em&gt;没有重复出现&lt;/em&gt; 的数字。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>81-搜索旋转排序数组II</title>
    <link href="https://liuyang0001.github.io/2020/03/30/81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/"/>
    <id>https://liuyang0001.github.io/2020/03/30/81-搜索旋转排序数组II/</id>
    <published>2020-03-30T10:22:15.000Z</published>
    <updated>2020-03-30T10:51:40.374Z</updated>
    
    <content type="html"><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,0,1,2,2,5,6]</code> 可能变为 <code>[2,5,6,0,0,1,2]</code> )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 <code>true</code>，否则返回 <code>false</code>。</p><a id="more"></a><p><strong>进阶:</strong></p><ul><li>这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">搜索旋转排序数组</a> 的延伸题目，本题中的 <code>nums</code> 可能包含重复元素。</li><li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：采用二分查找的思想，判断在那一部分出现完整的升序序列，</strong></p><p><strong>需要注意的点：可能存在l=r=mid的情况</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        mid, left, right = <span class="number">0</span>, <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 二分法</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 找到该点索引值</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="comment"># 出现重复值，如[1,2,1,1,1]情况</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == nums[mid] == nums[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 旋转点T在mid右区间</span></span><br><span class="line">            <span class="comment"># [left......mid....T....right]</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="comment"># target在[left,mid)的升序空间中</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="comment"># target在(mid,T]或者[T,right]中</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 旋转点T在mid左区间</span></span><br><span class="line">            <span class="comment"># [left...T...mid........right]</span></span><br><span class="line">            <span class="keyword">elif</span> nums[left] &gt; nums[mid]:</span><br><span class="line">                <span class="comment"># target在(mid,right]的升序空间中</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="comment"># target在[left,T]或者[T，mid)</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">        <span class="comment"># 未找到该点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,0,1,2,2,5,6]&lt;/code&gt; 可能变为 &lt;code&gt;[2,5,6,0,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="https://liuyang0001.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>80-删除排序数组中的重复项II</title>
    <link href="https://liuyang0001.github.io/2020/03/27/80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/"/>
    <id>https://liuyang0001.github.io/2020/03/27/80-删除排序数组中的重复项II/</id>
    <published>2020-03-27T09:11:44.000Z</published>
    <updated>2020-03-27T09:16:19.586Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组，你需要在<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><a id="more"></a><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [1,1,1,2,2,3],</span><br><span class="line"></span><br><span class="line">函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,1,2,3,3],</span><br><span class="line"></span><br><span class="line">函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用双指针，一快一慢，快指针用于遍历，慢指针用于确定新数组的尾端。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 双指针+计数器</span></span><br><span class="line">        count = <span class="number">1</span>  <span class="comment"># 元素出现的次数</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        L, R = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> R &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[R] == nums[R<span class="number">-1</span>]:  <span class="comment"># 出现重复元素，记录出现的次数</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = <span class="number">1</span>  <span class="comment"># 若不是重复元素，重置计数器</span></span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">2</span>:  <span class="comment"># 若只有2个及以下的重复元素，移动L</span></span><br><span class="line">                nums[L] = nums[R]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            R += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个排序数组，你需要在&lt;strong&gt;&lt;a href=&quot;http://baike.baidu.com/item/原地算法&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原地&lt;/a&gt;&lt;/strong&gt;删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/原地算法&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原地&lt;/a&gt;修改输入数组&lt;/strong&gt;并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>79-单词搜索</title>
    <link href="https://liuyang0001.github.io/2020/03/27/79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>https://liuyang0001.github.io/2020/03/27/79-单词搜索/</id>
    <published>2020-03-27T09:04:09.000Z</published>
    <updated>2020-03-27T09:10:02.985Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><a id="more"></a><p><strong>提示：</strong></p><ul><li><code>board</code> 和 <code>word</code> 中只包含大写和小写英文字母。</li><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li><li><code>1 &lt;= word.length &lt;= 10^3</code></li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = &quot;ABCCED&quot;, 返回 true</span><br><span class="line">给定 word = &quot;SEE&quot;, 返回 true</span><br><span class="line">给定 word = &quot;ABCB&quot;, 返回 false</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：使用回溯算法（dfs），寻找当前字母的上下左右是否存在符合条件的单词，找不到就返回上一层</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        row = len(board)</span><br><span class="line">        col = len(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__dfs</span><span class="params">(i, j, wd_len, visited)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> wd_len == len(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)]:</span><br><span class="line">                tem_i = x + i</span><br><span class="line">                tem_j = y + j</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= tem_i &lt; row <span class="keyword">and</span> <span class="number">0</span> &lt;= tem_j &lt; col \</span><br><span class="line">                        <span class="keyword">and</span> board[tem_i][tem_j] == word[wd_len] \</span><br><span class="line">                    <span class="keyword">and</span> (tem_i, tem_j) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add((tem_i, tem_j))</span><br><span class="line">                    <span class="keyword">if</span> __dfs(tem_i, tem_j, wd_len+<span class="number">1</span>, visited):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    visited.remove((tem_i, tem_j))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>] <span class="keyword">and</span> __dfs(i, j, <span class="number">1</span>, &#123;(i, j)&#125;):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/word-search/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/word-search/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。&lt;/p&gt;
&lt;p&gt;单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>78-子集</title>
    <link href="https://liuyang0001.github.io/2020/03/27/78-%E5%AD%90%E9%9B%86/"/>
    <id>https://liuyang0001.github.io/2020/03/27/78-子集/</id>
    <published>2020-03-27T08:56:08.000Z</published>
    <updated>2020-03-27T09:03:35.835Z</updated>
    
    <content type="html"><![CDATA[<p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><a id="more"></a><p><strong>说明：</strong>解集不能包含重复的子集。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用回溯算法，每添加一个数字，加到res一次</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># 回溯函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(index, tem)</span>:</span></span><br><span class="line">            res.append(tem)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index,n):</span><br><span class="line">                backtrack(i+<span class="number">1</span>, tem+[nums[i]])</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/subsets/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/subsets/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一组&lt;strong&gt;不含重复元素&lt;/strong&gt;的整数数组 &lt;em&gt;nums&lt;/em&gt;，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="位操作" scheme="https://liuyang0001.github.io/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
</feed>
