<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Liu&#39;s Tech Blog</title>
  
  <subtitle>Python技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuyang0001.github.io/"/>
  <updated>2020-01-12T10:28:47.363Z</updated>
  <id>https://liuyang0001.github.io/</id>
  
  <author>
    <name>Liu Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>12-整数转罗马数字</title>
    <link href="https://liuyang0001.github.io/2020/01/12/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>https://liuyang0001.github.io/2020/01/12/12-整数转罗马数字/</id>
    <published>2020-01-12T07:38:42.000Z</published>
    <updated>2020-01-12T10:28:47.363Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><a id="more"></a><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">数值</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">V</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">X</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">50</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">500</td></tr><tr><td style="text-align:left">M</td><td style="text-align:left">1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。 |<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下<strong>六种情况：</strong> </p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p><hr></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：使用贪心算法</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        num_dict = &#123;<span class="number">1</span>: <span class="string">'I'</span>,</span><br><span class="line">                    <span class="number">4</span>: <span class="string">'IV'</span>,</span><br><span class="line">                    <span class="number">5</span>: <span class="string">'V'</span>,</span><br><span class="line">                    <span class="number">9</span>: <span class="string">'IX'</span>,</span><br><span class="line">                    <span class="number">10</span>: <span class="string">'X'</span>,</span><br><span class="line">                    <span class="number">40</span>: <span class="string">'XL'</span>,</span><br><span class="line">                    <span class="number">50</span>: <span class="string">'L'</span>,</span><br><span class="line">                    <span class="number">90</span>: <span class="string">'XC'</span>,</span><br><span class="line">                    <span class="number">100</span>: <span class="string">'C'</span>,</span><br><span class="line">                    <span class="number">400</span>: <span class="string">'CD'</span>,</span><br><span class="line">                    <span class="number">500</span>: <span class="string">'D'</span>,</span><br><span class="line">                    <span class="number">900</span>: <span class="string">'CM'</span>,</span><br><span class="line">                    <span class="number">1000</span>: <span class="string">'M'</span>&#125;</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 贪心算法，将字典逆置，从大的开始除</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> sorted(num_dict.keys())[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            tmp = num//key</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += num_dict[key] * (tmp)</span><br><span class="line">            <span class="comment"># 更新num值</span></span><br><span class="line">            num -= key*(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心算法" scheme="https://liuyang0001.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>11-盛最多水的容器</title>
    <link href="https://liuyang0001.github.io/2020/01/11/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>https://liuyang0001.github.io/2020/01/11/11-盛最多水的容器/</id>
    <published>2020-01-11T06:46:00.000Z</published>
    <updated>2020-01-11T06:54:35.842Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><a id="more"></a><blockquote><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p></blockquote><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt=""></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><hr></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line"></span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure><p><hr></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：只有相对短的一边向内收缩才有可能使得面积变大</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        left, right, res = <span class="number">0</span>, len(height)<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right):</span><br><span class="line">            <span class="comment"># 判断是否需要更新最大面积</span></span><br><span class="line">            <span class="keyword">if</span> min(height[left], height[right])*(right-left) &gt; res:</span><br><span class="line">                res = min(height[left], height[right]) * (right - left)</span><br><span class="line">            <span class="comment"># 使得短的一端向内收缩</span></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>10-正则表达式匹配</title>
    <link href="https://liuyang0001.github.io/2020/01/10/10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>https://liuyang0001.github.io/2020/01/10/10-正则表达式匹配/</id>
    <published>2020-01-10T14:59:41.000Z</published>
    <updated>2020-01-10T15:33:05.212Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><a id="more"></a><table><thead><tr><th>字符</th><th>匹配规则</th></tr></thead><tbody><tr><td>.</td><td>匹配任意单个字符</td></tr><tr><td>*</td><td>匹配零个或多个前面的那一个元素</td></tr></tbody></table><p><strong>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</strong></p><blockquote><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。</p><p>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p></blockquote><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;aa&quot;p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;aa&quot;p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;ab&quot;p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;aab&quot;p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, text: str, pattern: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 递归边界：</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pattern: </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> text</span><br><span class="line">        <span class="comment"># text 非空并且p[0]==s[0]或者“.”</span></span><br><span class="line">        first = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] <span class="keyword">in</span> &#123;text[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line">        <span class="comment"># 处理带星号的问题</span></span><br><span class="line">        <span class="keyword">if</span> len(pattern) &gt;= <span class="number">2</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(text, pattern[<span class="number">2</span>:]) <span class="keyword">or</span> first <span class="keyword">and</span> self.isMatch(text[<span class="number">1</span>:], pattern)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 正常递归</span></span><br><span class="line">            <span class="keyword">return</span> first <span class="keyword">and</span> self.isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>9-回文数</title>
    <link href="https://liuyang0001.github.io/2020/01/09/9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>https://liuyang0001.github.io/2020/01/09/9-回文数/</id>
    <published>2020-01-09T02:25:44.000Z</published>
    <updated>2020-01-09T02:36:40.402Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>直接转换成字符串对比即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> str(x)==str(x)[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>8-字符串转换整数</title>
    <link href="https://liuyang0001.github.io/2020/01/08/8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"/>
    <id>https://liuyang0001.github.io/2020/01/08/8-字符串转换整数/</id>
    <published>2020-01-08T05:20:29.000Z</published>
    <updated>2020-01-08T06:28:03.667Z</updated>
    
    <content type="html"><![CDATA[<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><a id="more"></a><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><blockquote><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p></blockquote><p><strong>在任何情况下，若函数不能进行有效的转换时，请返回 0。</strong></p><blockquote><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;  -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line"></span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line"></span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line"></span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure><h2 id="解法-常规"><a href="#解法-常规" class="headerlink" title="解法-常规"></a>解法-常规</h2><p>该题解法很容易想到，只是有很多小细节需要注意。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        str_ = s.strip()  <span class="comment"># 去掉字符串的空白</span></span><br><span class="line">        <span class="keyword">if</span> len(str_) == <span class="number">0</span>:  <span class="comment"># 空字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums_ls = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        symbols_ls = [<span class="string">"-"</span>, <span class="string">"+"</span>]</span><br><span class="line">        <span class="comment"># 判断首个字符</span></span><br><span class="line">        <span class="keyword">if</span> str_[<span class="number">0</span>]<span class="keyword">not</span> <span class="keyword">in</span> nums_ls <span class="keyword">and</span> str_[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> symbols_ls:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = str_[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 判断后面的字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> str_[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> nums_ls:</span><br><span class="line">                res += i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">try</span>: <span class="comment"># 只有正负号时，返回0</span></span><br><span class="line">            res = int(res)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># if res &gt; 2147483647:</span></span><br><span class="line">        <span class="comment">#     return 2147483647</span></span><br><span class="line">        <span class="comment"># elif res &lt; -2147483648:</span></span><br><span class="line">        <span class="comment">#     return -2147483648</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     return res</span></span><br><span class="line">        <span class="comment"># 功能同上面注释部分，不过更加优雅</span></span><br><span class="line">        <span class="keyword">return</span> min(max(res, <span class="number">-2147483648</span>), <span class="number">2147483647</span>)</span><br></pre></td></tr></table></figure><h2 id="解法-正则"><a href="#解法-正则" class="headerlink" title="解法-正则"></a>解法-正则</h2><p>利用正则表达式，来提取有效字符串。</p><table><thead><tr><th>正则</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开头</td></tr><tr><td>[+-]</td><td>代表一个+字符或-字符</td></tr><tr><td>?</td><td>前面一个字符可有可无</td></tr><tr><td>\d</td><td>一个数字</td></tr><tr><td>+</td><td>前面一个字符的一个或多个</td></tr><tr><td>*</td><td>前面一个字符的零个或多个</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> max(min(int(*re.findall(<span class="string">'^[\+\-]?\d+'</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), <span class="number">-2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>7-整数反转</title>
    <link href="https://liuyang0001.github.io/2020/01/07/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>https://liuyang0001.github.io/2020/01/07/7-整数反转/</id>
    <published>2020-01-07T08:17:26.000Z</published>
    <updated>2020-01-07T08:32:40.572Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思路：int -&gt; abs(int) -&gt; str[::-1] -&gt; int</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        y = abs(x)</span><br><span class="line">        k = int(str(y)[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">2147483647</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> k*(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode刷题笔记</title>
    <link href="https://liuyang0001.github.io/2020/01/07/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://liuyang0001.github.io/2020/01/07/Leetcode刷题笔记/</id>
    <published>2020-01-07T06:54:39.000Z</published>
    <updated>2020-01-07T07:16:14.461Z</updated>
    
    <content type="html"><![CDATA[<p>所有刷题笔记内容的汇总，与个人总结。</p><a id="more"></a><hr><table><thead><tr><th style="text-align:center">#</th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">源码文件</th><th style="text-align:center">博客文章</th></tr></thead><tbody><tr><td style="text-align:center">001</td><td style="text-align:center">两数之和</td><td style="text-align:center">简单</td><td style="text-align:center">数组；哈希表</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/1_TwoSum.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/02/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/">:memo:</a></td></tr><tr><td style="text-align:center">002</td><td style="text-align:center">两数相加</td><td style="text-align:center">中等</td><td style="text-align:center">链表；数学</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/2_AddTwoNumbers.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/03/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/">:memo:</a></td></tr><tr><td style="text-align:center">003</td><td style="text-align:center">无重复字符的最长子串</td><td style="text-align:center">中等</td><td style="text-align:center">字符串；滑动窗口</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/3_LengthOfLongestSubstring.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/03/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">:memo:</a></td></tr><tr><td style="text-align:center">004</td><td style="text-align:center">寻找两个有序数组的中位数</td><td style="text-align:center">困难</td><td style="text-align:center">数组；分治算法</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/4_findMedianSortedArrays.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/04/4-寻找两个有序数组的中位数/">:memo:</a></td></tr><tr><td style="text-align:center">005</td><td style="text-align:center">最长回文子串</td><td style="text-align:center">中等</td><td style="text-align:center">字符串；动态规划；中心扩展</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/5_longestPalindrome.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/05/5-最长回文子串/">:memo:</a></td></tr><tr><td style="text-align:center">006</td><td style="text-align:center">Z字形变换</td><td style="text-align:center">中等</td><td style="text-align:center">字符串</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/6_convert.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/06/6-Z字形变换/">:memo:</a></td></tr><tr><td style="text-align:center">007</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">008</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有刷题笔记内容的汇总，与个人总结。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>6.Z字形变换</title>
    <link href="https://liuyang0001.github.io/2020/01/06/6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>https://liuyang0001.github.io/2020/01/06/6-Z字形变换/</id>
    <published>2020-01-06T10:10:21.000Z</published>
    <updated>2020-01-06T10:29:26.943Z</updated>
    
    <content type="html"><![CDATA[<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><a id="more"></a><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>Key Point：</strong>巧妙利用flag实现触碰到边界时进行“<strong>回弹</strong>”的效果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows&lt;<span class="number">2</span>: <span class="comment"># 该算法在小于2时，直接返回即可</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 初始化一个长度为numRows的列表</span></span><br><span class="line">        ls = [<span class="string">""</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numRows)]</span><br><span class="line">        flag, i = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> string <span class="keyword">in</span> s:</span><br><span class="line">            ls[i] += string</span><br><span class="line">            <span class="comment"># i等于0或者numRows-1时，改变方向</span></span><br><span class="line">            <span class="keyword">if</span> i % (numRows<span class="number">-1</span>) == <span class="number">0</span>:</span><br><span class="line">                flag = -flag</span><br><span class="line">            i += flag</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(ls)</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/zigzag-conversion" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>5.最长回文子串</title>
    <link href="https://liuyang0001.github.io/2020/01/05/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://liuyang0001.github.io/2020/01/05/5-最长回文子串/</id>
    <published>2020-01-05T06:14:37.000Z</published>
    <updated>2020-01-05T11:53:38.839Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="1-中心扩展"><a href="#1-中心扩展" class="headerlink" title="1-中心扩展"></a>1-中心扩展</h3><p>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。</p><p><img src="https://pic.leetcode-cn.com/1b9bfe346a4a9a5718b08149be11236a6db61b3922265d34f22632d4687aa0a8-image.png" alt=""></p><p>由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 <code>n+n-1</code> 个中心。</p><p><strong>时间复杂度：O<em>(</em>n<em>²）   空间复杂度：O(1）</em></strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 中心扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expandAroundCenter</span><span class="params">(self,s: str,left:int,right:int)</span> -&gt; str:</span></span><br><span class="line">        L, R = left, right</span><br><span class="line">        <span class="keyword">while</span> L&gt;= <span class="number">0</span> <span class="keyword">and</span> R&lt; len(s) <span class="keyword">and</span> s[L]==s[R]:</span><br><span class="line">            L -= <span class="number">1</span></span><br><span class="line">            R += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[L+<span class="number">1</span>:R]</span><br><span class="line">    <span class="comment"># 求最长回文子串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>: <span class="comment"># 长度小于等于1直接返回原字符串</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        res = s[:<span class="number">1</span>] <span class="comment"># 初始化result为字符串首位</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            len1 = self.expandAroundCenter(s, i, i)</span><br><span class="line">            len2 = self.expandAroundCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 迭代res使其成为最长的子串</span></span><br><span class="line">            res = max(len1,len2,res,key=len)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="2-马拉车算法（Manacher’s-Algorithm）"><a href="#2-马拉车算法（Manacher’s-Algorithm）" class="headerlink" title="2-马拉车算法（Manacher’s Algorithm）"></a>2-马拉车算法（Manacher’s Algorithm）</h3><p>Manacher‘s Algorithm是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p><p>首先我们解决下奇数和偶数的问题，在每个字符间插入 “#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。</p><p><img src="https://pic.leetcode-cn.com/ad2b5e0da4a3a35b60f60c9a5a2be07a8074f9be0fe1597351eeff7dc460789a-image.png" alt=""></p><p>首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 “#” 的原字符串的总长度。例如下图中下标是 6 的地方，可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 “#c#b#c#b#c#”。而去掉 # 恢复到原来的字符串，变成 “cbcbc”，它的长度刚好也就是 5。</p><p><img src="https://pic.leetcode-cn.com/ae2c30d48d35faa7f3d0d8bc4fe18d0691f3d13dcfc5846ddce1bf7a002681f5-image.png" alt=""></p><p><strong>求原字符串下标</strong><br>用 P 的下标 i 减去 P [ i ]，再除以 2，就是原字符串的开头下标了。</p><p>例如我们找到 P[ i ] 的最大值为 5，也就是回文串的最大长度是 5，对应的下标是 6，所以原字符串的开头下标是（6 - 5 ）/ 2 = 0。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。</p><p><strong>求每个 P [ i ]</strong><br>接下来是算法的关键了，它充分利用了回文串的对称性。</p><p>我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。</p><p>让我们考虑求 P [ i ] 的时候，如下图。</p><p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。</p><p><img src="https://pic.leetcode-cn.com/29eb66280ca149c3bf5d9906e066b4a2b39d1bf8f9dd0533ca00479aca6f4f39-image.png" alt=""></p><p>我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。</p><p>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。</p><ol><li><strong>超出了 R</strong></li></ol><p><img src="https://pic.leetcode-cn.com/b0d52a5f30747e55ef09b3c7b7cfc23026e37040edc41f387263e8f8a0ba8f49-image.png" alt=""></p><p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p><ol><li><strong>P [ i_mirror ] 遇到了原字符串的左边界</strong></li></ol><p><img src="https://pic.leetcode-cn.com/714e6f768e67304fb7162ecac3ae85fcf23ad82a21456e8ca55ac2c8cfd2609e-image.png" alt=""></p><p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#”，之后遇到了 “^” 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p><ol><li><strong>i 等于了 R</strong><br>此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。</li></ol><p><strong>考虑 C 和 R 的更新</strong><br>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p><p><img src="https://pic.leetcode-cn.com/5fbe52880634a9d5fa60ad5e126e8c5c38c5a6eadd0c901a3495dc1307d46d6b-image.png" alt=""></p><p>此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。</p><p>作者：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/" target="_blank" rel="noopener">windliang|链接地址</a></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 马拉车算法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 将一个可能是偶数长/奇数长的字符串，首位以及每个字符间添加#</span></span><br><span class="line">        test = <span class="string">'#'</span>+<span class="string">'#'</span>.join(s)+<span class="string">'#'</span></span><br><span class="line">        <span class="comment"># 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(test)):</span><br><span class="line">            left = i - <span class="number">1</span></span><br><span class="line">            right = i + <span class="number">1</span></span><br><span class="line">            step = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(test) <span class="keyword">and</span> test[left] == test[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 找到合适的起点位置</span></span><br><span class="line">            <span class="keyword">if</span> step &gt; max_len:</span><br><span class="line">                max_len = step</span><br><span class="line">                start = (i - max_len) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="动态规划" scheme="https://liuyang0001.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="中心扩展" scheme="https://liuyang0001.github.io/tags/%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>4.寻找两个有序数组的中位数</title>
    <link href="https://liuyang0001.github.io/2020/01/04/4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://liuyang0001.github.io/2020/01/04/4-寻找两个有序数组的中位数/</id>
    <published>2020-01-04T08:35:37.000Z</published>
    <updated>2020-01-07T06:54:51.724Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line"></span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line"></span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p><strong>分别在num1和num2切割，找到满足Lmax1&lt;Rmin2且Lmax2&lt;Rmin的位置。</strong></p><h3 id="奇偶问题"><a href="#奇偶问题" class="headerlink" title="奇偶问题"></a>奇偶问题</h3><p>两个数组合并后的长度，有可能是偶数，也有可能是奇数。如果可以让数组长度总是为偶数，那么就可以用公式覆盖。</p><p>通过虚拟加入<code>&quot;#&quot;</code>，让每个数组的长度都变成 2x + 1，所以 <code>n+m -&gt; 2n + 2m + 2</code>，恒为<strong>偶数</strong>。</p><p>转换后，<strong>原始的元素可以通过新下标//2得到。</strong></p><p><img src="https://pic.leetcode-cn.com/9e95202ed9e3fbad08971f69e9212b817750e05d6d6cece656cda25385f04a1e-image.png" alt=""></p><p>比如9，原来是3位，现在是7位， 7//2=3</p><p>而对于割，如果<code>‘#’</code>上等于割在2个元素之间，割在数字上等于把数字划到2个部分，总是有以下成立：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LMaxi = (Ci-1)/2 位置上的元素</span><br><span class="line">RMini = Ci/2 位置上的元素</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/ji-yu-bian-bian-xiong-de-shuo-ming-xue-xi-hou-shi-/" target="_blank" rel="noopener">点击查看详细</a></p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        <span class="comment"># 使得num2成为更长的表</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; m:</span><br><span class="line">            <span class="keyword">return</span> self.findMedianSortedArrays(nums2, nums1)</span><br><span class="line"></span><br><span class="line">        start_pos = <span class="number">0</span></span><br><span class="line">        end_pos = <span class="number">2</span> * m</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start_pos &lt;= end_pos:</span><br><span class="line">            c1 = (start_pos + end_pos) // <span class="number">2</span></span><br><span class="line">            c2 = m + n - c1  <span class="comment"># 因为数组从0开始，所以c1+c2=(m+n+1)-1</span></span><br><span class="line">            <span class="comment"># 切割nums1</span></span><br><span class="line">            LMax1 = nums1[(c1 - <span class="number">1</span>) // <span class="number">2</span>] <span class="keyword">if</span> c1 &gt; <span class="number">0</span> <span class="keyword">else</span> (<span class="number">-1</span> * sys.maxsize)</span><br><span class="line">            RMin1 = nums1[c1 // <span class="number">2</span>] <span class="keyword">if</span> c1 &lt; <span class="number">2</span> * n <span class="keyword">else</span> sys.maxsize</span><br><span class="line">            <span class="comment"># 切割nums2</span></span><br><span class="line">            LMax2 = nums2[(c2 - <span class="number">1</span>) // <span class="number">2</span>] <span class="keyword">if</span> c2 &gt; <span class="number">0</span> <span class="keyword">else</span> (<span class="number">-1</span> * sys.maxsize)</span><br><span class="line">            RMin2 = nums2[c2 // <span class="number">2</span>] <span class="keyword">if</span> c2 &lt; <span class="number">2</span> * m <span class="keyword">else</span> sys.maxsize</span><br><span class="line">            <span class="comment"># 不满足LMax&lt;RMin 则进行调整切割位置</span></span><br><span class="line">            <span class="keyword">if</span> LMax1 &gt; RMin2:</span><br><span class="line">                end_pos = c1 - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> LMax2 &gt; RMin1:</span><br><span class="line">                start_pos = c1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 找到合适的c1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 返回中位数</span></span><br><span class="line">        <span class="keyword">return</span> (max(LMax1, LMax2) + min(RMin1, RMin2)) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="分治算法" scheme="https://liuyang0001.github.io/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>3.无重复字符的最长子串</title>
    <link href="https://liuyang0001.github.io/2020/01/03/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>https://liuyang0001.github.io/2020/01/03/3-无重复字符的最长子串/</id>
    <published>2020-01-03T07:46:58.000Z</published>
    <updated>2020-01-04T09:38:13.714Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这道题主要用到思路是：<strong>滑动窗口</strong></p><blockquote><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！</p></blockquote><blockquote><p>如何移动？</p><p>我们只要找到那个相同元素的位置，把队列中它左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span> <span class="comment"># 如果字符串s为空，返回0</span></span><br><span class="line">        lookup = [] <span class="comment"># 初始化窗口</span></span><br><span class="line">        max_len = <span class="number">0</span> <span class="comment"># 窗口长度</span></span><br><span class="line">        cur_len = <span class="number">0</span> <span class="comment"># 当前子串长度</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): <span class="comment"># 遍历字符串s</span></span><br><span class="line">            val = s[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">in</span> lookup: <span class="comment"># 如果该值不在窗口中</span></span><br><span class="line">                lookup.append(val) <span class="comment"># 添加到窗口内</span></span><br><span class="line">                cur_len += <span class="number">1</span>  <span class="comment"># 当前长度+1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 如果该值在窗口中已存在</span></span><br><span class="line">                index = lookup.index(val) <span class="comment"># 获取其在窗口中的位置</span></span><br><span class="line">                lookup = lookup[index+<span class="number">1</span>:] <span class="comment"># 移除该位置及之前的字符</span></span><br><span class="line">                lookup.append(val) </span><br><span class="line">                cur_len = len(lookup) <span class="comment"># 当前长度更新为窗口长度</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; max_len: <span class="comment"># 看是否需要更新最大长度值</span></span><br><span class="line">                max_len = cur_len</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_len <span class="comment"># 返回最大子串长度</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>2.两数相加</title>
    <link href="https://liuyang0001.github.io/2020/01/03/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>https://liuyang0001.github.io/2020/01/03/2-两数相加/</id>
    <published>2020-01-03T06:04:18.000Z</published>
    <updated>2020-01-03T06:27:19.252Z</updated>
    
    <content type="html"><![CDATA[<p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</code></p><p><code>输出：7 -&gt; 0 -&gt; 8</code></p><p><code>原因：342 + 465 = 807</code></p><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>将链表转换成字符串，方便进行逆置操作；最后再讲字符串转换成链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ln2str</span><span class="params">(ln: ListNode)</span>:</span><span class="comment">#链表转换为字符串</span></span><br><span class="line">            <span class="keyword">if</span> ln.next == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> str(ln.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> str(ln.val) + str(ln2str(ln.next))</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">str2ln</span><span class="params">(str_res: str)</span>:</span><span class="comment">#字符串转换成链表</span></span><br><span class="line">            <span class="keyword">if</span> len(str_res)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> ListNode(int(str_res))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ln_temp = ListNode(int(str_res[<span class="number">0</span>]))</span><br><span class="line">                ln_temp.next = str2ln(str_res[<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">return</span> ln_temp</span><br><span class="line"></span><br><span class="line">        str1 = ln2str(l1)[::<span class="number">-1</span>] <span class="comment">#将链表1转换为字符串并逆置</span></span><br><span class="line">        str2 = ln2str(l2)[::<span class="number">-1</span>] <span class="comment">#将链表2转换为字符串并逆置</span></span><br><span class="line">        str_res = str(int(str1)+int(str2))[::<span class="number">-1</span>] <span class="comment">#相加后转换为字符串，逆置</span></span><br><span class="line">        <span class="keyword">return</span> str2ln(str_res)  <span class="comment">#返回转换成的链表</span></span><br></pre></td></tr></table></figure><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>把两个数按位相加，并存到一个新的链表中，使用carry保存是否需要进位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummyHead = ListNode(<span class="number">0</span>) <span class="comment"># 建立一个头结点</span></span><br><span class="line">        curr, carry = dummyHead, <span class="number">0</span> <span class="comment">#curr表当前结点；carry表进位</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2: <span class="comment"># 不全为空</span></span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l1: <span class="comment"># l1非空</span></span><br><span class="line">                sum += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2: <span class="comment"># l2非空</span></span><br><span class="line">                sum += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            sum += carry</span><br><span class="line">            carry = sum // <span class="number">10</span></span><br><span class="line">            curr.next = ListNode(sum % <span class="number">10</span>)</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">if</span> carry &gt; <span class="number">0</span>: <span class="comment"># 需要进位，使得链表加长</span></span><br><span class="line">            curr.next = ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next; <span class="comment">#返回除头结点之后链表</span></span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>1.两数之和</title>
    <link href="https://liuyang0001.github.io/2020/01/02/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://liuyang0001.github.io/2020/01/02/1-两数之和/</id>
    <published>2020-01-02T07:11:09.000Z</published>
    <updated>2020-01-02T08:00:12.867Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组<code>nums</code>和一个目标值<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>通过哈希来求解，这里通过字典来模拟哈希查询的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> hashmap.get(target - num) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>: <span class="comment"># 当前字典中找到对应key</span></span><br><span class="line">                <span class="keyword">return</span> [i,hashmap.get(target - num)]</span><br><span class="line">            hashmap[num] = i <span class="comment"># 未找到则将其加入字典中</span></span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组&lt;code&gt;nums&lt;/code&gt;和一个目标值&lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="https://liuyang0001.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-树</title>
    <link href="https://liuyang0001.github.io/2018/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <id>https://liuyang0001.github.io/2018/09/01/数据结构-树/</id>
    <published>2018-09-01T10:41:01.000Z</published>
    <updated>2018-09-02T16:44:42.689Z</updated>
    
    <content type="html"><![CDATA[<p>基于C/C++二叉树的构建与操作。</p><a id="more"></a><hr><h3 id="二叉树-递归实现"><a href="#二叉树-递归实现" class="headerlink" title="二叉树-递归实现"></a><center>二叉树-递归实现</center></h3><hr><h4 id="树的结点"><a href="#树的结点" class="headerlink" title="树的结点"></a>树的结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> BT_ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    BTNode *L_child, *R_child;<span class="comment">//左右孩子结点的指针</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure><h4 id="树的创建"><a href="#树的创建" class="headerlink" title="树的创建"></a>树的创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode *<span class="title">BiTree_Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data);<span class="comment">//手动输入树的结点值</span></span><br><span class="line">    BTNode *T;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0</span>) <span class="comment">//当遇到0时，令树的根节点为NULL，从而结束该分支的递归</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;<span class="comment">//空分支</span></span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));<span class="comment">//创建新的树节点</span></span><br><span class="line">        <span class="comment">//先序创建树</span></span><br><span class="line">        T-&gt;data = data;<span class="comment">//先给根节点赋值</span></span><br><span class="line">        T-&gt;L_child = BiTree_Create();<span class="comment">//创建左子树</span></span><br><span class="line">        T-&gt;R_child = BiTree_Create();<span class="comment">//创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问结点数据"><a href="#访问结点数据" class="headerlink" title="访问结点数据"></a>访问结点数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问节点数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_Vist_Node</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_Preorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree_Vist_Node(T);</span><br><span class="line">        BiTree_Preorder_Traversal(T-&gt;L_child);</span><br><span class="line">        BiTree_Preorder_Traversal(T-&gt;R_child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_Inorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree_Inorder_Traversal(T-&gt;L_child);</span><br><span class="line">        BiTree_Vist_Node(T);</span><br><span class="line">        BiTree_Inorder_Traversal(T-&gt;R_child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_Postorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree_Postorder_Traversal(T-&gt;L_child);</span><br><span class="line">        BiTree_Postorder_Traversal(T-&gt;R_child);</span><br><span class="line">        BiTree_Vist_Node(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双序遍历"><a href="#双序遍历" class="headerlink" title="双序遍历"></a>双序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的双序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_DblOrder_Traverse</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree_Vist_Node(T);</span><br><span class="line">        BiTree_DblOrder_Traverse(T-&gt;L_child);</span><br><span class="line">        BiTree_Vist_Node(T);</span><br><span class="line">        BiTree_DblOrder_Traverse(T-&gt;R_child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的复制"><a href="#树的复制" class="headerlink" title="树的复制"></a>树的复制</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的复制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_Copy</span><span class="params">(BTNode *T, BTNode *NewT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        NewT = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        NewT-&gt;data = T-&gt;data;</span><br><span class="line">        BiTree_Copy(T-&gt;L_child, NewT-&gt;L_child);</span><br><span class="line">        BiTree_Copy(T-&gt;R_child, NewT-&gt;R_child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTree_Depth</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = BiTree_Depth(T-&gt;L_child);</span><br><span class="line">        <span class="keyword">int</span> n = BiTree_Depth(T-&gt;R_child);</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> (m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结点个数"><a href="#结点个数" class="headerlink" title="结点个数"></a>结点个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计二叉树中结点的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTree_Node_Count</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BiTree_Node_Count(T-&gt;L_child) + BiTree_Node_Count(T-&gt;R_child) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="二叉树-非递归实现"><a href="#二叉树-非递归实现" class="headerlink" title="二叉树-非递归实现"></a><center>二叉树-非递归实现</center></h3><hr><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    BTNode *L_child, *R_child;</span><br><span class="line">    <span class="keyword">int</span> visitCount;<span class="comment">//用于非递归的后序遍历</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历-使用栈(Stack)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> &lt;BTNode *&gt; TreeStack;<span class="comment">//声明一个树的栈名为TreeStack</span></span><br><span class="line">    BTNode *p = T; <span class="comment">//辅助结点指针</span></span><br><span class="line">    <span class="keyword">while</span> (p || !TreeStack.empty())<span class="comment">//p不指向NULL或者栈内非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)<span class="comment">//p不指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);<span class="comment">//访问结点值</span></span><br><span class="line">            TreeStack.push(p);<span class="comment">//将p压入栈中,后进先出</span></span><br><span class="line">            p = p-&gt;L_child;<span class="comment">//p指向他的左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//p指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = TreeStack.top();<span class="comment">//取得栈顶指针</span></span><br><span class="line">            TreeStack.pop();<span class="comment">//开始出栈,即访问左节点为空</span></span><br><span class="line">            p = p-&gt;R_child;<span class="comment">//开始访问出战的左节点为空的父节点的右结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder_Traverse</span><span class="params">(BTNode* T)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">stack</span> &lt;BTNode*&gt; TreeStack;</span><br><span class="line">    BTNode* p = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p || !TreeStack.empty())<span class="comment">//p不指向NULL或者栈非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)<span class="comment">//p不指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeStack.push(p);<span class="comment">//压进栈内</span></span><br><span class="line">            p = p-&gt;L_child;<span class="comment">//访问他的左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//p指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = TreeStack.top();<span class="comment">//取得栈顶指针</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">            TreeStack.pop();<span class="comment">//根结点的左孩子开始出栈</span></span><br><span class="line">            p = p-&gt;R_child;<span class="comment">//访问目前根节点的右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BTNode *&gt; TreeStack;</span><br><span class="line">    BTNode *p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !TreeStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="comment">//不指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;visitCount = <span class="number">1</span>; <span class="comment">//访问根节点一次</span></span><br><span class="line">            TreeStack.push(p); <span class="comment">//压入栈中</span></span><br><span class="line">            p = p-&gt;L_child;    <span class="comment">//访问左结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = TreeStack.top();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;visitCount == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeStack.pop(); <span class="comment">//出栈</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data); <span class="comment">//读出栈顶的值</span></span><br><span class="line">                p = <span class="literal">NULL</span>;<span class="comment">//指向空</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//只有访问过一次</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;visitCount++;   <span class="comment">//访问次数+1</span></span><br><span class="line">                p = p-&gt;R_child;    <span class="comment">//访问右孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Levelorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BTNode *&gt; TreeQueue; <span class="comment">//调用队列</span></span><br><span class="line">    TreeQueue.push(T);<span class="comment">//树的根节点入队</span></span><br><span class="line">    BTNode *p = T;</span><br><span class="line">    <span class="keyword">while</span> (!TreeQueue.empty())<span class="comment">//队列非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = TreeQueue.front();<span class="comment">//指向队头</span></span><br><span class="line">        TreeQueue.pop();<span class="comment">//出队</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);<span class="comment">//取值</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;L_child)<span class="comment">//存在左结点,入队</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeQueue.push(p-&gt;L_child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;R_child)<span class="comment">//存在右结点,入队</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeQueue.push(p-&gt;R_child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="调用栈与队列"><a href="#调用栈与队列" class="headerlink" title="调用栈与队列"></a><center>调用栈与队列</center></h3><hr><h4 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//使用命名空间调用队列堆栈</span></span><br></pre></td></tr></table></figure><h4 id="引入头文件"><a href="#引入头文件" class="headerlink" title="引入头文件"></a>引入头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;BTNode *&gt; TreeStack;      <span class="comment">//声明一个元素为树结点指针的栈，名为TreeStack</span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xx.empty() <span class="comment">//为空则返回真</span></span><br><span class="line">xx.pop() <span class="comment">//删除元素</span></span><br><span class="line">xx.push() <span class="comment">//增加元素</span></span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a><center>测试源码</center></h3><hr><p><br></p><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/BiTree" target="_blank" rel="noopener">递归/非递归实现源码，请点击这里获取</a></strong></center><p><br></p><hr><center><strong>随时补充</strong></center><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于C/C++二叉树的构建与操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structure Study Notes" scheme="https://liuyang0001.github.io/categories/Data-Structure-Study-Notes/"/>
    
    
      <category term="C/C++" scheme="https://liuyang0001.github.io/tags/C-C/"/>
    
      <category term="Tree" scheme="https://liuyang0001.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-队</title>
    <link href="https://liuyang0001.github.io/2018/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F/"/>
    <id>https://liuyang0001.github.io/2018/09/01/数据结构-队/</id>
    <published>2018-09-01T05:55:46.000Z</published>
    <updated>2018-09-01T10:11:29.187Z</updated>
    
    <content type="html"><![CDATA[<p>基于C/C++顺序队列和链式队列的构建与操作。</p><a id="more"></a><hr><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a><center>顺序队列</center></h3><hr><h4 id="队的结构"><a href="#队的结构" class="headerlink" title="队的结构"></a>队的结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqQueue</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear; <span class="comment">// 队列头和队列尾</span></span><br><span class="line">&#125;SeqQueue;</span><br></pre></td></tr></table></figure><h4 id="队的操作"><a href="#队的操作" class="headerlink" title="队的操作"></a>队的操作</h4><h5 id="初始化空队"><a href="#初始化空队" class="headerlink" title="初始化空队"></a>初始化空队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化空队列</span></span><br><span class="line"><span class="function">SeqQueue *<span class="title">SeqQueue_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqQueue *Q = (SeqQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqQueue));<span class="comment">//分配内存</span></span><br><span class="line">    Q-&gt;rear = Q-&gt;front = <span class="number">0</span>;<span class="comment">//初始化对手与队尾</span></span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="是否空队"><a href="#是否空队" class="headerlink" title="是否空队"></a>是否空队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否空队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqQueue_Is_Empty</span><span class="params">(SeqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)<span class="comment">//队首与队尾相同时为空队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqQueue_Push</span><span class="params">(SeqQueue *Q, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MaxSize == Q-&gt;front) <span class="comment">//判断是否队满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The Queue has been full.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Elem %d has been in the Queue.\n"</span>, Q-&gt;data[Q-&gt;rear]);</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqQueue_Pop</span><span class="params">(SeqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SeqQueue_Is_Empty(Q)) <span class="comment">//如果空队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Elem %d has been out of the Queue.\n"</span>, Q-&gt;data[Q-&gt;front]);</span><br><span class="line">    Q-&gt;data[Q-&gt;front] = <span class="literal">NULL</span>; <span class="comment">//清空队首元素，队首上移</span></span><br><span class="line">    Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MaxSize; <span class="comment">//循环队列操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历打印"><a href="#遍历打印" class="headerlink" title="遍历打印"></a>遍历打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue_Print</span><span class="params">(SeqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Q-&gt;front; (i + <span class="number">1</span>) % MaxSize != Q-&gt;rear; i++)<span class="comment">//取余判断是否循环一遍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, Q-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a><center>链式队列</center></h3><hr><h4 id="链式队列结构"><a href="#链式队列结构" class="headerlink" title="链式队列结构"></a>链式队列结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    QNode *next;<span class="comment">//指针域</span></span><br><span class="line">&#125; QNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedQueue</span>&#123;</span></span><br><span class="line">    QNode *front, *rear; <span class="comment">// 队列头和队列尾</span></span><br><span class="line">&#125;LinkedQueue;</span><br></pre></td></tr></table></figure><h4 id="链式队列操作"><a href="#链式队列操作" class="headerlink" title="链式队列操作"></a>链式队列操作</h4><h5 id="空队初始化"><a href="#空队初始化" class="headerlink" title="空队初始化"></a>空队初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化空队列</span></span><br><span class="line"><span class="function">LinkedQueue* <span class="title">LinkedQueue_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedQueue *Q = (LinkedQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedQueue));</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = (QNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));<span class="comment">//分配空间给两个指针域结点</span></span><br><span class="line">    Q-&gt;rear-&gt;next = Q-&gt;front-&gt;next = <span class="literal">NULL</span>; <span class="comment">//初始de后继指针均指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedQueue_Push</span><span class="params">(LinkedQueue *Q, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//链式队列不用考虑满队</span></span><br><span class="line">    QNode *r = (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));<span class="comment">//新结点</span></span><br><span class="line">    r-&gt;data = x;                              <span class="comment">//插入元素</span></span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;                           <span class="comment">//后继结点为空</span></span><br><span class="line">    Q-&gt;rear-&gt;next = r;                        <span class="comment">//Q的原队尾结点指向s</span></span><br><span class="line">    Q-&gt;rear = r;                              <span class="comment">//更新队尾指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Elem %d has been in the Queue.\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队,需要注意头节点的问题</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedQueue_Pop</span><span class="params">(LinkedQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LinkedQueue_Is_Empty(Q)) <span class="comment">//如果空队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    QNode *s=Q-&gt;front-&gt;next;<span class="comment">//辅助结点,指向头结点的下一个</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Elem %d has been out of the Queue.\n"</span>,s-&gt;data);<span class="comment">//跳过头节点</span></span><br><span class="line">    Q-&gt;front-&gt;next = s-&gt;next;</span><br><span class="line">    <span class="comment">// Q-&gt;front = Q-&gt;front-&gt;next; //队首后移动</span></span><br><span class="line">    <span class="built_in">free</span>(s);<span class="comment">//释放原来的头结点后继</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="是否非空"><a href="#是否非空" class="headerlink" title="是否非空"></a>是否非空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否空队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedQueue_Is_Empty</span><span class="params">(LinkedQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front==Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历打印-1"><a href="#遍历打印-1" class="headerlink" title="遍历打印"></a>遍历打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkedQueue_Print</span><span class="params">(LinkedQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Q-&gt;front-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, Q-&gt;front-&gt;next-&gt;data);</span><br><span class="line">        Q-&gt;front = Q-&gt;front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a><center>测试源码</center></h3><hr><p><br></p><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/SeqQueue" target="_blank" rel="noopener">顺序队列源码，请点击这里获取</a></strong></center><p><br></p><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/LinkedQueue" target="_blank" rel="noopener">链式队列源码，请点击这里获取</a></strong></center><p><br></p><hr><center><strong>随时补充</strong></center><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于C/C++顺序队列和链式队列的构建与操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structure Study Notes" scheme="https://liuyang0001.github.io/categories/Data-Structure-Study-Notes/"/>
    
    
      <category term="C/C++" scheme="https://liuyang0001.github.io/tags/C-C/"/>
    
      <category term="Queue" scheme="https://liuyang0001.github.io/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="https://liuyang0001.github.io/2018/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>https://liuyang0001.github.io/2018/08/31/数据结构-栈/</id>
    <published>2018-08-31T13:07:03.000Z</published>
    <updated>2018-09-01T08:53:00.481Z</updated>
    
    <content type="html"><![CDATA[<p>基于C/C++顺序栈和链栈的构建与操作。</p><a id="more"></a><hr><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a><center>顺序栈</center></h3><hr><h4 id="栈的结构"><a href="#栈的结构" class="headerlink" title="栈的结构"></a>栈的结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;    <span class="comment">//栈的栈顶</span></span><br><span class="line">&#125; SeqStack;</span><br></pre></td></tr></table></figure><h4 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h4><h5 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqStack_Push</span><span class="params">(SeqStack *S, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top &gt;= MaxSize - <span class="number">1</span>)<span class="comment">//若栈满，拒绝入栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S-&gt;data[++S-&gt;top] = x; <span class="comment">//先移动指针。再赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈,返回出栈元素值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqStack_Pop</span><span class="params">(SeqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) <span class="comment">//若空栈，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ElemType x = S-&gt;data[S-&gt;top--];<span class="comment">//取得出栈元素后，top指针下移</span></span><br><span class="line">    S-&gt;data[S-&gt;top + <span class="number">1</span>] = <span class="literal">NULL</span>;<span class="comment">//将要删除的元素删除</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ELm %d has been out\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自动建栈"><a href="#自动建栈" class="headerlink" title="自动建栈"></a>自动建栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动建栈</span></span><br><span class="line"><span class="function">SeqStack *<span class="title">Create_SeqStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqStack *S; <span class="comment">//定义栈</span></span><br><span class="line">    S = (SeqStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqStack));</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>; <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SeqStack_Push(S, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历打印"><a href="#遍历打印" class="headerlink" title="遍历打印"></a>遍历打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从栈顶遍历顺序栈元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_SeqStack_FromTop</span><span class="params">(SeqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NULL"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = S-&gt;top; x &gt; <span class="number">-1</span>; x--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, S-&gt;data[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a><center>链栈</center></h3><hr><h4 id="栈的结构-1"><a href="#栈的结构-1" class="headerlink" title="栈的结构"></a>栈的结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式栈的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; SNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式栈的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedStack</span>&#123;</span></span><br><span class="line">    SNode *top;  <span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">//链式栈的结点数</span></span><br><span class="line">&#125; LinkedStack;</span><br></pre></td></tr></table></figure><h4 id="栈的操作-1"><a href="#栈的操作-1" class="headerlink" title="栈的操作"></a>栈的操作</h4><h5 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedStack_Push</span><span class="params">(LinkedStack *S, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SNode *p = (SNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));<span class="comment">//申请新结点内存</span></span><br><span class="line">    p-&gt;data = x;<span class="comment">//赋值</span></span><br><span class="line">    p-&gt;next = S-&gt;top;<span class="comment">//p得后继指针指向原来的栈顶</span></span><br><span class="line">    S-&gt;top = p;<span class="comment">//将栈顶指针移动到新结点</span></span><br><span class="line">    S-&gt;count++;<span class="comment">//增加结点数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedStack_Pop</span><span class="params">(LinkedStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!S-&gt;top)<span class="comment">//判定是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ElemType x = S-&gt;top-&gt;data;<span class="comment">//得到出栈元素</span></span><br><span class="line">    SNode *p = S-&gt;top;<span class="comment">//辅助指针指向栈顶</span></span><br><span class="line">    S-&gt;top = S-&gt;top-&gt;next;<span class="comment">//移动栈顶指针到原栈顶指针的后继</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放掉原栈顶</span></span><br><span class="line">    S-&gt;count--;<span class="comment">//结点数-1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Elem %d has been out of stack\n"</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自动建栈-1"><a href="#自动建栈-1" class="headerlink" title="自动建栈"></a>自动建栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动建栈</span></span><br><span class="line"><span class="function">LinkedStack *<span class="title">Create_LinkedStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedStack *S;</span><br><span class="line">     S = (LinkedStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));<span class="comment">//申请内存</span></span><br><span class="line">    S-&gt;count = <span class="number">0</span>;<span class="comment">//初始化结点数</span></span><br><span class="line">    S-&gt;top = <span class="literal">NULL</span>;<span class="comment">//初始化栈顶指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkedStack_Push(S, x);<span class="comment">//进栈操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历打印-1"><a href="#遍历打印-1" class="headerlink" title="遍历打印"></a>遍历打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_LinkedStack_FromTop</span><span class="params">(LinkedStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SNode *p = S-&gt;top;</span><br><span class="line">    <span class="keyword">while</span> (p)<span class="comment">//当栈顶指针不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a><center>测试源码</center></h3><hr><p><br></p><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/LinkedList" target="_blank" rel="noopener">链式栈源码，请点击这里获取</a></strong></center><p><br></p><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/SeqList" target="_blank" rel="noopener">顺序栈源码，请点击这里获取</a></strong></center><p><br></p><hr><center><strong>随时补充</strong></center><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于C/C++顺序栈和链栈的构建与操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structure Study Notes" scheme="https://liuyang0001.github.io/categories/Data-Structure-Study-Notes/"/>
    
    
      <category term="C/C++" scheme="https://liuyang0001.github.io/tags/C-C/"/>
    
      <category term="Stack" scheme="https://liuyang0001.github.io/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-表</title>
    <link href="https://liuyang0001.github.io/2018/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%A1%A8/"/>
    <id>https://liuyang0001.github.io/2018/08/29/数据结构-表/</id>
    <published>2018-08-29T13:28:51.000Z</published>
    <updated>2018-09-01T05:44:04.279Z</updated>
    
    <content type="html"><![CDATA[<p>基于C/C++顺序表和链表的构建与操作。</p><a id="more"></a><hr><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a><center>顺序表</center></h3><hr><h4 id="静态表结构"><a href="#静态表结构" class="headerlink" title="静态表结构"></a>静态表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态顺序表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList_Static</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SeqList_Static;</span><br></pre></td></tr></table></figure><h4 id="静态表操作"><a href="#静态表操作" class="headerlink" title="静态表操作"></a>静态表操作</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表初始化</span></span><br><span class="line"><span class="function">SeqList_Static *<span class="title">SeqList_Static_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一次性开辟存储空间</span></span><br><span class="line">    SeqList_Static *L = (SeqList_Static *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList_Static));</span><br><span class="line">    L-&gt;data[<span class="number">0</span>] = <span class="literal">NULL</span>;<span class="comment">//初始化为空，长度为0</span></span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化时，顺序插入0-9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[i] = i;</span><br><span class="line">        L-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="顺序打印"><a href="#顺序打印" class="headerlink" title="顺序打印"></a>顺序打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态链表的打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Static_Print</span><span class="params">(SeqList_Static *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, L-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="元素插入"><a href="#元素插入" class="headerlink" title="元素插入"></a>元素插入</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态链表——插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqList_Static_Insert</span><span class="params">(SeqList_Static *L, <span class="keyword">int</span> i, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//判断插入位置的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; L-&gt;length <span class="keyword">or</span> i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 要插入位置的后面结点循环右移一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L-&gt;length; j &gt;= i; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[j] = L-&gt;data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>] = x;<span class="comment">//插入元素</span></span><br><span class="line">    L-&gt;length++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n插入之后的链表为:\n"</span>);</span><br><span class="line">    SeqList_Static_Print(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态链表——删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqList_Static_Delete</span><span class="params">(SeqList_Static *L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断要删除位置的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; L-&gt;length <span class="keyword">or</span> i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 要删除位置的后面结点循环左移一位</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[i<span class="number">-1</span>] = L-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除之后的链表为:\n"</span>);</span><br><span class="line">    SeqList_Static_Print(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="动态表结构"><a href="#动态表结构" class="headerlink" title="动态表结构"></a>动态表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100         <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10         <span class="comment">//预定义顺序表初始长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ListIncrement 10    <span class="comment">//预定义顺序表扩充增量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;       <span class="comment">//元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态顺序表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span>&#123;</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="keyword">int</span> length,capacity;<span class="comment">//长度，动态的最大容量</span></span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure><h4 id="动态表操作"><a href="#动态表操作" class="headerlink" title="动态表操作"></a>动态表操作</h4><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态表初始化</span></span><br><span class="line"><span class="function">SeqList *<span class="title">SeqList_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqList *L = (SeqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList));</span><br><span class="line">    L-&gt;data = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * InitSize);<span class="comment">//不加会出错 不懂为什么</span></span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    L-&gt;capacity = InitSize; <span class="comment">//动态的空间最大量</span></span><br><span class="line">    L-&gt;data[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//初始化时，顺序插入0-9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[i] = i;</span><br><span class="line">        L-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Locate</span><span class="params">(SeqList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i<span class="number">-1</span>]==e)<span class="keyword">return</span> i;         <span class="comment">//返回第i个元素(下标为i-1值为e)的位号i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                               <span class="comment">//返回0表明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert_Seq</span><span class="params">(SeqList *L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//i的位置不合法</span></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length &gt;= L-&gt;capacity)</span><br><span class="line">    &#123;                                                                                                   <span class="comment">//当前长度已达到最大容量，扩充分配存储空间</span></span><br><span class="line">        ElemType *newbase = (ElemType *)<span class="built_in">realloc</span>(L-&gt;data, <span class="keyword">sizeof</span>(ElemType) * (InitSize + ListIncrement)); <span class="comment">//顺序表扩充</span></span><br><span class="line">        <span class="keyword">if</span> (!newbase)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//存储分配失败</span></span><br><span class="line">        L-&gt;data = newbase;           <span class="comment">//新基址</span></span><br><span class="line">        L-&gt;capacity += ListIncrement; <span class="comment">//增加存储容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L-&gt;length; j &gt;= i; j--) <span class="comment">//第i个元素以及其后的元素右移1个位置</span></span><br><span class="line">        L-&gt;data[j] = L-&gt;data[j - <span class="number">1</span>];</span><br><span class="line">    L-&gt;data[i - <span class="number">1</span>] = e; <span class="comment">//腾出一个空位置插入新元素</span></span><br><span class="line">    L-&gt;length++;        <span class="comment">//表当前长度+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete_Seq</span><span class="params">(SeqList &amp;L,<span class="keyword">int</span> i,ElemType&amp; e)</span></span>&#123;<span class="comment">//删除第i个位置（1&lt;=i&lt;=L.length）元素</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//i的位置不合法</span></span><br><span class="line">    e=L.data[i<span class="number">-1</span>];                  <span class="comment">//将被删除的元素用引用变量e返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;L.length;j++)     <span class="comment">//第i个位置之后元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">    L.length--;                     <span class="comment">//表长度-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a><center>单链表</center></h3><hr><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建单链表结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域，用于指向下一个结点</span></span><br><span class="line">&#125; LNode, *LinkedList;</span><br></pre></td></tr></table></figure><h4 id="单链表创建"><a href="#单链表创建" class="headerlink" title="单链表创建"></a>单链表创建</h4><h5 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h5><p>以顺序插入0-9为例创建带有头结点的单链表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法创建单链表</span></span><br><span class="line"><span class="function">LinkedList <span class="title">Create_LinkedList_H</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *L;<span class="comment">//创建头结点</span></span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//开辟头结点存储空间</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//默认将头结点指向空</span></span><br><span class="line">    LNode *s; <span class="comment">//创建辅助结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)<span class="comment">//0-9循环入队</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//开辟新的结点空间</span></span><br><span class="line">        s-&gt;data = x;<span class="comment">//1.为新的结点赋值</span></span><br><span class="line">        s-&gt;next = L-&gt;next;<span class="comment">//2.将新结点的后继指针指向头节点原来的后继，即插入到头结点后面</span></span><br><span class="line">        L-&gt;next = s;   <span class="comment">//3.最后修改头结点的后继指针指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;<span class="comment">//返回生成的链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾插法创建单链表</span></span><br><span class="line"><span class="function">LinkedList <span class="title">Create_LinkedList_R</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *L;<span class="comment">//创建头结点</span></span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//开辟结点空间</span></span><br><span class="line">    LNode *s;     <span class="comment">//辅助节点指针</span></span><br><span class="line">    LNode *r = L; <span class="comment">//相当于尾指针，当前初始指向头结点</span></span><br><span class="line">    <span class="keyword">for</span> (ElemType x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//开辟新节点空间</span></span><br><span class="line">        s-&gt;data = x; <span class="comment">//将新结点赋值</span></span><br><span class="line">        r-&gt;next = s; <span class="comment">//将新结点接到当前尾指针的后端</span></span><br><span class="line">        r = s;       <span class="comment">//将尾指针移到最后的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将最后得结点后继指针指向空</span></span><br><span class="line">    <span class="keyword">return</span> L;<span class="comment">//返回新的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表操作"><a href="#单链表操作" class="headerlink" title="单链表操作"></a>单链表操作</h4><h5 id="遍历打印"><a href="#遍历打印" class="headerlink" title="遍历打印"></a>遍历打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历打印带头结点的单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_LinkedList</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;<span class="comment">//跳过头结点</span></span><br><span class="line">    <span class="keyword">for</span> (; p; p = p-&gt;next)<span class="comment">//循环遍历链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找元素-1"><a href="#查找元素-1" class="headerlink" title="查找元素"></a>查找元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照序号查找元素</span></span><br><span class="line"><span class="function">LinkedList <span class="title">GetElem_By_Number</span><span class="params">(LinkedList L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)<span class="comment">//查找第一个元素，则直接返回头结点的后继结点</span></span><br><span class="line">        <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; = <span class="number">0</span>)<span class="comment">//非法查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L-&gt;next;<span class="comment">//跳过头结点</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i)<span class="comment">//当p非空且未到循环次数</span></span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;<span class="comment">//跳到下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//返回p的指针位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照值来查找元素</span></span><br><span class="line"><span class="function">LinkedList <span class="title">GetElem_By_Value</span><span class="params">(LinkedList L, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span> || x == <span class="literal">NULL</span>)<span class="comment">//其一为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p = L-&gt;next;<span class="comment">//跳过头结点</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;data != x)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//返回指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在第i个结点处插入新结点</span></span><br><span class="line"><span class="function">LinkedList <span class="title">Insert_LinkedList</span><span class="params">(LinkedList &amp;L, <span class="keyword">int</span> i, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = GetElem_By_Number(L, i - <span class="number">1</span>);<span class="comment">//得到要插入元素的前一个结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//开辟存储空间</span></span><br><span class="line">    s-&gt;data = x;<span class="comment">//赋值</span></span><br><span class="line">    s-&gt;next = p-&gt;next;<span class="comment">//将新节点的后继指向要插入位置的后一个结点</span></span><br><span class="line">    p-&gt;next = s;<span class="comment">//将要插入位置的前一个元素的后继指向新节点</span></span><br><span class="line">    <span class="keyword">return</span> L;<span class="comment">//返回新链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第i个结点</span></span><br><span class="line"><span class="function">LinkedList <span class="title">Delete_LinkedList</span><span class="params">(LinkedList &amp;L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = GetElem_By_Number(L, i - <span class="number">1</span>);<span class="comment">//p指向删除元素的前一个结点</span></span><br><span class="line">    LNode *q = p-&gt;next; <span class="comment">//q指向要删除的结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;  <span class="comment">//前一个直接跳过要删除元素指向要删除元素的后继</span></span><br><span class="line">    <span class="built_in">free</span>(q);            <span class="comment">//释放掉q的空间</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a><center>双链表</center></h3><hr><h4 id="结点结构-1"><a href="#结点结构-1" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义双链表结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span><span class="comment">//双指针</span></span><br><span class="line">&#125;DLNode;</span><br></pre></td></tr></table></figure><h4 id="双链表操作"><a href="#双链表操作" class="headerlink" title="双链表操作"></a>双链表操作</h4><h5 id="头插法创建单链表"><a href="#头插法创建单链表" class="headerlink" title="头插法创建单链表"></a>头插法创建单链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法建立双链表</span></span><br><span class="line"><span class="function">DLNode *<span class="title">Create_Double_LinkedList_H</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *L;                            <span class="comment">//头结点L</span></span><br><span class="line">    L = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode)); <span class="comment">//为头结点分配内存</span></span><br><span class="line">    L-&gt;next = L;                          <span class="comment">//初始化指针</span></span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    DLNode *s; <span class="comment">//新结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">        s-&gt;data = i;</span><br><span class="line">        L-&gt;next-&gt;prior = s;</span><br><span class="line">        s-&gt;prior = L;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尾插法创建双链表"><a href="#尾插法创建双链表" class="headerlink" title="尾插法创建双链表"></a>尾插法创建双链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法建立双链表</span></span><br><span class="line"><span class="function">DLNode *<span class="title">Create_Double_LinkedList_R</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *L = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">    L-&gt;prior = L-&gt;next = L;</span><br><span class="line">    DLNode *s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DLNode *r = L-&gt;prior; <span class="comment">//定义为尾指针</span></span><br><span class="line">        s = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">        s-&gt;data = i;<span class="comment">//赋值</span></span><br><span class="line">        r-&gt;next = s;<span class="comment">//原尾指针后继指向新结点</span></span><br><span class="line">        s-&gt;prior = r;<span class="comment">//新结点前驱指向原尾结点</span></span><br><span class="line">        s-&gt;next = L;<span class="comment">//新结点的后继为头结点</span></span><br><span class="line">        L-&gt;prior = s; <span class="comment">//头结点的前驱为新结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="打印双链表"><a href="#打印双链表" class="headerlink" title="打印双链表"></a>打印双链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印双循环链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Double_LinkedList</span><span class="params">(DLNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *p = L-&gt;next; <span class="comment">//p跳过头结点，指向第一个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a><center>测试源码</center></h3><hr><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/LinkedList" target="_blank" rel="noopener">链表源码，请点击这里获取</a></strong></center><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/SeqList" target="_blank" rel="noopener">顺序表源码，请点击这里获取</a></strong></center><p><br></p><hr><center><strong>随时补充</strong></center><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于C/C++顺序表和链表的构建与操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structure Study Notes" scheme="https://liuyang0001.github.io/categories/Data-Structure-Study-Notes/"/>
    
    
      <category term="C/C++" scheme="https://liuyang0001.github.io/tags/C-C/"/>
    
      <category term="Linked List" scheme="https://liuyang0001.github.io/tags/Linked-List/"/>
    
      <category term="Sequence List" scheme="https://liuyang0001.github.io/tags/Sequence-List/"/>
    
  </entry>
  
  <entry>
    <title>Python下划线</title>
    <link href="https://liuyang0001.github.io/2018/04/21/Python%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    <id>https://liuyang0001.github.io/2018/04/21/Python下划线/</id>
    <published>2018-04-21T07:40:15.000Z</published>
    <updated>2018-08-31T11:19:06.798Z</updated>
    
    <content type="html"><![CDATA[<p>Python中单下划线和双下划线的各种含义和命名约定，名称修饰的工作原理，以及它如何影响你自己的Python类。<br><a id="more"></a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>单下划线和双下划线在Python变量和方法名称中都各有其含义。有一些含义仅仅是依照约定，被视作是对程序员的提示 - 而有一些含义是由Python解释器严格执行的。</p><p>在本文中，我们将讨论以下五种下划线模式和命名约定，以及它们如何影响Python程序的行为：</p><blockquote><ul><li>单前导下划线：<code>_var</code></li></ul></blockquote><blockquote><ul><li>单末尾下划线：<code>var_</code></li></ul></blockquote><blockquote><ul><li>双前导下划线：<code>__var</code></li></ul></blockquote><blockquote><ul><li>双前导和末尾下划线：<code>__var__</code></li></ul></blockquote><blockquote><ul><li>单下划线：<code>_</code></li></ul></blockquote><hr><h2 id="1-单前导下划线-var"><a href="#1-单前导下划线-var" class="headerlink" title="1. 单前导下划线 _var"></a>1. 单前导下划线 _var</h2><p>当涉及到变量和方法名称时，单个下划线前缀有一个约定俗成的含义。 它是对程序员的一个提示 - 意味着Python开发人员一致认为它应该是什么意思，但程序的行为不受影响。</p><p>下划线前缀的含义是告知其他程序员：以单个下划线开头的变量或方法仅供内部使用。 该约定在PEP 8中有定义。</p><p>这不是Python强制规定的。 Python不像Java那样在“私有”和“公共”变量之间有很强的区别。 这就像有人提出了一个小小的下划线警告标志，说：</p><blockquote><p>“嘿，这不是真的要成为类的公共接口的一部分。不去管它就好。“</p></blockquote><p>看看下面的例子：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/jiJG3iG731.png?imageslim" alt="mark"></p><p>如果你实例化此类，并尝试访问在<code>__init__</code>构造函数中定义的foo和_bar属性，会发生什么情况？ 让我们来看看：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/CCJlima0Be.png?imageslim" alt="mark"><br>你会看到_bar中的单个下划线并没有阻止我们“进入”类并访问该变量的值。</p><p>这是因为Python中的单个下划线前缀仅仅是一个约定 - 至少相对于变量和方法名而言。</p><p><strong>但是，前导下划线的确会影响从模块中导入名称的方式。</strong><br>假设你在一个名为my_module的模块中有以下代码：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/AE8GgieLK9.png?imageslim" alt="mark"></p><p>现在，如果使用通配符从模块中导入所有名称，则Python不会导入带有前导下划线的名称（除非模块定义了覆盖此行为的<code>__all__</code>列表）：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/7f4F1iK97c.png?imageslim" alt="mark"></p><p>顺便说一下，应该避免通配符导入，因为它们使名称空间中存在哪些名称不清楚。 为了清楚起见，坚持常规导入更好。</p><p>与通配符导入不同，常规导入不受前导单个下划线命名约定的影响：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/I6eH9JAbDa.png?imageslim" alt="mark"></p><p>我知道这一点可能有点令人困惑。 如果你遵循PEP 8推荐，避免通配符导入，那么你真正需要记住的只有这个：</p><blockquote><p>单个下划线是一个Python命名约定，表示这个名称是供内部使用的。 它通常不由Python解释器强制执行，仅仅作为一种对程序员的提示。</p></blockquote><hr><h2 id="2-单末尾下划线-var"><a href="#2-单末尾下划线-var" class="headerlink" title="2. 单末尾下划线 var_"></a>2. 单末尾下划线 var_</h2><p>有时候，一个变量的最合适的名称已经被一个关键字所占用。 因此，像class或def这样的名称不能用作Python中的变量名称。 在这种情况下，你可以附加一个下划线来解决命名冲突：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/E21Dd9i5a4.png?imageslim" alt="mark"><br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/FAhCKb65F7.png?imageslim" alt="mark"><br>总之，单个末尾下划线（后缀）是一个约定，用来避免与Python关键字产生命名冲突。 PEP 8解释了这个约定。</p><hr><h2 id="3-双前导下划线-var"><a href="#3-双前导下划线-var" class="headerlink" title="3. 双前导下划线 __var"></a>3. 双前导下划线 __var</h2><p>到目前为止，我们所涉及的所有命名模式的含义，来自于已达成共识的约定。 而对于以双下划线开头的Python类的属性（包括变量和方法），情况就有点不同了。</p><p>双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。</p><p>这也叫做名称修饰（name mangling） - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。</p><p>我知道这听起来很抽象。 因此，我组合了一个小小的代码示例来予以说明：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/DbAK29Ha92.png?imageslim" alt="mark"></p><p>让我们用内置的dir()函数来看看这个对象的属性：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/dlfg2f36Jc.png?imageslim" alt="mark"></p><p>以上是这个对象属性的列表。 让我们来看看这个列表，并寻找我们的原始变量名称<code>foo</code>，<code>_bar</code>和<code>__baz</code> - 我保证你会注意到一些有趣的变化。</p><p><code>self.foo</code>变量在属性列表中显示为未修改为foo。</p><p><code>self._bar</code>的行为方式相同 - 它以<code>_bar</code>的形式显示在类上。 就像我之前说过的，在这种情况下，前导下划线仅仅是一个约定。 给程序员一个提示而已。</p><p>然而，对于<code>self.__baz</code>而言，情况看起来有点不同。 当你在该列表中搜索__baz时，你会看不到有这个名字的变量。</p><p><strong>__baz出什么情况了？</strong></p><p>如果你仔细观察，你会看到此对象上有一个名为<code>_Test__baz</code>的属性。 这就是Python解释器所做的名称修饰。 它这样做是<strong>为了防止变量在子类中被重写。</strong></p><p>让我们创建另一个扩展Test类的类，并尝试重写构造函数中添加的现有属性：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/iljAIbcJbe.png?imageslim" alt="mark"></p><p>等一下，当我们尝试查看<code>t2 .__ baz</code>的值时，为什么我们会得到AttributeError？ 名称修饰被再次触发了！ 事实证明，这个对象甚至没有__baz属性：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/leg0kGGG0K.png?imageslim" alt="mark"></p><p>正如你可以看到<code>__baz</code>变成<code>_ExtendedTest__baz</code>以防止意外修改：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/CHGlhCF4Cm.png?imageslim" alt="mark"></p><p>但原来的<code>_Test__baz</code>还在：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/K9Cf3d24hC.png?imageslim" alt="mark"></p><p>双下划线名称修饰对程序员是完全透明的。 下面的例子证实了这一点：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/DikeKk2Bb3.png?imageslim" alt="mark"></p><p>名称修饰是否也适用于方法名称？ 是的，也适用。名称修饰会影响在一个类的上下文中，以两个下划线字符（”dunders”）开头的所有名称：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/JmIm7gKJmJ.png?imageslim" alt="mark"></p><p>这是另一个也许令人惊讶的运用名称修饰的例子：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/3ja0mfA9Gg.png?imageslim" alt="mark"></p><p>在这个例子中，我声明了一个名为<code>_MangledGlobal__mangled</code>的全局变量。然后我在名为MangledGlobal的类的上下文中访问变量。由于名称修饰，我能够在类的test()方法内，以<code>__mangled</code>来引用<code>_MangledGlobal__mangled</code>全局变量。</p><p>Python解释器自动将名称<code>__mangled</code>扩展为<code>_MangledGlobal__mangled</code>，因为它以两个下划线字符开头。这表明名称修饰不是专门与类属性关联的。它适用于在类上下文中使用的两个下划线字符开头的任何名称。</p><hr><h2 id="4-双前导和双末尾下划线-var"><a href="#4-双前导和双末尾下划线-var" class="headerlink" title="4. 双前导和双末尾下划线 __var__"></a>4. 双前导和双末尾下划线 <code>__var__</code></h2><p>也许令人惊讶的是，如果一个名字同时以双下划线开始和结束，则不会应用名称修饰。 由双下划线前缀和后缀包围的变量不会被Python解释器修改：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/ADDl7hei7B.png?imageslim" alt="mark"></p><p>但是，Python保留了有双前导和双末尾下划线的名称，用于特殊用途。 这样的例子有，<code>__init__</code>对象构造函数，或<code>__call__</code> — 它使得一个对象可以被调用。</p><p>这些dunder方法通常被称为<strong>神奇方法</strong> , 但Python开发者们都不喜欢这种方法。</p><blockquote><p><strong>最好避免在自己的程序中使用以双下划线（dunders）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。</strong></p></blockquote><hr><h2 id="5-单下划线"><a href="#5-单下划线" class="headerlink" title="5. 单下划线 _"></a>5. 单下划线 _</h2><p>按照习惯，有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。</p><p>例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用“_”来表示它只是一个临时值：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/5aCkAJ5bK9.png?imageslim" alt="mark"></p><p>你也可以在拆分(unpacking)表达式中将单个下划线用作“不关心的”变量，以忽略特定的值。 同样，这个含义只是“依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。</p><p>在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，“_”作为占位符变量可以派上用场：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/aLg5Hlf4l9.png?imageslim" alt="mark"></p><p>除了用作临时变量之外，“_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。</p><p>这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/E92eeCBbBd.png?imageslim" alt="mark"></p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/hJkhG4JK2k.png?imageslim" alt="mark"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是一个简短的小结，即“速查表”，罗列了我在本文中谈到的五种Python下划线模式的含义：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/Ijebl95g70.png?imageslim" alt="mark"></p><p><br><br><br></p><blockquote><p>英文原文：<a href="https://dbader.org/blog/meaning-of-underscores-in-python" target="_blank" rel="noopener">https://dbader.org/blog/meaning-of-underscores-in-python</a> </p></blockquote><p><hr><br> <center><strong>单前导下划线</strong></center></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python中单下划线和双下划线的各种含义和命名约定，名称修饰的工作原理，以及它如何影响你自己的Python类。&lt;br&gt;
    
    </summary>
    
      <category term="Python Study Notes" scheme="https://liuyang0001.github.io/categories/Python-Study-Notes/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="下划线" scheme="https://liuyang0001.github.io/tags/%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>selenium遇到click失效问题解决</title>
    <link href="https://liuyang0001.github.io/2018/04/11/selenium%E9%81%87%E5%88%B0click%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://liuyang0001.github.io/2018/04/11/selenium遇到click失效问题解决/</id>
    <published>2018-04-11T14:04:56.000Z</published>
    <updated>2018-04-11T15:03:34.596Z</updated>
    
    <content type="html"><![CDATA[<p>在使用selenium webdriver进行爬取淘宝信息，爬取一页结束后，进行翻页操作失败，仔细检查源码，发现在底端输入页码后模拟点击并未生效，本篇记录一下解决问题的办法。<br><a id="more"></a></p><hr><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用谷歌浏览器</span></span><br><span class="line">browser = webdriver.Chrome(executable_path=chromedriver, chrome_options=options)</span><br><span class="line"><span class="comment"># 定义一个等待，方便后面调用</span></span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数功能：跳转到指定页数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump_to_page</span><span class="params">(page)</span>:</span></span><br><span class="line"><span class="comment"># 输入页码</span></span><br><span class="line">    input_page = wait.until(</span><br><span class="line">        EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">"#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input"</span>))</span><br><span class="line">    )</span><br><span class="line">    input_page.clear()</span><br><span class="line">    input_page.send_keys(page)</span><br><span class="line">    <span class="comment"># 等待提交按钮可点击</span></span><br><span class="line">    submit_page = wait.until(</span><br><span class="line">        EC.element_to_be_clickable((By.CLASS_NAME, <span class="string">"btn J_Submit"</span>))</span><br><span class="line">    )</span><br><span class="line">    submit_page.click()</span><br></pre></td></tr></table></figure><p>在这里发现<code>submit_page.click()</code>并未生效。在网页中的这个地方：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180411/kILC2d9kG4.png?imageslim" alt="mark"></p><p>页码可以正常插入，但并未发生跳转，即click方法未生效。</p><hr><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="方法一：先点父元素"><a href="#方法一：先点父元素" class="headerlink" title="方法一：先点父元素"></a>方法一：先点父元素</h2><p>即先点击想要点击的父元素，再点击子元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element_by_css_selector(<span class="string">'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form'</span>).click()</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">'"#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit'</span>).click()</span><br></pre></td></tr></table></figure></p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180411/D4KiHA8Gea.png?imageslim" alt="mark"></p><p><strong>淘宝真的强无敌，该方法并未起作用，是时候放大招了。</strong></p><h1 id="方法二：JS大法好"><a href="#方法二：JS大法好" class="headerlink" title="方法二：JS大法好"></a>方法二：JS大法好</h1><p>即直接用js直接去点击，简单粗暴，但有效。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js = <span class="string">'document.getElementsByClassName("btn J_Submit")[0].click();'</span></span><br><span class="line">browser.execute_script(js)</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用selenium webdriver进行爬取淘宝信息，爬取一页结束后，进行翻页操作失败，仔细检查源码，发现在底端输入页码后模拟点击并未生效，本篇记录一下解决问题的办法。&lt;br&gt;
    
    </summary>
    
      <category term="Spider Study Notes" scheme="https://liuyang0001.github.io/categories/Spider-Study-Notes/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Spider" scheme="https://liuyang0001.github.io/tags/Spider/"/>
    
      <category term="Selenium" scheme="https://liuyang0001.github.io/tags/Selenium/"/>
    
      <category term="web driver" scheme="https://liuyang0001.github.io/tags/web-driver/"/>
    
  </entry>
  
  <entry>
    <title>Django编写Restful-Api：ViewSets与Routers</title>
    <link href="https://liuyang0001.github.io/2018/04/08/Django%E7%BC%96%E5%86%99Restful-Api%EF%BC%9AViewSets%E4%B8%8ERouters/"/>
    <id>https://liuyang0001.github.io/2018/04/08/Django编写Restful-Api：ViewSets与Routers/</id>
    <published>2018-04-08T13:05:07.000Z</published>
    <updated>2018-04-08T13:24:36.986Z</updated>
    
    <content type="html"><![CDATA[<p>在这一篇文章中，要介绍的是另一种基于类的视图的写法，它的抽象程度更高，也可以说是代码量又减少了。<br><a id="more"></a></p><hr><h1 id="使用ViewSets重构视图"><a href="#使用ViewSets重构视图" class="headerlink" title="使用ViewSets重构视图"></a>使用ViewSets重构视图</h1><p>先介绍一下这个ViewSets。ViewSets，翻译过来可以说是视图集，也就是几个视图的集合。</p><p>拿本项目为例子，我们之前查看所有用户列表就要写一个视图类UserList，并在<code>urls.py</code>中为其设置一个模式然后as_view使用它，然后要看单个用户的详情页就要再写一个UserDetail视图类并再在添加一个url模式。同时注意到这两个视图类都是继承的generics.XXXAPIView。而使用ViewSets我们就可以把UserList和UserDetail合并成UserViewSet视图类，并且继承的类改为viewsets.ReadOnlyModelViewSet，这样就是一个视图集了。</p><p>还是有点懵逼？没事，下面看看代码。编辑<code>snippets/view.py</code>，导入viewsets并使用UserViewSet来替换掉UserList和UserDetail：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> viewsets</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span><span class="params">(viewsets.ReadOnlyModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    viewset自动提供了list和detail动作</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br></pre></td></tr></table></figure><p>这里面的queryset和serializer_class的值还是和原来一样。因为关于User的API都是只读的，所以我们继承了一个ReadOnlyModelViewSet类，这样就把原先的两个视图类集合起来了。原本类里面的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queryset = User.objects.all()</span><br><span class="line">serializer_class = UserSerializer</span><br></pre></td></tr></table></figure><p>这部分属于重复代码，所以通过视图集来实现视图类我们的代码量确实减少了，更加简洁。</p><p>ViewSet类与View类其实几乎是相同的,但提供的是read或update这些操作,而不是get或put 等HTTP动作。同时，ViewSet为我们提供了默认的URL结构, 使得我们能更专注于API本身。</p><p>上面这段话呢，是官方文档里面说的，想就这样看看就算了来理解也行，不过如果我们看一下源码也许能理解的更好。因为我用的是PyCharm，所以查看源码很方便，按住CTRL键然后鼠标点击一下就会自动跳转了，首先查看一下ReadOnlyModelViewSet，发现它是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ReadOnlyModelViewSet(mixins.RetrieveModelMixin,</span><br><span class="line">                           mixins.ListModelMixin,</span><br><span class="line">                           GenericViewSet):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    A viewset that provides default `list()` and `retrieve()` actions.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>发现原来有用到之前说的mixins，所以刚才才说ViewSet类与View类其实几乎是相同的。但是这里多了一个GenericViewSet类是新的内容，继续CTRL点击查看其代码，发现它内部只是一个pass然后就没有其他的操作了，但是可以继续查看其父类ViewSetMixin的源码来了解ViewSets，然后就可以看到这个ViewSetMixin其实重写了as_view方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@classonlymethod</span><br><span class="line">    def as_view(cls, actions=None, **initkwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Because of the way class based views create a closure around the</span><br><span class="line">        instantiated view, we need to totally reimplement `.as_view`,</span><br><span class="line">        and slightly modify the view function that is created and returned.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>我们平时使用视图类的时候，编写<code>urls.py</code>时，就一个XXX.as_view()，现在使用ViewSets，需要传入参数，大概像下面这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'list'</span>&#125;)</span><br></pre></td></tr></table></figure><p>之后url就配置好了，也就是上面说的ViewSet为我们提供了默认的URL结构。当然了，这个还不是完整的url模式，稍后补全。</p><p>刚才把User的两个视图类合并成视图集了，那么Snippet的几个视图类操作上也是差不多的。用视图集SnippetViewSet代替SnippetList, SnippetDetail 和 SnippetHighlight这三个视图类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> detail_route</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    viewset自动提供了`list`, `create`, `retrieve`,</span></span><br><span class="line"><span class="string">    `update` 和 `destroy` 动作.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    同时我们手动增加一个额外的'highlight'动作用于查看高亮的代码段</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = Snippet.objects.all()</span><br><span class="line">    serializer_class = SnippetSerializer</span><br><span class="line">    permission_classes = (permissions.IsAuthenticatedOrReadOnly,</span><br><span class="line">                          IsOwnerOrReadOnly,)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @detail_route(renderer_classes=[renderers.StaticHTMLRenderer])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">highlight</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        snippet = self.get_object()</span><br><span class="line">        <span class="keyword">return</span> Response(snippet.highlighted)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">        serializer.save(owner=self.request.user)</span><br></pre></td></tr></table></figure><p>因为查看highlight不像其他动作那样，django-rest-framework并没有替我们封装好，所以我们需要自己添加这个额外的动作，要记得在方法前面加上装饰器@detail_route，这个装饰器就是用来创建自定义的动作，当然我们的自定义动作不可以是create/update/delete这些标准的，否则会有冲突。</p><p>还有一点，用@detail_route装饰器定义的动作默认是GET请求，需要其他的请求方式可以传入methods参数给这个装饰器。同样的，默认情况下，自定义操作的URL取决于方法名称本身。如果要更改url应该构造的方式，可以将url_path作为decorator的关键字参数。</p><p>最后还要注意继承的类是ModelViewSet和刚才的也有点不同，为什么换成这个，也可以看看源码能略知一二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ModelViewSet(mixins.CreateModelMixin,</span><br><span class="line">                   mixins.RetrieveModelMixin,</span><br><span class="line">                   mixins.UpdateModelMixin,</span><br><span class="line">                   mixins.DestroyModelMixin,</span><br><span class="line">                   mixins.ListModelMixin,</span><br><span class="line">                   GenericViewSet):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><h1 id="将ViewSets明确的绑定到URL"><a href="#将ViewSets明确的绑定到URL" class="headerlink" title="将ViewSets明确的绑定到URL"></a>将ViewSets明确的绑定到URL</h1><p>根据上面所说的，每个视图集的url模式都需要我们在as_view中传入参数，把<code>snippets/urls.py</code>的代码换成下面的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url,include</span><br><span class="line"><span class="keyword">from</span> snippets.views <span class="keyword">import</span> SnippetViewSet, UserViewSet, api_root</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> renderers</span><br><span class="line"><span class="keyword">from</span> rest_framework.urlpatterns <span class="keyword">import</span> format_suffix_patterns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">snippet_list = SnippetViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'list'</span>,</span><br><span class="line">    <span class="string">'post'</span>: <span class="string">'create'</span></span><br><span class="line">&#125;)</span><br><span class="line">snippet_detail = SnippetViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'retrieve'</span>,</span><br><span class="line">    <span class="string">'put'</span>: <span class="string">'update'</span>,</span><br><span class="line">    <span class="string">'patch'</span>: <span class="string">'partial_update'</span>,</span><br><span class="line">    <span class="string">'delete'</span>: <span class="string">'destroy'</span></span><br><span class="line">&#125;)</span><br><span class="line">snippet_highlight = SnippetViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'highlight'</span></span><br><span class="line">&#125;, renderer_classes=[renderers.StaticHTMLRenderer])</span><br><span class="line">user_list = UserViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'list'</span></span><br><span class="line">&#125;)</span><br><span class="line">user_detail = UserViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'retrieve'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = format_suffix_patterns([</span><br><span class="line">    url(<span class="string">r'^$'</span>, api_root),</span><br><span class="line">    url(<span class="string">r'^snippets/$'</span>, snippet_list, name=<span class="string">'snippet-list'</span>),</span><br><span class="line">    url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/$'</span>, snippet_detail, name=<span class="string">'snippet-detail'</span>),</span><br><span class="line">    url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$'</span>, snippet_highlight, name=<span class="string">'snippet-highlight'</span>),</span><br><span class="line">    url(<span class="string">r'^users/$'</span>, user_list, name=<span class="string">'user-list'</span>),</span><br><span class="line">    url(<span class="string">r'^users/(?P&lt;pk&gt;[0-9]+)/$'</span>, user_detail, name=<span class="string">'user-detail'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>OK，到了这里对视图的改造已经完成了，可以启动服务器测试一下，我们的项目功能还是和之前的一样的。</p><hr><h1 id="使用Routers"><a href="#使用Routers" class="headerlink" title="使用Routers"></a>使用Routers</h1><p>不过看到<code>urls.py</code>的代码，我们可能会发现一个问题，就是我们的视图类代码简洁了变少了，但是<code>urls.py</code>的代码量好像多了啊，要绑定那么多动作，这样算起来好像也没多大提升？</p><p>确实是这样。但是我们这可是在用python开发啊，当然是能短则短了，没错，django-rest-framework的作者也是这么想的，所以我们又有现成的轮子可以使用了。这个轮子就是本文的另一个主角——<strong>Routers</strong>。用起来也是简单粗暴，重写<code>urls.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url, include</span><br><span class="line"><span class="keyword">from</span> snippets <span class="keyword">import</span> views</span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a router and register our viewsets with it.</span></span><br><span class="line">router = DefaultRouter()</span><br><span class="line">router.register(<span class="string">r'snippets'</span>, views.SnippetViewSet)</span><br><span class="line">router.register(<span class="string">r'users'</span>, views.UserViewSet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The API URLs are now determined automatically by the router.</span></span><br><span class="line"><span class="comment"># Additionally, we include the login URLs for the browsable API.</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^'</span>, include(router.urls)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样就搞定了，代码少了很多，连原来用来设置后缀的下面这行代码都不需要了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = format_suffix_patterns(urlpatterns)</span><br></pre></td></tr></table></figure><p>而且这个DefaultRouter 类还会自动帮我们创建API根视图，也就是说<code>view.py</code>中的api_root方法也可以删除掉了。</p><p>额…这个Routers帮我们做的事情真是有点多啊。。不过这也就是我为什么在文章的前言里面说使用ViewSets会比原本的视图更抽象的原因。</p><p>拿过来用是会了，但是这里面发生了什么我们完全不知道啊，比如说API后缀去哪了？上面我们写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">snippet_list = SnippetViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'list'</span>,</span><br><span class="line">    <span class="string">'post'</span>: <span class="string">'create'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这些绑定全都自动生成了？这些确实都是DefaultRouter 帮我们做好了，怎么做的，我们还是可以看一下源码了解一下大概的过程。首先就是register方法，我们绑定了那么多动作它两行就搞定了，查看它的源码，发现它是BaseRouter类下的一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRouter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.registry = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, prefix, viewset, base_name=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> base_name <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            base_name = self.get_default_base_name(viewset)</span><br><span class="line">        self.registry.append((prefix, viewset, base_name))</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">urls</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'_urls'</span>):</span><br><span class="line">            self._urls = self.get_urls()</span><br><span class="line">        <span class="keyword">return</span> self._urls</span><br></pre></td></tr></table></figure><p>改方法根据传进来的参数生成url端点，也就是/snippets和/users，然后存到registry列表中。并且这个类的最后是一个可以当属性用的方法urls，而这个方法里面又调用了get_urls()来生成所有的url模式，当然这个get_urls()被子类SimpleRouter和子子类DefaultRouter重写了。SimpleRouter中的get_urls()实现了生成是5个url模式，也就是原本的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^snippets/$'</span>,snippet_list,name=<span class="string">'snippet-list'</span>),</span><br><span class="line">url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/$'</span>, snippet_detail, name=<span class="string">'snippet-detail'</span>),</span><br><span class="line">url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$'</span>, snippet_highlight, name=<span class="string">'snippet-highlight'</span>),</span><br><span class="line">url(<span class="string">r'^users/$'</span>, user_list, name=<span class="string">'user-list'</span>),</span><br><span class="line">url(<span class="string">r'^users/(?P&lt;pk&gt;[0-9]+)/$'</span>, user_detail, name=<span class="string">'user-detail'</span>)</span><br></pre></td></tr></table></figure><p>而DefaultRouter中的get_urls()中则生成了api_root的url模式，同时还为这些url模式加了格式后缀，所以我们自己不会用到format_suffix_patterns这个东西。</p><blockquote><p>当然了，并不一定要使用ViewSets的视图代替View，两者各有好处ViewSets节省了很多代码并且url模式也不用我们自己设置了，但是也会带来一些不确定性，自动化的效果有时候可能和你预想的不太一样，所以想要选择哪种方法看你自己喜欢。</p></blockquote><hr><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇文章来自<code>ziv</code>的博客，仅作整理学习分享。<br>点击这里<a href="http://www.comingnext.cn/post/11/" target="_blank" rel="noopener">访问原文</a>。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这一篇文章中，要介绍的是另一种基于类的视图的写法，它的抽象程度更高，也可以说是代码量又减少了。&lt;br&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="https://liuyang0001.github.io/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Django" scheme="https://liuyang0001.github.io/tags/Django/"/>
    
      <category term="Web" scheme="https://liuyang0001.github.io/tags/Web/"/>
    
      <category term="数据库" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Restful-Api" scheme="https://liuyang0001.github.io/tags/Restful-Api/"/>
    
  </entry>
  
</feed>
