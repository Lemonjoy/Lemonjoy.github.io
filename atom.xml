<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Liu&#39;s Tech Blog</title>
  
  <subtitle>Python技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuyang1.club/"/>
  <updated>2020-01-02T08:00:12.867Z</updated>
  <id>http://liuyang1.club/</id>
  
  <author>
    <name>Liu Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1.两数之和</title>
    <link href="http://liuyang1.club/2020/01/02/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://liuyang1.club/2020/01/02/1-两数之和/</id>
    <published>2020-01-02T07:11:09.000Z</published>
    <updated>2020-01-02T08:00:12.867Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组<code>nums</code>和一个目标值<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>通过哈希来求解，这里通过字典来模拟哈希查询的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> hashmap.get(target - num) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>: <span class="comment"># 当前字典中找到对应key</span></span><br><span class="line">                <span class="keyword">return</span> [i,hashmap.get(target - num)]</span><br><span class="line">            hashmap[num] = i <span class="comment"># 未找到则将其加入字典中</span></span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组&lt;code&gt;nums&lt;/code&gt;和一个目标值&lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://liuyang1.club/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Algorithms" scheme="http://liuyang1.club/tags/Algorithms/"/>
    
      <category term="数组" scheme="http://liuyang1.club/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="http://liuyang1.club/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-树</title>
    <link href="http://liuyang1.club/2018/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <id>http://liuyang1.club/2018/09/01/数据结构-树/</id>
    <published>2018-09-01T10:41:01.000Z</published>
    <updated>2018-09-02T16:44:42.689Z</updated>
    
    <content type="html"><![CDATA[<p>基于C/C++二叉树的构建与操作。</p><a id="more"></a><hr><h3 id="二叉树-递归实现"><a href="#二叉树-递归实现" class="headerlink" title="二叉树-递归实现"></a><center>二叉树-递归实现</center></h3><hr><h4 id="树的结点"><a href="#树的结点" class="headerlink" title="树的结点"></a>树的结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> BT_ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    BTNode *L_child, *R_child;<span class="comment">//左右孩子结点的指针</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure><h4 id="树的创建"><a href="#树的创建" class="headerlink" title="树的创建"></a>树的创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode *<span class="title">BiTree_Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data);<span class="comment">//手动输入树的结点值</span></span><br><span class="line">    BTNode *T;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0</span>) <span class="comment">//当遇到0时，令树的根节点为NULL，从而结束该分支的递归</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;<span class="comment">//空分支</span></span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));<span class="comment">//创建新的树节点</span></span><br><span class="line">        <span class="comment">//先序创建树</span></span><br><span class="line">        T-&gt;data = data;<span class="comment">//先给根节点赋值</span></span><br><span class="line">        T-&gt;L_child = BiTree_Create();<span class="comment">//创建左子树</span></span><br><span class="line">        T-&gt;R_child = BiTree_Create();<span class="comment">//创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问结点数据"><a href="#访问结点数据" class="headerlink" title="访问结点数据"></a>访问结点数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问节点数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_Vist_Node</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_Preorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree_Vist_Node(T);</span><br><span class="line">        BiTree_Preorder_Traversal(T-&gt;L_child);</span><br><span class="line">        BiTree_Preorder_Traversal(T-&gt;R_child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_Inorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree_Inorder_Traversal(T-&gt;L_child);</span><br><span class="line">        BiTree_Vist_Node(T);</span><br><span class="line">        BiTree_Inorder_Traversal(T-&gt;R_child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_Postorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree_Postorder_Traversal(T-&gt;L_child);</span><br><span class="line">        BiTree_Postorder_Traversal(T-&gt;R_child);</span><br><span class="line">        BiTree_Vist_Node(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双序遍历"><a href="#双序遍历" class="headerlink" title="双序遍历"></a>双序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的双序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_DblOrder_Traverse</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree_Vist_Node(T);</span><br><span class="line">        BiTree_DblOrder_Traverse(T-&gt;L_child);</span><br><span class="line">        BiTree_Vist_Node(T);</span><br><span class="line">        BiTree_DblOrder_Traverse(T-&gt;R_child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的复制"><a href="#树的复制" class="headerlink" title="树的复制"></a>树的复制</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的复制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiTree_Copy</span><span class="params">(BTNode *T, BTNode *NewT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        NewT = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">        NewT-&gt;data = T-&gt;data;</span><br><span class="line">        BiTree_Copy(T-&gt;L_child, NewT-&gt;L_child);</span><br><span class="line">        BiTree_Copy(T-&gt;R_child, NewT-&gt;R_child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTree_Depth</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = BiTree_Depth(T-&gt;L_child);</span><br><span class="line">        <span class="keyword">int</span> n = BiTree_Depth(T-&gt;R_child);</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> (m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结点个数"><a href="#结点个数" class="headerlink" title="结点个数"></a>结点个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计二叉树中结点的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTree_Node_Count</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BiTree_Node_Count(T-&gt;L_child) + BiTree_Node_Count(T-&gt;R_child) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="二叉树-非递归实现"><a href="#二叉树-非递归实现" class="headerlink" title="二叉树-非递归实现"></a><center>二叉树-非递归实现</center></h3><hr><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    BTNode *L_child, *R_child;</span><br><span class="line">    <span class="keyword">int</span> visitCount;<span class="comment">//用于非递归的后序遍历</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历-使用栈(Stack)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> &lt;BTNode *&gt; TreeStack;<span class="comment">//声明一个树的栈名为TreeStack</span></span><br><span class="line">    BTNode *p = T; <span class="comment">//辅助结点指针</span></span><br><span class="line">    <span class="keyword">while</span> (p || !TreeStack.empty())<span class="comment">//p不指向NULL或者栈内非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)<span class="comment">//p不指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);<span class="comment">//访问结点值</span></span><br><span class="line">            TreeStack.push(p);<span class="comment">//将p压入栈中,后进先出</span></span><br><span class="line">            p = p-&gt;L_child;<span class="comment">//p指向他的左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//p指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = TreeStack.top();<span class="comment">//取得栈顶指针</span></span><br><span class="line">            TreeStack.pop();<span class="comment">//开始出栈,即访问左节点为空</span></span><br><span class="line">            p = p-&gt;R_child;<span class="comment">//开始访问出战的左节点为空的父节点的右结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder_Traverse</span><span class="params">(BTNode* T)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">stack</span> &lt;BTNode*&gt; TreeStack;</span><br><span class="line">    BTNode* p = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p || !TreeStack.empty())<span class="comment">//p不指向NULL或者栈非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)<span class="comment">//p不指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeStack.push(p);<span class="comment">//压进栈内</span></span><br><span class="line">            p = p-&gt;L_child;<span class="comment">//访问他的左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//p指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = TreeStack.top();<span class="comment">//取得栈顶指针</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);<span class="comment">//访问根节点</span></span><br><span class="line">            TreeStack.pop();<span class="comment">//根结点的左孩子开始出栈</span></span><br><span class="line">            p = p-&gt;R_child;<span class="comment">//访问目前根节点的右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BTNode *&gt; TreeStack;</span><br><span class="line">    BTNode *p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !TreeStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="comment">//不指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;visitCount = <span class="number">1</span>; <span class="comment">//访问根节点一次</span></span><br><span class="line">            TreeStack.push(p); <span class="comment">//压入栈中</span></span><br><span class="line">            p = p-&gt;L_child;    <span class="comment">//访问左结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//指向NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = TreeStack.top();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;visitCount == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeStack.pop(); <span class="comment">//出栈</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data); <span class="comment">//读出栈顶的值</span></span><br><span class="line">                p = <span class="literal">NULL</span>;<span class="comment">//指向空</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//只有访问过一次</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;visitCount++;   <span class="comment">//访问次数+1</span></span><br><span class="line">                p = p-&gt;R_child;    <span class="comment">//访问右孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Levelorder_Traversal</span><span class="params">(BTNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BTNode *&gt; TreeQueue; <span class="comment">//调用队列</span></span><br><span class="line">    TreeQueue.push(T);<span class="comment">//树的根节点入队</span></span><br><span class="line">    BTNode *p = T;</span><br><span class="line">    <span class="keyword">while</span> (!TreeQueue.empty())<span class="comment">//队列非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = TreeQueue.front();<span class="comment">//指向队头</span></span><br><span class="line">        TreeQueue.pop();<span class="comment">//出队</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);<span class="comment">//取值</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;L_child)<span class="comment">//存在左结点,入队</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeQueue.push(p-&gt;L_child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;R_child)<span class="comment">//存在右结点,入队</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeQueue.push(p-&gt;R_child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="调用栈与队列"><a href="#调用栈与队列" class="headerlink" title="调用栈与队列"></a><center>调用栈与队列</center></h3><hr><h4 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//使用命名空间调用队列堆栈</span></span><br></pre></td></tr></table></figure><h4 id="引入头文件"><a href="#引入头文件" class="headerlink" title="引入头文件"></a>引入头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;BTNode *&gt; TreeStack;      <span class="comment">//声明一个元素为树结点指针的栈，名为TreeStack</span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xx.empty() <span class="comment">//为空则返回真</span></span><br><span class="line">xx.pop() <span class="comment">//删除元素</span></span><br><span class="line">xx.push() <span class="comment">//增加元素</span></span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a><center>测试源码</center></h3><hr><p><br></p><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/BiTree" target="_blank" rel="noopener">递归/非递归实现源码，请点击这里获取</a></strong></center><p><br></p><hr><center><strong>随时补充</strong></center><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于C/C++二叉树的构建与操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structure Study Notes" scheme="http://liuyang1.club/categories/Data-Structure-Study-Notes/"/>
    
    
      <category term="C/C++" scheme="http://liuyang1.club/tags/C-C/"/>
    
      <category term="Tree" scheme="http://liuyang1.club/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-队</title>
    <link href="http://liuyang1.club/2018/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F/"/>
    <id>http://liuyang1.club/2018/09/01/数据结构-队/</id>
    <published>2018-09-01T05:55:46.000Z</published>
    <updated>2018-09-01T10:11:29.187Z</updated>
    
    <content type="html"><![CDATA[<p>基于C/C++顺序队列和链式队列的构建与操作。</p><a id="more"></a><hr><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a><center>顺序队列</center></h3><hr><h4 id="队的结构"><a href="#队的结构" class="headerlink" title="队的结构"></a>队的结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqQueue</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear; <span class="comment">// 队列头和队列尾</span></span><br><span class="line">&#125;SeqQueue;</span><br></pre></td></tr></table></figure><h4 id="队的操作"><a href="#队的操作" class="headerlink" title="队的操作"></a>队的操作</h4><h5 id="初始化空队"><a href="#初始化空队" class="headerlink" title="初始化空队"></a>初始化空队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化空队列</span></span><br><span class="line"><span class="function">SeqQueue *<span class="title">SeqQueue_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqQueue *Q = (SeqQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqQueue));<span class="comment">//分配内存</span></span><br><span class="line">    Q-&gt;rear = Q-&gt;front = <span class="number">0</span>;<span class="comment">//初始化对手与队尾</span></span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="是否空队"><a href="#是否空队" class="headerlink" title="是否空队"></a>是否空队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否空队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqQueue_Is_Empty</span><span class="params">(SeqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)<span class="comment">//队首与队尾相同时为空队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqQueue_Push</span><span class="params">(SeqQueue *Q, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MaxSize == Q-&gt;front) <span class="comment">//判断是否队满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The Queue has been full.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Elem %d has been in the Queue.\n"</span>, Q-&gt;data[Q-&gt;rear]);</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqQueue_Pop</span><span class="params">(SeqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SeqQueue_Is_Empty(Q)) <span class="comment">//如果空队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Elem %d has been out of the Queue.\n"</span>, Q-&gt;data[Q-&gt;front]);</span><br><span class="line">    Q-&gt;data[Q-&gt;front] = <span class="literal">NULL</span>; <span class="comment">//清空队首元素，队首上移</span></span><br><span class="line">    Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MaxSize; <span class="comment">//循环队列操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历打印"><a href="#遍历打印" class="headerlink" title="遍历打印"></a>遍历打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue_Print</span><span class="params">(SeqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Q-&gt;front; (i + <span class="number">1</span>) % MaxSize != Q-&gt;rear; i++)<span class="comment">//取余判断是否循环一遍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, Q-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a><center>链式队列</center></h3><hr><h4 id="链式队列结构"><a href="#链式队列结构" class="headerlink" title="链式队列结构"></a>链式队列结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    QNode *next;<span class="comment">//指针域</span></span><br><span class="line">&#125; QNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedQueue</span>&#123;</span></span><br><span class="line">    QNode *front, *rear; <span class="comment">// 队列头和队列尾</span></span><br><span class="line">&#125;LinkedQueue;</span><br></pre></td></tr></table></figure><h4 id="链式队列操作"><a href="#链式队列操作" class="headerlink" title="链式队列操作"></a>链式队列操作</h4><h5 id="空队初始化"><a href="#空队初始化" class="headerlink" title="空队初始化"></a>空队初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化空队列</span></span><br><span class="line"><span class="function">LinkedQueue* <span class="title">LinkedQueue_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedQueue *Q = (LinkedQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedQueue));</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = (QNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));<span class="comment">//分配空间给两个指针域结点</span></span><br><span class="line">    Q-&gt;rear-&gt;next = Q-&gt;front-&gt;next = <span class="literal">NULL</span>; <span class="comment">//初始de后继指针均指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedQueue_Push</span><span class="params">(LinkedQueue *Q, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//链式队列不用考虑满队</span></span><br><span class="line">    QNode *r = (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));<span class="comment">//新结点</span></span><br><span class="line">    r-&gt;data = x;                              <span class="comment">//插入元素</span></span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;                           <span class="comment">//后继结点为空</span></span><br><span class="line">    Q-&gt;rear-&gt;next = r;                        <span class="comment">//Q的原队尾结点指向s</span></span><br><span class="line">    Q-&gt;rear = r;                              <span class="comment">//更新队尾指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Elem %d has been in the Queue.\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队,需要注意头节点的问题</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedQueue_Pop</span><span class="params">(LinkedQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LinkedQueue_Is_Empty(Q)) <span class="comment">//如果空队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    QNode *s=Q-&gt;front-&gt;next;<span class="comment">//辅助结点,指向头结点的下一个</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Elem %d has been out of the Queue.\n"</span>,s-&gt;data);<span class="comment">//跳过头节点</span></span><br><span class="line">    Q-&gt;front-&gt;next = s-&gt;next;</span><br><span class="line">    <span class="comment">// Q-&gt;front = Q-&gt;front-&gt;next; //队首后移动</span></span><br><span class="line">    <span class="built_in">free</span>(s);<span class="comment">//释放原来的头结点后继</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="是否非空"><a href="#是否非空" class="headerlink" title="是否非空"></a>是否非空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否空队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedQueue_Is_Empty</span><span class="params">(LinkedQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front==Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历打印-1"><a href="#遍历打印-1" class="headerlink" title="遍历打印"></a>遍历打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkedQueue_Print</span><span class="params">(LinkedQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Q-&gt;front-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, Q-&gt;front-&gt;next-&gt;data);</span><br><span class="line">        Q-&gt;front = Q-&gt;front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a><center>测试源码</center></h3><hr><p><br></p><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/SeqQueue" target="_blank" rel="noopener">顺序队列源码，请点击这里获取</a></strong></center><p><br></p><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/LinkedQueue" target="_blank" rel="noopener">链式队列源码，请点击这里获取</a></strong></center><p><br></p><hr><center><strong>随时补充</strong></center><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于C/C++顺序队列和链式队列的构建与操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structure Study Notes" scheme="http://liuyang1.club/categories/Data-Structure-Study-Notes/"/>
    
    
      <category term="C/C++" scheme="http://liuyang1.club/tags/C-C/"/>
    
      <category term="Queue" scheme="http://liuyang1.club/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="http://liuyang1.club/2018/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>http://liuyang1.club/2018/08/31/数据结构-栈/</id>
    <published>2018-08-31T13:07:03.000Z</published>
    <updated>2018-09-01T08:53:00.481Z</updated>
    
    <content type="html"><![CDATA[<p>基于C/C++顺序栈和链栈的构建与操作。</p><a id="more"></a><hr><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a><center>顺序栈</center></h3><hr><h4 id="栈的结构"><a href="#栈的结构" class="headerlink" title="栈的结构"></a>栈的结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;    <span class="comment">//栈的栈顶</span></span><br><span class="line">&#125; SeqStack;</span><br></pre></td></tr></table></figure><h4 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h4><h5 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqStack_Push</span><span class="params">(SeqStack *S, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top &gt;= MaxSize - <span class="number">1</span>)<span class="comment">//若栈满，拒绝入栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S-&gt;data[++S-&gt;top] = x; <span class="comment">//先移动指针。再赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈,返回出栈元素值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqStack_Pop</span><span class="params">(SeqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) <span class="comment">//若空栈，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ElemType x = S-&gt;data[S-&gt;top--];<span class="comment">//取得出栈元素后，top指针下移</span></span><br><span class="line">    S-&gt;data[S-&gt;top + <span class="number">1</span>] = <span class="literal">NULL</span>;<span class="comment">//将要删除的元素删除</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ELm %d has been out\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自动建栈"><a href="#自动建栈" class="headerlink" title="自动建栈"></a>自动建栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动建栈</span></span><br><span class="line"><span class="function">SeqStack *<span class="title">Create_SeqStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqStack *S; <span class="comment">//定义栈</span></span><br><span class="line">    S = (SeqStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqStack));</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>; <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SeqStack_Push(S, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历打印"><a href="#遍历打印" class="headerlink" title="遍历打印"></a>遍历打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从栈顶遍历顺序栈元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_SeqStack_FromTop</span><span class="params">(SeqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NULL"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = S-&gt;top; x &gt; <span class="number">-1</span>; x--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, S-&gt;data[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a><center>链栈</center></h3><hr><h4 id="栈的结构-1"><a href="#栈的结构-1" class="headerlink" title="栈的结构"></a>栈的结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式栈的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; SNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式栈的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedStack</span>&#123;</span></span><br><span class="line">    SNode *top;  <span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">//链式栈的结点数</span></span><br><span class="line">&#125; LinkedStack;</span><br></pre></td></tr></table></figure><h4 id="栈的操作-1"><a href="#栈的操作-1" class="headerlink" title="栈的操作"></a>栈的操作</h4><h5 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedStack_Push</span><span class="params">(LinkedStack *S, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SNode *p = (SNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));<span class="comment">//申请新结点内存</span></span><br><span class="line">    p-&gt;data = x;<span class="comment">//赋值</span></span><br><span class="line">    p-&gt;next = S-&gt;top;<span class="comment">//p得后继指针指向原来的栈顶</span></span><br><span class="line">    S-&gt;top = p;<span class="comment">//将栈顶指针移动到新结点</span></span><br><span class="line">    S-&gt;count++;<span class="comment">//增加结点数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedStack_Pop</span><span class="params">(LinkedStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!S-&gt;top)<span class="comment">//判定是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ElemType x = S-&gt;top-&gt;data;<span class="comment">//得到出栈元素</span></span><br><span class="line">    SNode *p = S-&gt;top;<span class="comment">//辅助指针指向栈顶</span></span><br><span class="line">    S-&gt;top = S-&gt;top-&gt;next;<span class="comment">//移动栈顶指针到原栈顶指针的后继</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放掉原栈顶</span></span><br><span class="line">    S-&gt;count--;<span class="comment">//结点数-1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Elem %d has been out of stack\n"</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自动建栈-1"><a href="#自动建栈-1" class="headerlink" title="自动建栈"></a>自动建栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动建栈</span></span><br><span class="line"><span class="function">LinkedStack *<span class="title">Create_LinkedStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedStack *S;</span><br><span class="line">     S = (LinkedStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));<span class="comment">//申请内存</span></span><br><span class="line">    S-&gt;count = <span class="number">0</span>;<span class="comment">//初始化结点数</span></span><br><span class="line">    S-&gt;top = <span class="literal">NULL</span>;<span class="comment">//初始化栈顶指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkedStack_Push(S, x);<span class="comment">//进栈操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历打印-1"><a href="#遍历打印-1" class="headerlink" title="遍历打印"></a>遍历打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_LinkedStack_FromTop</span><span class="params">(LinkedStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SNode *p = S-&gt;top;</span><br><span class="line">    <span class="keyword">while</span> (p)<span class="comment">//当栈顶指针不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a><center>测试源码</center></h3><hr><p><br></p><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/LinkedList" target="_blank" rel="noopener">链式栈源码，请点击这里获取</a></strong></center><p><br></p><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/SeqList" target="_blank" rel="noopener">顺序栈源码，请点击这里获取</a></strong></center><p><br></p><hr><center><strong>随时补充</strong></center><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于C/C++顺序栈和链栈的构建与操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structure Study Notes" scheme="http://liuyang1.club/categories/Data-Structure-Study-Notes/"/>
    
    
      <category term="C/C++" scheme="http://liuyang1.club/tags/C-C/"/>
    
      <category term="Stack" scheme="http://liuyang1.club/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-表</title>
    <link href="http://liuyang1.club/2018/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%A1%A8/"/>
    <id>http://liuyang1.club/2018/08/29/数据结构-表/</id>
    <published>2018-08-29T13:28:51.000Z</published>
    <updated>2018-09-01T05:44:04.279Z</updated>
    
    <content type="html"><![CDATA[<p>基于C/C++顺序表和链表的构建与操作。</p><a id="more"></a><hr><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a><center>顺序表</center></h3><hr><h4 id="静态表结构"><a href="#静态表结构" class="headerlink" title="静态表结构"></a>静态表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态顺序表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList_Static</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SeqList_Static;</span><br></pre></td></tr></table></figure><h4 id="静态表操作"><a href="#静态表操作" class="headerlink" title="静态表操作"></a>静态表操作</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表初始化</span></span><br><span class="line"><span class="function">SeqList_Static *<span class="title">SeqList_Static_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一次性开辟存储空间</span></span><br><span class="line">    SeqList_Static *L = (SeqList_Static *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList_Static));</span><br><span class="line">    L-&gt;data[<span class="number">0</span>] = <span class="literal">NULL</span>;<span class="comment">//初始化为空，长度为0</span></span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化时，顺序插入0-9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[i] = i;</span><br><span class="line">        L-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="顺序打印"><a href="#顺序打印" class="headerlink" title="顺序打印"></a>顺序打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态链表的打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Static_Print</span><span class="params">(SeqList_Static *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, L-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="元素插入"><a href="#元素插入" class="headerlink" title="元素插入"></a>元素插入</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态链表——插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqList_Static_Insert</span><span class="params">(SeqList_Static *L, <span class="keyword">int</span> i, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//判断插入位置的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; L-&gt;length <span class="keyword">or</span> i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 要插入位置的后面结点循环右移一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L-&gt;length; j &gt;= i; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[j] = L-&gt;data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>] = x;<span class="comment">//插入元素</span></span><br><span class="line">    L-&gt;length++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n插入之后的链表为:\n"</span>);</span><br><span class="line">    SeqList_Static_Print(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态链表——删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqList_Static_Delete</span><span class="params">(SeqList_Static *L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断要删除位置的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; L-&gt;length <span class="keyword">or</span> i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 要删除位置的后面结点循环左移一位</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[i<span class="number">-1</span>] = L-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除之后的链表为:\n"</span>);</span><br><span class="line">    SeqList_Static_Print(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="动态表结构"><a href="#动态表结构" class="headerlink" title="动态表结构"></a>动态表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100         <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10         <span class="comment">//预定义顺序表初始长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ListIncrement 10    <span class="comment">//预定义顺序表扩充增量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;       <span class="comment">//元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态顺序表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span>&#123;</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="keyword">int</span> length,capacity;<span class="comment">//长度，动态的最大容量</span></span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure><h4 id="动态表操作"><a href="#动态表操作" class="headerlink" title="动态表操作"></a>动态表操作</h4><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态表初始化</span></span><br><span class="line"><span class="function">SeqList *<span class="title">SeqList_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqList *L = (SeqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList));</span><br><span class="line">    L-&gt;data = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * InitSize);<span class="comment">//不加会出错 不懂为什么</span></span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    L-&gt;capacity = InitSize; <span class="comment">//动态的空间最大量</span></span><br><span class="line">    L-&gt;data[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//初始化时，顺序插入0-9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[i] = i;</span><br><span class="line">        L-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Locate</span><span class="params">(SeqList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i<span class="number">-1</span>]==e)<span class="keyword">return</span> i;         <span class="comment">//返回第i个元素(下标为i-1值为e)的位号i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                               <span class="comment">//返回0表明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert_Seq</span><span class="params">(SeqList *L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//i的位置不合法</span></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length &gt;= L-&gt;capacity)</span><br><span class="line">    &#123;                                                                                                   <span class="comment">//当前长度已达到最大容量，扩充分配存储空间</span></span><br><span class="line">        ElemType *newbase = (ElemType *)<span class="built_in">realloc</span>(L-&gt;data, <span class="keyword">sizeof</span>(ElemType) * (InitSize + ListIncrement)); <span class="comment">//顺序表扩充</span></span><br><span class="line">        <span class="keyword">if</span> (!newbase)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//存储分配失败</span></span><br><span class="line">        L-&gt;data = newbase;           <span class="comment">//新基址</span></span><br><span class="line">        L-&gt;capacity += ListIncrement; <span class="comment">//增加存储容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L-&gt;length; j &gt;= i; j--) <span class="comment">//第i个元素以及其后的元素右移1个位置</span></span><br><span class="line">        L-&gt;data[j] = L-&gt;data[j - <span class="number">1</span>];</span><br><span class="line">    L-&gt;data[i - <span class="number">1</span>] = e; <span class="comment">//腾出一个空位置插入新元素</span></span><br><span class="line">    L-&gt;length++;        <span class="comment">//表当前长度+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete_Seq</span><span class="params">(SeqList &amp;L,<span class="keyword">int</span> i,ElemType&amp; e)</span></span>&#123;<span class="comment">//删除第i个位置（1&lt;=i&lt;=L.length）元素</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//i的位置不合法</span></span><br><span class="line">    e=L.data[i<span class="number">-1</span>];                  <span class="comment">//将被删除的元素用引用变量e返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;L.length;j++)     <span class="comment">//第i个位置之后元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">    L.length--;                     <span class="comment">//表长度-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a><center>单链表</center></h3><hr><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建单链表结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域，用于指向下一个结点</span></span><br><span class="line">&#125; LNode, *LinkedList;</span><br></pre></td></tr></table></figure><h4 id="单链表创建"><a href="#单链表创建" class="headerlink" title="单链表创建"></a>单链表创建</h4><h5 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h5><p>以顺序插入0-9为例创建带有头结点的单链表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法创建单链表</span></span><br><span class="line"><span class="function">LinkedList <span class="title">Create_LinkedList_H</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *L;<span class="comment">//创建头结点</span></span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//开辟头结点存储空间</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//默认将头结点指向空</span></span><br><span class="line">    LNode *s; <span class="comment">//创建辅助结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)<span class="comment">//0-9循环入队</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//开辟新的结点空间</span></span><br><span class="line">        s-&gt;data = x;<span class="comment">//1.为新的结点赋值</span></span><br><span class="line">        s-&gt;next = L-&gt;next;<span class="comment">//2.将新结点的后继指针指向头节点原来的后继，即插入到头结点后面</span></span><br><span class="line">        L-&gt;next = s;   <span class="comment">//3.最后修改头结点的后继指针指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;<span class="comment">//返回生成的链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾插法创建单链表</span></span><br><span class="line"><span class="function">LinkedList <span class="title">Create_LinkedList_R</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *L;<span class="comment">//创建头结点</span></span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//开辟结点空间</span></span><br><span class="line">    LNode *s;     <span class="comment">//辅助节点指针</span></span><br><span class="line">    LNode *r = L; <span class="comment">//相当于尾指针，当前初始指向头结点</span></span><br><span class="line">    <span class="keyword">for</span> (ElemType x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//开辟新节点空间</span></span><br><span class="line">        s-&gt;data = x; <span class="comment">//将新结点赋值</span></span><br><span class="line">        r-&gt;next = s; <span class="comment">//将新结点接到当前尾指针的后端</span></span><br><span class="line">        r = s;       <span class="comment">//将尾指针移到最后的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将最后得结点后继指针指向空</span></span><br><span class="line">    <span class="keyword">return</span> L;<span class="comment">//返回新的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表操作"><a href="#单链表操作" class="headerlink" title="单链表操作"></a>单链表操作</h4><h5 id="遍历打印"><a href="#遍历打印" class="headerlink" title="遍历打印"></a>遍历打印</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历打印带头结点的单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_LinkedList</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;<span class="comment">//跳过头结点</span></span><br><span class="line">    <span class="keyword">for</span> (; p; p = p-&gt;next)<span class="comment">//循环遍历链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找元素-1"><a href="#查找元素-1" class="headerlink" title="查找元素"></a>查找元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照序号查找元素</span></span><br><span class="line"><span class="function">LinkedList <span class="title">GetElem_By_Number</span><span class="params">(LinkedList L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)<span class="comment">//查找第一个元素，则直接返回头结点的后继结点</span></span><br><span class="line">        <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; = <span class="number">0</span>)<span class="comment">//非法查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L-&gt;next;<span class="comment">//跳过头结点</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i)<span class="comment">//当p非空且未到循环次数</span></span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;<span class="comment">//跳到下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//返回p的指针位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照值来查找元素</span></span><br><span class="line"><span class="function">LinkedList <span class="title">GetElem_By_Value</span><span class="params">(LinkedList L, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span> || x == <span class="literal">NULL</span>)<span class="comment">//其一为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p = L-&gt;next;<span class="comment">//跳过头结点</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;data != x)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//返回指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在第i个结点处插入新结点</span></span><br><span class="line"><span class="function">LinkedList <span class="title">Insert_LinkedList</span><span class="params">(LinkedList &amp;L, <span class="keyword">int</span> i, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = GetElem_By_Number(L, i - <span class="number">1</span>);<span class="comment">//得到要插入元素的前一个结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//开辟存储空间</span></span><br><span class="line">    s-&gt;data = x;<span class="comment">//赋值</span></span><br><span class="line">    s-&gt;next = p-&gt;next;<span class="comment">//将新节点的后继指向要插入位置的后一个结点</span></span><br><span class="line">    p-&gt;next = s;<span class="comment">//将要插入位置的前一个元素的后继指向新节点</span></span><br><span class="line">    <span class="keyword">return</span> L;<span class="comment">//返回新链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第i个结点</span></span><br><span class="line"><span class="function">LinkedList <span class="title">Delete_LinkedList</span><span class="params">(LinkedList &amp;L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = GetElem_By_Number(L, i - <span class="number">1</span>);<span class="comment">//p指向删除元素的前一个结点</span></span><br><span class="line">    LNode *q = p-&gt;next; <span class="comment">//q指向要删除的结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;  <span class="comment">//前一个直接跳过要删除元素指向要删除元素的后继</span></span><br><span class="line">    <span class="built_in">free</span>(q);            <span class="comment">//释放掉q的空间</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a><center>双链表</center></h3><hr><h4 id="结点结构-1"><a href="#结点结构-1" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义双链表结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span><span class="comment">//双指针</span></span><br><span class="line">&#125;DLNode;</span><br></pre></td></tr></table></figure><h4 id="双链表操作"><a href="#双链表操作" class="headerlink" title="双链表操作"></a>双链表操作</h4><h5 id="头插法创建单链表"><a href="#头插法创建单链表" class="headerlink" title="头插法创建单链表"></a>头插法创建单链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法建立双链表</span></span><br><span class="line"><span class="function">DLNode *<span class="title">Create_Double_LinkedList_H</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *L;                            <span class="comment">//头结点L</span></span><br><span class="line">    L = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode)); <span class="comment">//为头结点分配内存</span></span><br><span class="line">    L-&gt;next = L;                          <span class="comment">//初始化指针</span></span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    DLNode *s; <span class="comment">//新结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">        s-&gt;data = i;</span><br><span class="line">        L-&gt;next-&gt;prior = s;</span><br><span class="line">        s-&gt;prior = L;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尾插法创建双链表"><a href="#尾插法创建双链表" class="headerlink" title="尾插法创建双链表"></a>尾插法创建双链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法建立双链表</span></span><br><span class="line"><span class="function">DLNode *<span class="title">Create_Double_LinkedList_R</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *L = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">    L-&gt;prior = L-&gt;next = L;</span><br><span class="line">    DLNode *s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DLNode *r = L-&gt;prior; <span class="comment">//定义为尾指针</span></span><br><span class="line">        s = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">        s-&gt;data = i;<span class="comment">//赋值</span></span><br><span class="line">        r-&gt;next = s;<span class="comment">//原尾指针后继指向新结点</span></span><br><span class="line">        s-&gt;prior = r;<span class="comment">//新结点前驱指向原尾结点</span></span><br><span class="line">        s-&gt;next = L;<span class="comment">//新结点的后继为头结点</span></span><br><span class="line">        L-&gt;prior = s; <span class="comment">//头结点的前驱为新结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="打印双链表"><a href="#打印双链表" class="headerlink" title="打印双链表"></a>打印双链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印双循环链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Double_LinkedList</span><span class="params">(DLNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *p = L-&gt;next; <span class="comment">//p跳过头结点，指向第一个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><center><strong>···</strong></center><hr><h3 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a><center>测试源码</center></h3><hr><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/LinkedList" target="_blank" rel="noopener">链表源码，请点击这里获取</a></strong></center><center><strong><a href="https://github.com/Liuyang0001/Data_Structures/tree/master/SeqList" target="_blank" rel="noopener">顺序表源码，请点击这里获取</a></strong></center><p><br></p><hr><center><strong>随时补充</strong></center><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于C/C++顺序表和链表的构建与操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structure Study Notes" scheme="http://liuyang1.club/categories/Data-Structure-Study-Notes/"/>
    
    
      <category term="C/C++" scheme="http://liuyang1.club/tags/C-C/"/>
    
      <category term="Linked List" scheme="http://liuyang1.club/tags/Linked-List/"/>
    
      <category term="Sequence List" scheme="http://liuyang1.club/tags/Sequence-List/"/>
    
  </entry>
  
  <entry>
    <title>Python下划线</title>
    <link href="http://liuyang1.club/2018/04/21/Python%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    <id>http://liuyang1.club/2018/04/21/Python下划线/</id>
    <published>2018-04-21T07:40:15.000Z</published>
    <updated>2018-08-31T11:19:06.798Z</updated>
    
    <content type="html"><![CDATA[<p>Python中单下划线和双下划线的各种含义和命名约定，名称修饰的工作原理，以及它如何影响你自己的Python类。<br><a id="more"></a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>单下划线和双下划线在Python变量和方法名称中都各有其含义。有一些含义仅仅是依照约定，被视作是对程序员的提示 - 而有一些含义是由Python解释器严格执行的。</p><p>在本文中，我们将讨论以下五种下划线模式和命名约定，以及它们如何影响Python程序的行为：</p><blockquote><ul><li>单前导下划线：<code>_var</code></li></ul></blockquote><blockquote><ul><li>单末尾下划线：<code>var_</code></li></ul></blockquote><blockquote><ul><li>双前导下划线：<code>__var</code></li></ul></blockquote><blockquote><ul><li>双前导和末尾下划线：<code>__var__</code></li></ul></blockquote><blockquote><ul><li>单下划线：<code>_</code></li></ul></blockquote><hr><h2 id="1-单前导下划线-var"><a href="#1-单前导下划线-var" class="headerlink" title="1. 单前导下划线 _var"></a>1. 单前导下划线 _var</h2><p>当涉及到变量和方法名称时，单个下划线前缀有一个约定俗成的含义。 它是对程序员的一个提示 - 意味着Python开发人员一致认为它应该是什么意思，但程序的行为不受影响。</p><p>下划线前缀的含义是告知其他程序员：以单个下划线开头的变量或方法仅供内部使用。 该约定在PEP 8中有定义。</p><p>这不是Python强制规定的。 Python不像Java那样在“私有”和“公共”变量之间有很强的区别。 这就像有人提出了一个小小的下划线警告标志，说：</p><blockquote><p>“嘿，这不是真的要成为类的公共接口的一部分。不去管它就好。“</p></blockquote><p>看看下面的例子：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/jiJG3iG731.png?imageslim" alt="mark"></p><p>如果你实例化此类，并尝试访问在<code>__init__</code>构造函数中定义的foo和_bar属性，会发生什么情况？ 让我们来看看：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/CCJlima0Be.png?imageslim" alt="mark"><br>你会看到_bar中的单个下划线并没有阻止我们“进入”类并访问该变量的值。</p><p>这是因为Python中的单个下划线前缀仅仅是一个约定 - 至少相对于变量和方法名而言。</p><p><strong>但是，前导下划线的确会影响从模块中导入名称的方式。</strong><br>假设你在一个名为my_module的模块中有以下代码：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/AE8GgieLK9.png?imageslim" alt="mark"></p><p>现在，如果使用通配符从模块中导入所有名称，则Python不会导入带有前导下划线的名称（除非模块定义了覆盖此行为的<code>__all__</code>列表）：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/7f4F1iK97c.png?imageslim" alt="mark"></p><p>顺便说一下，应该避免通配符导入，因为它们使名称空间中存在哪些名称不清楚。 为了清楚起见，坚持常规导入更好。</p><p>与通配符导入不同，常规导入不受前导单个下划线命名约定的影响：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/I6eH9JAbDa.png?imageslim" alt="mark"></p><p>我知道这一点可能有点令人困惑。 如果你遵循PEP 8推荐，避免通配符导入，那么你真正需要记住的只有这个：</p><blockquote><p>单个下划线是一个Python命名约定，表示这个名称是供内部使用的。 它通常不由Python解释器强制执行，仅仅作为一种对程序员的提示。</p></blockquote><hr><h2 id="2-单末尾下划线-var"><a href="#2-单末尾下划线-var" class="headerlink" title="2. 单末尾下划线 var_"></a>2. 单末尾下划线 var_</h2><p>有时候，一个变量的最合适的名称已经被一个关键字所占用。 因此，像class或def这样的名称不能用作Python中的变量名称。 在这种情况下，你可以附加一个下划线来解决命名冲突：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/E21Dd9i5a4.png?imageslim" alt="mark"><br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/FAhCKb65F7.png?imageslim" alt="mark"><br>总之，单个末尾下划线（后缀）是一个约定，用来避免与Python关键字产生命名冲突。 PEP 8解释了这个约定。</p><hr><h2 id="3-双前导下划线-var"><a href="#3-双前导下划线-var" class="headerlink" title="3. 双前导下划线 __var"></a>3. 双前导下划线 __var</h2><p>到目前为止，我们所涉及的所有命名模式的含义，来自于已达成共识的约定。 而对于以双下划线开头的Python类的属性（包括变量和方法），情况就有点不同了。</p><p>双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。</p><p>这也叫做名称修饰（name mangling） - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。</p><p>我知道这听起来很抽象。 因此，我组合了一个小小的代码示例来予以说明：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/DbAK29Ha92.png?imageslim" alt="mark"></p><p>让我们用内置的dir()函数来看看这个对象的属性：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/dlfg2f36Jc.png?imageslim" alt="mark"></p><p>以上是这个对象属性的列表。 让我们来看看这个列表，并寻找我们的原始变量名称<code>foo</code>，<code>_bar</code>和<code>__baz</code> - 我保证你会注意到一些有趣的变化。</p><p><code>self.foo</code>变量在属性列表中显示为未修改为foo。</p><p><code>self._bar</code>的行为方式相同 - 它以<code>_bar</code>的形式显示在类上。 就像我之前说过的，在这种情况下，前导下划线仅仅是一个约定。 给程序员一个提示而已。</p><p>然而，对于<code>self.__baz</code>而言，情况看起来有点不同。 当你在该列表中搜索__baz时，你会看不到有这个名字的变量。</p><p><strong>__baz出什么情况了？</strong></p><p>如果你仔细观察，你会看到此对象上有一个名为<code>_Test__baz</code>的属性。 这就是Python解释器所做的名称修饰。 它这样做是<strong>为了防止变量在子类中被重写。</strong></p><p>让我们创建另一个扩展Test类的类，并尝试重写构造函数中添加的现有属性：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/iljAIbcJbe.png?imageslim" alt="mark"></p><p>等一下，当我们尝试查看<code>t2 .__ baz</code>的值时，为什么我们会得到AttributeError？ 名称修饰被再次触发了！ 事实证明，这个对象甚至没有__baz属性：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/leg0kGGG0K.png?imageslim" alt="mark"></p><p>正如你可以看到<code>__baz</code>变成<code>_ExtendedTest__baz</code>以防止意外修改：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/CHGlhCF4Cm.png?imageslim" alt="mark"></p><p>但原来的<code>_Test__baz</code>还在：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/K9Cf3d24hC.png?imageslim" alt="mark"></p><p>双下划线名称修饰对程序员是完全透明的。 下面的例子证实了这一点：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/DikeKk2Bb3.png?imageslim" alt="mark"></p><p>名称修饰是否也适用于方法名称？ 是的，也适用。名称修饰会影响在一个类的上下文中，以两个下划线字符（”dunders”）开头的所有名称：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/JmIm7gKJmJ.png?imageslim" alt="mark"></p><p>这是另一个也许令人惊讶的运用名称修饰的例子：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/3ja0mfA9Gg.png?imageslim" alt="mark"></p><p>在这个例子中，我声明了一个名为<code>_MangledGlobal__mangled</code>的全局变量。然后我在名为MangledGlobal的类的上下文中访问变量。由于名称修饰，我能够在类的test()方法内，以<code>__mangled</code>来引用<code>_MangledGlobal__mangled</code>全局变量。</p><p>Python解释器自动将名称<code>__mangled</code>扩展为<code>_MangledGlobal__mangled</code>，因为它以两个下划线字符开头。这表明名称修饰不是专门与类属性关联的。它适用于在类上下文中使用的两个下划线字符开头的任何名称。</p><hr><h2 id="4-双前导和双末尾下划线-var"><a href="#4-双前导和双末尾下划线-var" class="headerlink" title="4. 双前导和双末尾下划线 __var__"></a>4. 双前导和双末尾下划线 <code>__var__</code></h2><p>也许令人惊讶的是，如果一个名字同时以双下划线开始和结束，则不会应用名称修饰。 由双下划线前缀和后缀包围的变量不会被Python解释器修改：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/ADDl7hei7B.png?imageslim" alt="mark"></p><p>但是，Python保留了有双前导和双末尾下划线的名称，用于特殊用途。 这样的例子有，<code>__init__</code>对象构造函数，或<code>__call__</code> — 它使得一个对象可以被调用。</p><p>这些dunder方法通常被称为<strong>神奇方法</strong> , 但Python开发者们都不喜欢这种方法。</p><blockquote><p><strong>最好避免在自己的程序中使用以双下划线（dunders）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。</strong></p></blockquote><hr><h2 id="5-单下划线"><a href="#5-单下划线" class="headerlink" title="5. 单下划线 _"></a>5. 单下划线 _</h2><p>按照习惯，有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。</p><p>例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用“_”来表示它只是一个临时值：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/5aCkAJ5bK9.png?imageslim" alt="mark"></p><p>你也可以在拆分(unpacking)表达式中将单个下划线用作“不关心的”变量，以忽略特定的值。 同样，这个含义只是“依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。</p><p>在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，“_”作为占位符变量可以派上用场：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/aLg5Hlf4l9.png?imageslim" alt="mark"></p><p>除了用作临时变量之外，“_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。</p><p>这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/E92eeCBbBd.png?imageslim" alt="mark"></p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/hJkhG4JK2k.png?imageslim" alt="mark"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是一个简短的小结，即“速查表”，罗列了我在本文中谈到的五种Python下划线模式的含义：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180421/Ijebl95g70.png?imageslim" alt="mark"></p><p><br><br><br></p><blockquote><p>英文原文：<a href="https://dbader.org/blog/meaning-of-underscores-in-python" target="_blank" rel="noopener">https://dbader.org/blog/meaning-of-underscores-in-python</a> </p></blockquote><p><hr><br> <center><strong>单前导下划线</strong></center></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python中单下划线和双下划线的各种含义和命名约定，名称修饰的工作原理，以及它如何影响你自己的Python类。&lt;br&gt;
    
    </summary>
    
      <category term="Python Study Notes" scheme="http://liuyang1.club/categories/Python-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="下划线" scheme="http://liuyang1.club/tags/%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>selenium遇到click失效问题解决</title>
    <link href="http://liuyang1.club/2018/04/11/selenium%E9%81%87%E5%88%B0click%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://liuyang1.club/2018/04/11/selenium遇到click失效问题解决/</id>
    <published>2018-04-11T14:04:56.000Z</published>
    <updated>2018-04-11T15:03:34.596Z</updated>
    
    <content type="html"><![CDATA[<p>在使用selenium webdriver进行爬取淘宝信息，爬取一页结束后，进行翻页操作失败，仔细检查源码，发现在底端输入页码后模拟点击并未生效，本篇记录一下解决问题的办法。<br><a id="more"></a></p><hr><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用谷歌浏览器</span></span><br><span class="line">browser = webdriver.Chrome(executable_path=chromedriver, chrome_options=options)</span><br><span class="line"><span class="comment"># 定义一个等待，方便后面调用</span></span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数功能：跳转到指定页数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump_to_page</span><span class="params">(page)</span>:</span></span><br><span class="line"><span class="comment"># 输入页码</span></span><br><span class="line">    input_page = wait.until(</span><br><span class="line">        EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">"#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input"</span>))</span><br><span class="line">    )</span><br><span class="line">    input_page.clear()</span><br><span class="line">    input_page.send_keys(page)</span><br><span class="line">    <span class="comment"># 等待提交按钮可点击</span></span><br><span class="line">    submit_page = wait.until(</span><br><span class="line">        EC.element_to_be_clickable((By.CLASS_NAME, <span class="string">"btn J_Submit"</span>))</span><br><span class="line">    )</span><br><span class="line">    submit_page.click()</span><br></pre></td></tr></table></figure><p>在这里发现<code>submit_page.click()</code>并未生效。在网页中的这个地方：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180411/kILC2d9kG4.png?imageslim" alt="mark"></p><p>页码可以正常插入，但并未发生跳转，即click方法未生效。</p><hr><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="方法一：先点父元素"><a href="#方法一：先点父元素" class="headerlink" title="方法一：先点父元素"></a>方法一：先点父元素</h2><p>即先点击想要点击的父元素，再点击子元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element_by_css_selector(<span class="string">'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form'</span>).click()</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">'"#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit'</span>).click()</span><br></pre></td></tr></table></figure></p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180411/D4KiHA8Gea.png?imageslim" alt="mark"></p><p><strong>淘宝真的强无敌，该方法并未起作用，是时候放大招了。</strong></p><h1 id="方法二：JS大法好"><a href="#方法二：JS大法好" class="headerlink" title="方法二：JS大法好"></a>方法二：JS大法好</h1><p>即直接用js直接去点击，简单粗暴，但有效。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js = <span class="string">'document.getElementsByClassName("btn J_Submit")[0].click();'</span></span><br><span class="line">browser.execute_script(js)</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用selenium webdriver进行爬取淘宝信息，爬取一页结束后，进行翻页操作失败，仔细检查源码，发现在底端输入页码后模拟点击并未生效，本篇记录一下解决问题的办法。&lt;br&gt;
    
    </summary>
    
      <category term="Spider Study Notes" scheme="http://liuyang1.club/categories/Spider-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Spider" scheme="http://liuyang1.club/tags/Spider/"/>
    
      <category term="Selenium" scheme="http://liuyang1.club/tags/Selenium/"/>
    
      <category term="web driver" scheme="http://liuyang1.club/tags/web-driver/"/>
    
  </entry>
  
  <entry>
    <title>Django编写Restful-Api：ViewSets与Routers</title>
    <link href="http://liuyang1.club/2018/04/08/Django%E7%BC%96%E5%86%99Restful-Api%EF%BC%9AViewSets%E4%B8%8ERouters/"/>
    <id>http://liuyang1.club/2018/04/08/Django编写Restful-Api：ViewSets与Routers/</id>
    <published>2018-04-08T13:05:07.000Z</published>
    <updated>2018-04-08T13:24:36.986Z</updated>
    
    <content type="html"><![CDATA[<p>在这一篇文章中，要介绍的是另一种基于类的视图的写法，它的抽象程度更高，也可以说是代码量又减少了。<br><a id="more"></a></p><hr><h1 id="使用ViewSets重构视图"><a href="#使用ViewSets重构视图" class="headerlink" title="使用ViewSets重构视图"></a>使用ViewSets重构视图</h1><p>先介绍一下这个ViewSets。ViewSets，翻译过来可以说是视图集，也就是几个视图的集合。</p><p>拿本项目为例子，我们之前查看所有用户列表就要写一个视图类UserList，并在<code>urls.py</code>中为其设置一个模式然后as_view使用它，然后要看单个用户的详情页就要再写一个UserDetail视图类并再在添加一个url模式。同时注意到这两个视图类都是继承的generics.XXXAPIView。而使用ViewSets我们就可以把UserList和UserDetail合并成UserViewSet视图类，并且继承的类改为viewsets.ReadOnlyModelViewSet，这样就是一个视图集了。</p><p>还是有点懵逼？没事，下面看看代码。编辑<code>snippets/view.py</code>，导入viewsets并使用UserViewSet来替换掉UserList和UserDetail：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> viewsets</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span><span class="params">(viewsets.ReadOnlyModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    viewset自动提供了list和detail动作</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br></pre></td></tr></table></figure><p>这里面的queryset和serializer_class的值还是和原来一样。因为关于User的API都是只读的，所以我们继承了一个ReadOnlyModelViewSet类，这样就把原先的两个视图类集合起来了。原本类里面的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queryset = User.objects.all()</span><br><span class="line">serializer_class = UserSerializer</span><br></pre></td></tr></table></figure><p>这部分属于重复代码，所以通过视图集来实现视图类我们的代码量确实减少了，更加简洁。</p><p>ViewSet类与View类其实几乎是相同的,但提供的是read或update这些操作,而不是get或put 等HTTP动作。同时，ViewSet为我们提供了默认的URL结构, 使得我们能更专注于API本身。</p><p>上面这段话呢，是官方文档里面说的，想就这样看看就算了来理解也行，不过如果我们看一下源码也许能理解的更好。因为我用的是PyCharm，所以查看源码很方便，按住CTRL键然后鼠标点击一下就会自动跳转了，首先查看一下ReadOnlyModelViewSet，发现它是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ReadOnlyModelViewSet(mixins.RetrieveModelMixin,</span><br><span class="line">                           mixins.ListModelMixin,</span><br><span class="line">                           GenericViewSet):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    A viewset that provides default `list()` and `retrieve()` actions.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>发现原来有用到之前说的mixins，所以刚才才说ViewSet类与View类其实几乎是相同的。但是这里多了一个GenericViewSet类是新的内容，继续CTRL点击查看其代码，发现它内部只是一个pass然后就没有其他的操作了，但是可以继续查看其父类ViewSetMixin的源码来了解ViewSets，然后就可以看到这个ViewSetMixin其实重写了as_view方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@classonlymethod</span><br><span class="line">    def as_view(cls, actions=None, **initkwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Because of the way class based views create a closure around the</span><br><span class="line">        instantiated view, we need to totally reimplement `.as_view`,</span><br><span class="line">        and slightly modify the view function that is created and returned.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>我们平时使用视图类的时候，编写<code>urls.py</code>时，就一个XXX.as_view()，现在使用ViewSets，需要传入参数，大概像下面这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'list'</span>&#125;)</span><br></pre></td></tr></table></figure><p>之后url就配置好了，也就是上面说的ViewSet为我们提供了默认的URL结构。当然了，这个还不是完整的url模式，稍后补全。</p><p>刚才把User的两个视图类合并成视图集了，那么Snippet的几个视图类操作上也是差不多的。用视图集SnippetViewSet代替SnippetList, SnippetDetail 和 SnippetHighlight这三个视图类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> detail_route</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetViewSet</span><span class="params">(viewsets.ModelViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    viewset自动提供了`list`, `create`, `retrieve`,</span></span><br><span class="line"><span class="string">    `update` 和 `destroy` 动作.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    同时我们手动增加一个额外的'highlight'动作用于查看高亮的代码段</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = Snippet.objects.all()</span><br><span class="line">    serializer_class = SnippetSerializer</span><br><span class="line">    permission_classes = (permissions.IsAuthenticatedOrReadOnly,</span><br><span class="line">                          IsOwnerOrReadOnly,)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @detail_route(renderer_classes=[renderers.StaticHTMLRenderer])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">highlight</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        snippet = self.get_object()</span><br><span class="line">        <span class="keyword">return</span> Response(snippet.highlighted)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">        serializer.save(owner=self.request.user)</span><br></pre></td></tr></table></figure><p>因为查看highlight不像其他动作那样，django-rest-framework并没有替我们封装好，所以我们需要自己添加这个额外的动作，要记得在方法前面加上装饰器@detail_route，这个装饰器就是用来创建自定义的动作，当然我们的自定义动作不可以是create/update/delete这些标准的，否则会有冲突。</p><p>还有一点，用@detail_route装饰器定义的动作默认是GET请求，需要其他的请求方式可以传入methods参数给这个装饰器。同样的，默认情况下，自定义操作的URL取决于方法名称本身。如果要更改url应该构造的方式，可以将url_path作为decorator的关键字参数。</p><p>最后还要注意继承的类是ModelViewSet和刚才的也有点不同，为什么换成这个，也可以看看源码能略知一二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ModelViewSet(mixins.CreateModelMixin,</span><br><span class="line">                   mixins.RetrieveModelMixin,</span><br><span class="line">                   mixins.UpdateModelMixin,</span><br><span class="line">                   mixins.DestroyModelMixin,</span><br><span class="line">                   mixins.ListModelMixin,</span><br><span class="line">                   GenericViewSet):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><h1 id="将ViewSets明确的绑定到URL"><a href="#将ViewSets明确的绑定到URL" class="headerlink" title="将ViewSets明确的绑定到URL"></a>将ViewSets明确的绑定到URL</h1><p>根据上面所说的，每个视图集的url模式都需要我们在as_view中传入参数，把<code>snippets/urls.py</code>的代码换成下面的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url,include</span><br><span class="line"><span class="keyword">from</span> snippets.views <span class="keyword">import</span> SnippetViewSet, UserViewSet, api_root</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> renderers</span><br><span class="line"><span class="keyword">from</span> rest_framework.urlpatterns <span class="keyword">import</span> format_suffix_patterns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">snippet_list = SnippetViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'list'</span>,</span><br><span class="line">    <span class="string">'post'</span>: <span class="string">'create'</span></span><br><span class="line">&#125;)</span><br><span class="line">snippet_detail = SnippetViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'retrieve'</span>,</span><br><span class="line">    <span class="string">'put'</span>: <span class="string">'update'</span>,</span><br><span class="line">    <span class="string">'patch'</span>: <span class="string">'partial_update'</span>,</span><br><span class="line">    <span class="string">'delete'</span>: <span class="string">'destroy'</span></span><br><span class="line">&#125;)</span><br><span class="line">snippet_highlight = SnippetViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'highlight'</span></span><br><span class="line">&#125;, renderer_classes=[renderers.StaticHTMLRenderer])</span><br><span class="line">user_list = UserViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'list'</span></span><br><span class="line">&#125;)</span><br><span class="line">user_detail = UserViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'retrieve'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = format_suffix_patterns([</span><br><span class="line">    url(<span class="string">r'^$'</span>, api_root),</span><br><span class="line">    url(<span class="string">r'^snippets/$'</span>, snippet_list, name=<span class="string">'snippet-list'</span>),</span><br><span class="line">    url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/$'</span>, snippet_detail, name=<span class="string">'snippet-detail'</span>),</span><br><span class="line">    url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$'</span>, snippet_highlight, name=<span class="string">'snippet-highlight'</span>),</span><br><span class="line">    url(<span class="string">r'^users/$'</span>, user_list, name=<span class="string">'user-list'</span>),</span><br><span class="line">    url(<span class="string">r'^users/(?P&lt;pk&gt;[0-9]+)/$'</span>, user_detail, name=<span class="string">'user-detail'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>OK，到了这里对视图的改造已经完成了，可以启动服务器测试一下，我们的项目功能还是和之前的一样的。</p><hr><h1 id="使用Routers"><a href="#使用Routers" class="headerlink" title="使用Routers"></a>使用Routers</h1><p>不过看到<code>urls.py</code>的代码，我们可能会发现一个问题，就是我们的视图类代码简洁了变少了，但是<code>urls.py</code>的代码量好像多了啊，要绑定那么多动作，这样算起来好像也没多大提升？</p><p>确实是这样。但是我们这可是在用python开发啊，当然是能短则短了，没错，django-rest-framework的作者也是这么想的，所以我们又有现成的轮子可以使用了。这个轮子就是本文的另一个主角——<strong>Routers</strong>。用起来也是简单粗暴，重写<code>urls.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url, include</span><br><span class="line"><span class="keyword">from</span> snippets <span class="keyword">import</span> views</span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a router and register our viewsets with it.</span></span><br><span class="line">router = DefaultRouter()</span><br><span class="line">router.register(<span class="string">r'snippets'</span>, views.SnippetViewSet)</span><br><span class="line">router.register(<span class="string">r'users'</span>, views.UserViewSet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The API URLs are now determined automatically by the router.</span></span><br><span class="line"><span class="comment"># Additionally, we include the login URLs for the browsable API.</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^'</span>, include(router.urls)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样就搞定了，代码少了很多，连原来用来设置后缀的下面这行代码都不需要了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = format_suffix_patterns(urlpatterns)</span><br></pre></td></tr></table></figure><p>而且这个DefaultRouter 类还会自动帮我们创建API根视图，也就是说<code>view.py</code>中的api_root方法也可以删除掉了。</p><p>额…这个Routers帮我们做的事情真是有点多啊。。不过这也就是我为什么在文章的前言里面说使用ViewSets会比原本的视图更抽象的原因。</p><p>拿过来用是会了，但是这里面发生了什么我们完全不知道啊，比如说API后缀去哪了？上面我们写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">snippet_list = SnippetViewSet.as_view(&#123;</span><br><span class="line">    <span class="string">'get'</span>: <span class="string">'list'</span>,</span><br><span class="line">    <span class="string">'post'</span>: <span class="string">'create'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这些绑定全都自动生成了？这些确实都是DefaultRouter 帮我们做好了，怎么做的，我们还是可以看一下源码了解一下大概的过程。首先就是register方法，我们绑定了那么多动作它两行就搞定了，查看它的源码，发现它是BaseRouter类下的一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRouter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.registry = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, prefix, viewset, base_name=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> base_name <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            base_name = self.get_default_base_name(viewset)</span><br><span class="line">        self.registry.append((prefix, viewset, base_name))</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">urls</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'_urls'</span>):</span><br><span class="line">            self._urls = self.get_urls()</span><br><span class="line">        <span class="keyword">return</span> self._urls</span><br></pre></td></tr></table></figure><p>改方法根据传进来的参数生成url端点，也就是/snippets和/users，然后存到registry列表中。并且这个类的最后是一个可以当属性用的方法urls，而这个方法里面又调用了get_urls()来生成所有的url模式，当然这个get_urls()被子类SimpleRouter和子子类DefaultRouter重写了。SimpleRouter中的get_urls()实现了生成是5个url模式，也就是原本的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^snippets/$'</span>,snippet_list,name=<span class="string">'snippet-list'</span>),</span><br><span class="line">url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/$'</span>, snippet_detail, name=<span class="string">'snippet-detail'</span>),</span><br><span class="line">url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$'</span>, snippet_highlight, name=<span class="string">'snippet-highlight'</span>),</span><br><span class="line">url(<span class="string">r'^users/$'</span>, user_list, name=<span class="string">'user-list'</span>),</span><br><span class="line">url(<span class="string">r'^users/(?P&lt;pk&gt;[0-9]+)/$'</span>, user_detail, name=<span class="string">'user-detail'</span>)</span><br></pre></td></tr></table></figure><p>而DefaultRouter中的get_urls()中则生成了api_root的url模式，同时还为这些url模式加了格式后缀，所以我们自己不会用到format_suffix_patterns这个东西。</p><blockquote><p>当然了，并不一定要使用ViewSets的视图代替View，两者各有好处ViewSets节省了很多代码并且url模式也不用我们自己设置了，但是也会带来一些不确定性，自动化的效果有时候可能和你预想的不太一样，所以想要选择哪种方法看你自己喜欢。</p></blockquote><hr><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇文章来自<code>ziv</code>的博客，仅作整理学习分享。<br>点击这里<a href="http://www.comingnext.cn/post/11/" target="_blank" rel="noopener">访问原文</a>。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这一篇文章中，要介绍的是另一种基于类的视图的写法，它的抽象程度更高，也可以说是代码量又减少了。&lt;br&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="http://liuyang1.club/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Django" scheme="http://liuyang1.club/tags/Django/"/>
    
      <category term="Web" scheme="http://liuyang1.club/tags/Web/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Restful-Api" scheme="http://liuyang1.club/tags/Restful-Api/"/>
    
  </entry>
  
  <entry>
    <title>Django编写Restful-Api：超链接</title>
    <link href="http://liuyang1.club/2018/04/08/Django%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E8%B6%85%E9%93%BE%E6%8E%A5/"/>
    <id>http://liuyang1.club/2018/04/08/Django编写Restful-Api：超链接/</id>
    <published>2018-04-07T16:05:07.000Z</published>
    <updated>2018-04-07T16:10:13.734Z</updated>
    
    <content type="html"><![CDATA[<p>在不同的资源信息之间使用超链接进行跳转，及之前提到的显示时代码段高亮的实现。<br><a id="more"></a></p><hr><p>在上篇中，加入了用户模型，以及相关的认证和权限的功能。但是我们在使用的时候，会发现在访问<code>http://127.0.0.1:8000/users/</code>时看到的用户列表，不能够直接点击某个链接然后查看其详情，也就是不能跳转到<code>http://127.0.0.1:8000/users/2</code>这样的链接，查看Snippet列表的时候也是如此。而且User和Snippet也没相关的链接进行相互之间的跳转。这些就很影响用户体验了，每次都需要重新输入URL才可以访问别的内容。这就是这篇文章主要解决的问题。</p><p>另外，上一篇文章说的能使代码段高亮的HTML代码，也会在本文中看到其使用。</p><hr><h1 id="为API创建根URL"><a href="#为API创建根URL" class="headerlink" title="为API创建根URL"></a>为API创建根URL</h1><p>根URL也就是访问根路径，就是<code>http://127.0.0.1:8000/</code>，要让这个页面能显示并访问所有的模型，也就是本项目的snippets和users。所以在<code>views.py</code>中肯定要多增加一个内容作为根URL（也就是首页）的视图，在这里我们采用基于函数的视图，编辑<code>snippets/views.py</code>并添加下面的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.reverse <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view(['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_root</span><span class="params">(request, format=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(&#123;</span><br><span class="line">        <span class="string">'users'</span>: reverse(<span class="string">'user-list'</span>, request=request, format=format),</span><br><span class="line">        <span class="string">'snippets'</span>: reverse(<span class="string">'snippet-list'</span>, request=request, format=format)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>关于装饰器在之前的文章已经讲解过了，这里的新知识是<code>reverse</code>，<strong>这是rest_framework的reverse而不是Django自带的那个</strong>，但是使用习惯类似，它会根据参数返回一个超链接，看到’user-list’和’snippet-list’基本就和Django自带的reverse一样的道理，就是根据路由匹配模式的命名来生成超链接，所以等下需要编辑<code>snippets/urls.py</code>设置一下name参数。</p><p>然后Response的参数是一个字典，这个其实也和Django开发一样，这个字典的键和值会传到前端模板然后经过模板引擎渲染，只不过这里的前端模板<code>django-rest-framework</code>已经帮我们做好了，只需把值传递过去就OK啦。</p><hr><h1 id="创建跳转至查看高亮代码段的URL"><a href="#创建跳转至查看高亮代码段的URL" class="headerlink" title="创建跳转至查看高亮代码段的URL"></a>创建跳转至查看高亮代码段的URL</h1><p>现在我们的API还不能查看高亮代码段，所以需要添加一个链接进行跳转。</p><p>回到上一篇文章里面的<code>snippets/models.py</code>，我们为Snippet模型添加了highlighted字段，并且使用save方法，使得保存数据时生成能使代码段高亮的HTML代码，也就是下面这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用pygments库来生成能使代码高亮的HTML代码</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    lexer = get_lexer_by_name(self.language)</span><br><span class="line">    linenos = self.linenos <span class="keyword">and</span> <span class="string">'table'</span> <span class="keyword">or</span> <span class="keyword">False</span></span><br><span class="line">    options = self.title <span class="keyword">and</span> &#123;<span class="string">'title'</span>: self.title&#125; <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    formatter = HtmlFormatter(style=self.style, linenos=linenos,</span><br><span class="line">                              full=<span class="keyword">True</span>, **options)</span><br><span class="line">    self.highlighted = highlight(self.code, lexer, formatter)</span><br><span class="line">    super(Snippet, self).save(*args, **kwargs)</span><br></pre></td></tr></table></figure><p>所以每次保存数据时都会自动更新生成新的HTML代码。</p><p>现在我们要做的就是使用API的时候，每个snippet下面除了id、title、owner等这些本来就有的，还要加一个超链接，点击链接就能查看高亮代码段的页面，所以需要为这个新页面再创建一个视图，编辑<strong><code>snippet/views.py</code></strong>，添加代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> renderers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetHighlight</span><span class="params">(generics.GenericAPIView)</span>:</span></span><br><span class="line">    queryset = Snippet.objects.all()</span><br><span class="line">    renderer_classes = (renderers.StaticHTMLRenderer,)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        snippet = self.get_object()</span><br><span class="line">        <span class="keyword">return</span> Response(snippet.highlighted)</span><br></pre></td></tr></table></figure><p>这个代码高亮是为了在浏览器上使用API时查看的，所以返回json格式的数据就没有什么意思了，所以这里限定为只用HTML方式呈现。</p><p><strong>REST framework为我们提供了两种方式来呈现HTML，一种是使用已有的模板（我们平时开发Django更常用的那种方式），另一种就是使用已经构建好的HTML代码。</strong>在这里我们会使用第二种方法，因为刚才已经说了每次保存数据时都会自动更新生成新的HTML代码，而这个由pygments生成的代码就保存在Snippet下的highlighted，所以有浏览器渲染并呈现highlighted下的HTML代码就行了。因此有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer_classes = (renderers.StaticHTMLRenderer,)</span><br></pre></td></tr></table></figure><p>另外我们还注意到这里使用了get方法，其他的视图类不用这个方法因为他们返回的是整个实例对象，而我们的高亮代码段页面只需要这个实例对象的一个属性，也就是snippet.highlighted。REST framework提供的通用视图类并没有提供直接返回一个实例的某个属性的方法，所以这里需要我们自己写一个get方法来指定返回的属性。</p><p>完成了根视图以及高亮代码段视图的设计，要调用到它们的话，接下来自然要为其设计URL了。编辑<code>snippets/urls.py</code>，添加下面两个url模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^$'</span>, views.api_root),</span><br><span class="line">url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$'</span>, views.SnippetHighlight.as_view()),</span><br></pre></td></tr></table></figure><hr><h1 id="用超链接关联API"><a href="#用超链接关联API" class="headerlink" title="用超链接关联API"></a>用超链接关联API</h1><p>到目前，User和Snippet在浏览时还不能相互之间进行跳转，比如我们访问一个用户的详情页时，单个User下的snippets会显示此用户创建的所有snippet，但是只显示了id值，可读性不好并且不能跳转，光看到个数字其实意义不大。我们希望实现的是把这些id值换成相应的snippet的超链接，同时希望在查看用户列表的时候每个用户下面有个超链接能直接进入该用户详情页；同样的，在每个snippet下有个URL指向其创建者的详情页面。</p><p>说了那么多，我们想要的就是用超链接来关联API，用来代替之前简单粗暴的使用外键以及id值来表示。</p><p>由此，在序列化器中引出一个新的HyperlinkedModelSerializer类来代替之前的ModelSerializer类。</p><p>这个新的类有以下的<strong>不同点</strong>： </p><ol><li><strong>默认不包含id值</strong> </li><li><strong>通过HyperlinkedIdentityField这个字段会为序列化器生成一个url属性</strong> </li><li><strong>关联API使用的是HyperlinkedRelatedField而不是PrimaryKeyRelatedField（超链接代替外键）</strong></li></ol><p>这么一看，这个新的HyperlinkedModelSerializer类好像可以实现上面我们所说的那些功能，确实是这样的。编辑<code>snippet/serializers.py</code>，改进序列化器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetSerializer</span><span class="params">(serializers.HyperlinkedModelSerializer)</span>:</span></span><br><span class="line">    owner = serializers.ReadOnlyField(source=<span class="string">'owner.username'</span>)</span><br><span class="line">    highlight = serializers.HyperlinkedIdentityField(view_name=<span class="string">'snippet-highlighted'</span>, format=<span class="string">'html'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Snippet</span><br><span class="line">        fields = (<span class="string">'url'</span>, <span class="string">'id'</span>, <span class="string">'highlight'</span>, <span class="string">'owner'</span>,</span><br><span class="line">                  <span class="string">'title'</span>, <span class="string">'code'</span>, <span class="string">'linenos'</span>, <span class="string">'language'</span>, <span class="string">'style'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.HyperlinkedModelSerializer)</span>:</span></span><br><span class="line">    snippets = serializers.HyperlinkedRelatedField(many=<span class="keyword">True</span>, view_name=<span class="string">'snippet-detail'</span>, read_only=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">'url'</span>, <span class="string">'id'</span>, <span class="string">'username'</span>, <span class="string">'snippets'</span>)</span><br></pre></td></tr></table></figure><p>可以看到两个Meta类都多了一个’url’，这就是HyperlinkedRelatedField生成的，并且看到参数中又有一个命名空间，乍一看好像有点像reverse生成URL的套路啊？</p><p>额…内部的实现真的是有用到reverse，通过查看源码就能追踪到那里，首先进入HyperlinkedRelatedField源码，发现里面只有一个<code>__init__</code>构造方法，那就继续进入它的父类HyperlinkedRelatedField的源码，发现里面有这么一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(self, obj, view_name, request, format)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Given an object, return the URL that hyperlinks to the object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    May raise a `NoReverseMatch` if the `view_name` and `lookup_field`</span></span><br><span class="line"><span class="string">    attributes are not configured to correctly match the URL conf.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Unsaved objects will not yet have a valid URL.</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(obj, <span class="string">'pk'</span>) <span class="keyword">and</span> obj.pk <span class="keyword">in</span> (<span class="keyword">None</span>, <span class="string">''</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    lookup_value = getattr(obj, self.lookup_field)</span><br><span class="line">    kwargs = &#123;self.lookup_url_kwarg: lookup_value&#125;</span><br><span class="line">    <span class="keyword">return</span> self.reverse(view_name, kwargs=kwargs, request=request, format=format)</span><br></pre></td></tr></table></figure><p>发现其实这个方法最后用的还是reverse方法，并且将生成的url作为返回的数据。所以继续往下看这个类的代码，会发现还有个to_representation方法里面有这么几行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    url = self.get_url(value, self.view_name, request, format)</span><br><span class="line"><span class="keyword">except</span> NoReverseMatch:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Hyperlink(url, value)</span><br></pre></td></tr></table></figure><p>这个过程下来我们大概能知道HyperlinkedIdentityField也能帮我们生成相应url，并且是一个超链接的形式。</p><p>另外注意到我们想要让代码高亮API只用HTML呈现，所以还设置了format=’html’参数限定了后缀。</p><hr><h1 id="为各个URL模式命名"><a href="#为各个URL模式命名" class="headerlink" title="为各个URL模式命名"></a>为各个URL模式命名</h1><p>上面的程序为了生成url又是reverse又是HyperlinkedIdentityField的，其中的参数都用到了命名，所以我们想要生成正确的url就要给各个URL模式根据上面的参数正确命名。</p><p>编辑 <code>snippets/urls.py</code>，添加命名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> snippets <span class="keyword">import</span> views</span><br><span class="line"><span class="keyword">from</span> rest_framework.urlpatterns <span class="keyword">import</span> format_suffix_patterns</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^snippets/$'</span>, views.SnippetList.as_view(),name=<span class="string">'snippet-list'</span>),</span><br><span class="line">    url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/$'</span>, views.SnippetDetail.as_view(),name=<span class="string">'snippet-detail'</span>),</span><br><span class="line">    url(<span class="string">r'^users/$'</span>,views.UserList.as_view(),name=<span class="string">'user-list'</span>),</span><br><span class="line">    url(<span class="string">r'^users/(?P&lt;pk&gt;[0-9]+)/$'</span>,views.UserDetail.as_view(),name=<span class="string">'user-detail'</span>),</span><br><span class="line">    url(<span class="string">r'^$'</span>,views.api_root),</span><br><span class="line">    url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlighted/$'</span>,views.SnippetHighlight.as_view(),name=<span class="string">'snippet-highlighted'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">urlpatterns = format_suffix_patterns(urlpatterns)</span><br></pre></td></tr></table></figure><hr><h1 id="添加分页"><a href="#添加分页" class="headerlink" title="添加分页"></a>添加分页</h1><p>如果我们创建的用户和代码段都很多的话，再查看列表是全部显示在一页有时候可能有点难看，所以这里需要添加一个分页设置，很简单，只需要在项目的<code>settings.py</code>中添加一个配置字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以实现分页了</p><p>OK，现在我们的项目通过使用各种超链接来关联，API之间已经可以方便的进行花式跳转了。</p><hr><h1 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h1><p>首先是API根页面：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180407/jm3bbfklah.png?imageslim" alt="mark"></p><p>里面的链接都是可以点击的，下面是单个Snippet详情页：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180407/GEghJ5Cjl4.png?imageslim" alt="mark"></p><p>最后是代码高亮页面，其实就是highlighted中的HTML代码被浏览器渲染后的样子：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180407/71E4jedBJf.png?imageslim" alt="mark"></p><p>想要这个页面的源码的话除了在浏览器右键打开，还可以直接SnippetSerializer下面的Meta类中，直接为field再加一个’highlighted’，然后浏览的时候就会发现Snippet详情页多了个highlighted键，它的值就是很长很长的一坨HTML代码，这代码生成的页面其实就是上面那个图的样子。</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180407/gb4KE7eC5l.png?imageslim" alt="mark"></p><p>OK，关于添加超链接提高模型间的关联性的介绍就先到这了。下一篇文章会介绍视图集和路由相关的内容。</p><hr><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本篇文章来自<code>ziv</code>的博客，仅作整理学习分享。<br>点击这里<a href="http://www.comingnext.cn/post/10/" target="_blank" rel="noopener">访问原文</a>。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在不同的资源信息之间使用超链接进行跳转，及之前提到的显示时代码段高亮的实现。&lt;br&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="http://liuyang1.club/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Django" scheme="http://liuyang1.club/tags/Django/"/>
    
      <category term="Web" scheme="http://liuyang1.club/tags/Web/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Restful-Api" scheme="http://liuyang1.club/tags/Restful-Api/"/>
    
  </entry>
  
  <entry>
    <title>Django编写Restful-Api：权限控制</title>
    <link href="http://liuyang1.club/2018/04/07/Django%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://liuyang1.club/2018/04/07/Django编写Restful-Api：权限控制/</id>
    <published>2018-04-07T04:05:07.000Z</published>
    <updated>2018-04-07T06:20:33.488Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们的API还有一个很明显的缺陷，那就是没有认证和权限功能，任何资源都会任何用户被随意更改，所以我们要添加这一功能。<br><a id="more"></a></p><hr><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>我们要改进程序，实现以下功能：</p><ol><li><strong>snippet与其创建者相互关联</strong></li><li><strong>只有经过身份验证（登录）的用户才可以创建snipp</strong>ets</li><li><strong>只有创建该snippet的用户才可以对其进行更改或者删除</strong></li><li><strong>未经验证的用户只具有访问（只读）的功能</strong></li></ol><h3 id="修改snippet模型"><a href="#修改snippet模型" class="headerlink" title="修改snippet模型"></a>修改snippet模型</h3><p>首先，我们想让<code>snippets</code>都和它们的创建用户关联起来，所以我们自然的要在<code>Snippet</code>模型添加一个<code>owner</code>字段来表示。另外，我们还添加一个<code>highlighted</code>字段用来实现代码高亮，修改<code>snippets/models.py</code>的<code>Snippet</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">owner = models.ForeignKey(<span class="string">'auth.User'</span>, related_name=<span class="string">'snippets'</span>, on_delete=models.CASCADE)</span><br><span class="line">highlighted = models.TextField()</span><br></pre></td></tr></table></figure></p><p>想要实现代码高亮，当然不是上面一行代码就搞定了，它现在还只是一个普通的字段而已。我们要做的是在保存的时候，也就是当执行save()时, 我们使用pygments生成高亮后的HTML，还是在model.py,首先导入相关的库:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pygments.lexers <span class="keyword">import</span> get_lexer_by_name</span><br><span class="line"><span class="keyword">from</span> pygments.formatters.html <span class="keyword">import</span> HtmlFormatter</span><br><span class="line"><span class="keyword">from</span> pygments <span class="keyword">import</span> highlight</span><br></pre></td></tr></table></figure><p>然后在Snippet类中添加save()方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用pygments库来生成能使代码高亮的HTML代码</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    lexer = get_lexer_by_name(self.language)</span><br><span class="line">    linenos = self.linenos <span class="keyword">and</span> <span class="string">'table'</span> <span class="keyword">or</span> <span class="keyword">False</span></span><br><span class="line">    options = self.title <span class="keyword">and</span> &#123;<span class="string">'title'</span>: self.title&#125; <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    formatter = HtmlFormatter(style=self.style, linenos=linenos,</span><br><span class="line">                              full=<span class="keyword">True</span>, **options)</span><br><span class="line">    self.highlighted = highlight(self.code, lexer, formatter)</span><br><span class="line">    super(Snippet, self).save(*args, **kwargs)</span><br></pre></td></tr></table></figure><p>在保存数据的时候就会执行上面这个方法，整个方法的功能如注释所示，在这一篇文章中还不会具体的展示这个功能，在接下来的文章中会展示。</p><p>修改了模型当然需要同步一下数据库了，在这里我们和官方文档一样把数据库删了在重新生成，<strong>首先把工程目录下的db.sqlite3以及snippets下的migrations文件夹删除，然后再执行迁移步骤</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations snippets</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>同时，由于我们想要实现的是访问各个snippet时显示相应的创建者，所以这里需要创建几个不同的账户稍后才可以显示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><hr><h3 id="为用户模型添加端点"><a href="#为用户模型添加端点" class="headerlink" title="为用户模型添加端点"></a>为用户模型添加端点</h3><p>原理和之前的SnippetSerializer基本一样，在snippets/serializers.py中添加一个User序列化器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    snippets = serializers.PrimaryKeyRelatedField(many=<span class="keyword">True</span>, queryset=Snippet.objects.all())</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">'id'</span>, <span class="string">'username'</span>, <span class="string">'snippets'</span>)</span><br></pre></td></tr></table></figure><p>注意到里面的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all())</span><br></pre></td></tr></table></figure><p>因为snippets在User模型中是一个反向关系，在使用ModelSerializer类时默认情况是不会包括这个关系，就是说通过Snippet的owner能查询到User，而User这边查询不到一个用户创建的snippet，所以我们需要手动为用户序列添加这个字段。</p><p>弄好了User的序列化器，接着就要让其能够显示出来，所以要添加相关的视图类，编辑view.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> snippets.serializers <span class="keyword">import</span> UserSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDetail</span><span class="params">(generics.RetrieveAPIView)</span>:</span></span><br><span class="line">    queryset = User.objects.all()</span><br><span class="line">    serializer_class = UserSerializer</span><br></pre></td></tr></table></figure><p>写好了视图函数，想要通过URL访问到它们，肯定是配置一下路由分发啦，编辑<code>snippets/urls.py</code>添加下面的匹配模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^users/$'</span>, views.UserList.as_view()),</span><br><span class="line">url(<span class="string">r'^users/(?P&lt;pk&gt;[0-9]+)/$'</span>, views.UserDetail.as_view()</span><br></pre></td></tr></table></figure><hr><h3 id="关联Snippets和Users"><a href="#关联Snippets和Users" class="headerlink" title="关联Snippets和Users"></a>关联Snippets和Users</h3><p>到了这里，如果像之前那样创建代码段的话，我们还不能把Snippets和Users关联起来。因为在使用的时候User的数据是通过request传入的，而不是以序列化的数据传递过来。</p><p>而我们刚才添加了一个owner作为外键，这个时候就要看到它的用处了，编辑view.py,为SnippetList视图类添加一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetList</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = Snippet.objects.all()</span><br><span class="line">    serializer_class = SnippetSerializer</span><br><span class="line">    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">        serializer.save(owner=self.request.user)</span><br></pre></td></tr></table></figure><p>这个perform_create() 可以让用户在通过POST请求创建一个新的Snippet时，在保存新的Snippet数据的时候会把request中的user赋值给Snippet的owner。等下具体使用的时候就可以轻松的理解了。</p><hr><h3 id="更新serializer"><a href="#更新serializer" class="headerlink" title="更新serializer"></a>更新serializer</h3><p>上一步已经把两者关联起来了，owner会在创建新的Snippet的时候拥有User的各个属性，那么在API中要让owner显示id还是用户名，为了提高可读性，答案当然是显示用户名了，所以我们在SnippetSerializer 下面增加一个字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">owner = serializers.ReadOnlyField(source=<span class="string">'owner.username'</span>)</span><br></pre></td></tr></table></figure><p>这里的source参数就指定了哪个属性用于填充字段，为了在使用的时候显示owner，但是还要把它添加进Meta类里面，所以整个SnippetSerializer如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="comment"># 这里可以使用也 CharField(read_only=True) 来替换</span></span><br><span class="line">    owner = serializers.ReadOnlyField(source=<span class="string">'owner.username'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Snippet</span><br><span class="line">        fields = (<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'code'</span>, <span class="string">'linenos'</span>, <span class="string">'language'</span>, <span class="string">'style'</span>,<span class="string">'owner'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h3><p>现在Snippet和User已经关联起来并且是可浏览的。接下来我们要实现的及时权限的问题了。也就是我们一开始说的几点中的：</p><ol><li><p>只有经过身份验证（登录）的用户才可以创建snippet</p></li><li><p>只有创建该snippet的用户才可以对其进行更改或者删除</p></li><li><p>未经验证的用户只具有访问（只读）的功能</p></li></ol><p>首先在views.py导入一个库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> permissions</span><br></pre></td></tr></table></figure><p>接着为SnippetList 和 SnippetDetail添加权限判断，在这两个视图类中都加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permission_classes = (permissions.IsAuthenticatedOrReadOnly, )</span><br></pre></td></tr></table></figure><p><strong>这里要特别注意，有一个坑，就是那个逗号一定要加上去，不然就会报错。</strong><br>这行代码的作用就是判断当前用户是否为该Snippet的创建者，而其他用户只有只读属性，就是只能查看。</p><hr><h3 id="为可浏览的API添加登录功能"><a href="#为可浏览的API添加登录功能" class="headerlink" title="为可浏览的API添加登录功能"></a>为可浏览的API添加登录功能</h3><p>刚才添加了权限判断，如果没有登录用户，那就相当于游客啦，什么功能都没有只能看，所以在浏览器浏览API的时候就需要登录 功能。在这里，强大的django-rest-framework又为我们做了很多事情，想要在添加登录按钮和页面，只需要修改一个rest_tutorial/urls.py，添加一个URL匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns += [</span><br><span class="line">    url(<span class="string">r'^api-auth/'</span>, include(<span class="string">'rest_framework.urls'</span>,</span><br><span class="line">                               namespace=<span class="string">'rest_framework'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>这里的<code>r&#39;^api-auth/&#39;</code>你可以设置成任意你喜欢的，但是命名空间一定要相同，就是<code>namespace=&#39;rest_framework</code>。</strong></p><p>好了，现在打开浏览器，就可以看到在我们的API页面的<strong>右上角有一个登录的按钮</strong>，点击之后就可以使用之前创建的用户登录了。</p><p>这个时候访问单个用户的详情，就可以看到该用户创建的所有Snippet的id值（需要先创建好几个Snippet，可以按照本系列第一篇文章中在shell模式中的方法来创建）。比如访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/users/</span><br></pre></td></tr></table></figure><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180407/gLFjFd1D4f.png?imageslim" alt="mark"></p><hr><h3 id="添加对象权限"><a href="#添加对象权限" class="headerlink" title="添加对象权限"></a>添加对象权限</h3><p>接着我们要实现的是让所有的Snippet可以被所有人访问到，但是每个Snippet只有其创建者才可以对其进行更改、删除等操作。</p><p>因此，我们需要设置一下自定义权限，使每个Snippet只允许其创建者编辑它。在snippets目录下新建一个permissions.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> permissions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsOwnerOrReadOnly</span><span class="params">(permissions.BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使每个Snippet只允许其创建者编辑它</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_object_permission</span><span class="params">(self, request, view, obj)</span>:</span></span><br><span class="line">        <span class="comment"># 任何用户或者游客都可以访问任何Snippet，所以当请求动作在安全范围内，</span></span><br><span class="line">        <span class="comment"># 也就是GET，HEAD，OPTIONS请求时，都会被允许</span></span><br><span class="line">        <span class="keyword">if</span> request.method <span class="keyword">in</span> permissions.SAFE_METHODS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 而当请求不是上面的安全模式的话，那就需要判断一下当前的用户</span></span><br><span class="line">        <span class="comment"># 如果Snippet所有者和当前的用户一致，那就允许，否则返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> obj.owner == request.user</span><br></pre></td></tr></table></figure><p>代码的逻辑已在注释中，简单说就是提供判断功能，然后我们要把它运用起来，在view.py中的SnippetDetail 修改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetDetail</span><span class="params">(generics.RetrieveUpdateDestroyAPIView)</span>:</span></span><br><span class="line">    queryset = Snippet.objects.all()</span><br><span class="line">    serializer_class = SnippetSerializer</span><br><span class="line">    permission_classes = (permissions.IsAuthenticatedOrReadOnly,</span><br><span class="line">                          IsOwnerOrReadOnly,)</span><br></pre></td></tr></table></figure><p>注意要导入IsOwnerOrReadOnly类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snippets.permissions <span class="keyword">import</span> IsOwnerOrReadOnly</span><br></pre></td></tr></table></figure><p>现在用浏览器打开单个Snippet详情页，如果你当前登录的用户是这个Snippet的创建者，那你会发现多了DELETE和PUT两个操作，比如访问<code>http://127.0.0.1:8000/snippets/2/</code>，效果如下：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180407/C4Amf93F9E.png?imageslim" alt="mark"></p><hr><h3 id="使用API授权"><a href="#使用API授权" class="headerlink" title="使用API授权"></a>使用API授权</h3><p>由于现在我们还没使用authentication 类，所以项目目前还是使用默认的SessionAuthentication 和 BasicAuthentication.</p><p>在使用浏览器访问API的时候，浏览器会帮我们保存会话信息，所以当权限满足时就可以对一个Snippet进行删除或者更改，或者是创建一个新的Snippet。</p><p>当如果是通过命令行来操作API，我们就必须在每次发送请求的时候添加授权信息，也就是用户名和密码，没有的话就会报错，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http POST http://127.0.0.1:8000/snippets/ code=&quot;print 123&quot;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;detail&quot;: &quot;Authentication credentials were not provided.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http -a username:password POST http://127.0.0.1:8000/snippets/ code=&quot;print 789&quot;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;owner&quot;: &quot;username1&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;&quot;,</span><br><span class="line">    &quot;code&quot;: &quot;print 789&quot;,</span><br><span class="line">    &quot;linenos&quot;: false,</span><br><span class="line">    &quot;language&quot;: &quot;python&quot;,</span><br><span class="line">    &quot;style&quot;: &quot;friendly&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出owner就是提交过来的用户名，这就是上面代码的功能体现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">    serializer.save(owner=self.request.user)</span><br></pre></td></tr></table></figure><p>通过实际使用更能理解程序，owner会在一个用户创建Snippet时得到该用户的信息就是这么来的。</p><hr><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本篇文章来自<code>ziv</code>的博客，仅作整理学习分享。<br>点击这里<a href="http://www.comingnext.cn/post/9/" target="_blank" rel="noopener">访问原文</a>。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我们的API还有一个很明显的缺陷，那就是没有认证和权限功能，任何资源都会任何用户被随意更改，所以我们要添加这一功能。&lt;br&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="http://liuyang1.club/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Django" scheme="http://liuyang1.club/tags/Django/"/>
    
      <category term="Web" scheme="http://liuyang1.club/tags/Web/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Restful-Api" scheme="http://liuyang1.club/tags/Restful-Api/"/>
    
  </entry>
  
  <entry>
    <title>Django编写Restful-Api：类视图</title>
    <link href="http://liuyang1.club/2018/04/06/Django%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E7%B1%BB%E8%A7%86%E5%9B%BE/"/>
    <id>http://liuyang1.club/2018/04/06/Django编写Restful-Api：类视图/</id>
    <published>2018-04-06T13:05:28.000Z</published>
    <updated>2018-04-06T13:23:41.351Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，主要讲的是请求和响应，项目里面<code>views.py</code>中的视图函数都是基于函数的，并且我们介绍了<code>@api_view</code>这个很有用的装饰器。同时，我们还介绍了<code>APIView</code>这个类，但是还没使用它。在这篇文章中，我们要做的是把基于方法的视图改为基于类的视图，将会了解到<code>APIView</code>。<br><a id="more"></a></p><hr><h3 id="改为基于类的视图"><a href="#改为基于类的视图" class="headerlink" title="改为基于类的视图"></a>改为基于类的视图</h3><p>重构一下<code>snippets/view.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snippets.models <span class="keyword">import</span> Snippet</span><br><span class="line"><span class="keyword">from</span> snippets.serializers <span class="keyword">import</span> SnippetSerializer</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetList</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    列出所有已经存在的snippet或者创建一个新的snippet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        snippets = Snippet.objects.all()</span><br><span class="line">        serializer = SnippetSerializer(snippets, many=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, format=None)</span>:</span></span><br><span class="line">        serializer = SnippetSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            serializer.save()</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure><p>到这里应该很容易理解，和原来的相比，可以发现基于类的视图把各种不同的<code>HTTP</code>请求分离开变成单个的方法，而不是<code>if...elif...</code>这样的结构，所以这样处理起来很更加的高效。</p><p>同样的，把另一个视图函数也进行修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetDetail</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    检索查看、更新或者删除一个snippet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self, pk)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> Snippet.objects.get(pk=pk)</span><br><span class="line">        <span class="keyword">except</span> Snippet.DoesNotExist:</span><br><span class="line">            <span class="keyword">raise</span> Http404</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, pk, format=None)</span>:</span></span><br><span class="line">        snippet = self.get_object(pk)</span><br><span class="line">        serializer = SnippetSerializer(snippet)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request, pk, format=None)</span>:</span></span><br><span class="line">        snippet = self.get_object(pk)</span><br><span class="line">        serializer = SnippetSerializer(snippet, data=request.data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            serializer.save()</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, pk, format=None)</span>:</span></span><br><span class="line">        snippet = self.get_object(pk)</span><br><span class="line">        snippet.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure><h3 id="修改路由"><a href="#修改路由" class="headerlink" title="修改路由"></a>修改路由</h3><p>改为基于类的视图之后，当然也要修改一下路由了，对<code>snippets/urls.py</code>稍加修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> rest_framework.urlpatterns <span class="keyword">import</span> format_suffix_patterns</span><br><span class="line"><span class="keyword">from</span> snippets <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^snippets/$'</span>, views.SnippetList.as_view()),</span><br><span class="line">    url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/$'</span>, views.SnippetDetail.as_view()),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">urlpatterns = format_suffix_patterns(urlpatterns)</span><br></pre></td></tr></table></figure><hr><h3 id="使用mixins类"><a href="#使用mixins类" class="headerlink" title="使用mixins类"></a>使用mixins类</h3><p>使用基于类的视图的好处除了上面所说的把各种HTTP请求分离开，还有什么好处吗？答案是肯定的——使用基于类的视图的最大优势之一是它可以轻松地构成可重复使用的行为。</p><p>可重复使用的行为？简单说，就是让我们少写一点功能类似的代码，由此就要介绍一下<code>mixins</code>类了，它帮我们封装了很多操作，简化代码，使用也很简单，编辑<code>snippets/view.py</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snippets.models <span class="keyword">import</span> Snippet</span><br><span class="line"><span class="keyword">from</span> snippets.serializers <span class="keyword">import</span> SnippetSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> mixins</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> generics</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetList</span><span class="params">(mixins.ListModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  mixins.CreateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  generics.GenericAPIView)</span>:</span></span><br><span class="line">    queryset = Snippet.objects.all()</span><br><span class="line">    serializer_class = SnippetSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.create(request, *args, **kwargs)</span><br></pre></td></tr></table></figure><p>新的视图类中继承了 <code>generic.GenericAPIView</code>、<code>mixins.ListModelMixin</code>和<code>mixins.CreatteModelMixin</code>，类的作用看字面意思就能懂啦，<code>mixins</code>类为我们提供了<code>list()</code>和<code>create()</code>方法，当然，<strong>使用这两个函数需要先设置<code>queryset</code>和<code>serializer_class</code></strong>，这点我们查看一下<code>mixins</code>的源码就可以看出来了，比如list方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListModelMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    List a queryset.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        queryset = self.filter_queryset(self.get_queryset())</span><br><span class="line"></span><br><span class="line">        page = self.paginate_queryset(queryset)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="keyword">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(queryset, many=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure><p>这里的代码会分别通过<code>get_queryset()</code>和<code>get_serializer()</code>得到查询集和序列化器，其他封装好的方法也是如此。</p><p>知道了这个，再修改一下另一个视图类就很容易了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetDetail</span><span class="params">(mixins.RetrieveModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                    mixins.UpdateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                    mixins.DestroyModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                    generics.GenericAPIView)</span>:</span></span><br><span class="line">    queryset = Snippet.objects.all()</span><br><span class="line">    serializer_class = SnippetSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.update(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.destroy(request, *args, **kwargs)</span><br></pre></td></tr></table></figure><hr><h3 id="使用generics视图类"><a href="#使用generics视图类" class="headerlink" title="使用generics视图类"></a>使用generics视图类</h3><p>到这里，视图代码已经简化了许多了，但是我要告诉你的是，还可以进一步简化。进一步简化就是连mixins类都不用了，只使用generics就可以了，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> snippets.models <span class="keyword">import</span> Snippet</span><br><span class="line"><span class="keyword">from</span> snippets.serializers <span class="keyword">import</span> SnippetSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> generics</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetList</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = Snippet.objects.all()</span><br><span class="line">    serializer_class = SnippetSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetDetail</span><span class="params">(generics.RetrieveUpdateDestroyAPIView)</span>:</span></span><br><span class="line">    queryset = Snippet.objects.all()</span><br><span class="line">    serializer_class = SnippetSerializer</span><br></pre></td></tr></table></figure><p>好了，现在的代码就显得非常简洁了，但是短小却精悍，依然可以实现原本的功能。</p><hr><h3 id="测试Api"><a href="#测试Api" class="headerlink" title="测试Api"></a>测试Api</h3><p>测试方法和上篇雷同，可跳过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http http://127.0.0.1:8000/snippets/</span><br></pre></td></tr></table></figure></p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/7bfiKd7Kmb.png?imageslim" alt="mark"></p><ol><li>通过<strong>设置Accept头部信息来控制返回的格式</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http http://127.0.0.1:8000/snippets/ Accept:application/json  # JSON</span><br><span class="line">http http://127.0.0.1:8000/snippets/ Accept:text/html         # HTML</span><br></pre></td></tr></table></figure><p>效果如下（返回的是页面的HTML代码，只展示了一部分）：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/JKkFDIGFKk.png?imageslim" alt="mark"></p><ol><li>直接加格式后缀</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http http://127.0.0.1:8000/snippets.json  # JSON suffix</span><br><span class="line">http http://127.0.0.1:8000/snippets.api   # Browsable API suffix</span><br></pre></td></tr></table></figure><ol><li>浏览器查看Api</li></ol><p>我们可以直接在浏览器输入 <code>http://127.0.0.1:8000/snippets.api</code> 进行查看，会得到一个美观的页面：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/1cegeECCIe.png?imageslim" alt="mark"></p><h4 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h4><p>我们可以控制 Content-Type 头部信息来提交POST请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http --form POST http://127.0.0.1:8000/snippets/ code=&quot;print 123&quot;</span><br><span class="line">http --json POST http://127.0.0.1:8000/snippets/ code=&quot;print 456&quot;</span><br></pre></td></tr></table></figure><p>它会自动在原有的数据后面添加你提交过去的数据，效果如下：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/e2eLdFfbAg.png?imageslim" alt="mark"></p><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>我们通过<code>PUT</code>来实现修改功能，在我们之前定义的函数<code>views.snippet_detail</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)$'</span>, views.snippet_detail),</span><br></pre></td></tr></table></figure><p>所以通过 url <code>snippets/[id]</code>就可以访问到我们要的数据，就可以对其进行修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http --json PUT http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/snippets/<span class="number">1.j</span>son code=<span class="string">"sss"</span></span><br></pre></td></tr></table></figure><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/BcK1A73b1c.png?imageslim" alt="mark"></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>同之前的修改一样，我们使用<code>DELETE</code>，通过 url <code>snippets/[id]</code>访问数据，提交删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http DELETE http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/snippets/<span class="number">8.j</span>son</span><br></pre></td></tr></table></figure><p>这样我们就成功的删除了一条数据。</p><hr><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本篇文章来自<code>ziv</code>的博客，仅作整理学习分享。<br>点击这里<a href="http://www.comingnext.cn/post/8/" target="_blank" rel="noopener">访问原文</a>。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中，主要讲的是请求和响应，项目里面&lt;code&gt;views.py&lt;/code&gt;中的视图函数都是基于函数的，并且我们介绍了&lt;code&gt;@api_view&lt;/code&gt;这个很有用的装饰器。同时，我们还介绍了&lt;code&gt;APIView&lt;/code&gt;这个类，但是还没使用它。在这篇文章中，我们要做的是把基于方法的视图改为基于类的视图，将会了解到&lt;code&gt;APIView&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="http://liuyang1.club/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Django" scheme="http://liuyang1.club/tags/Django/"/>
    
      <category term="Web" scheme="http://liuyang1.club/tags/Web/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Restful-Api" scheme="http://liuyang1.club/tags/Restful-Api/"/>
    
  </entry>
  
  <entry>
    <title>Django编写Restful-Api：请求与响应</title>
    <link href="http://liuyang1.club/2018/04/06/Django%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"/>
    <id>http://liuyang1.club/2018/04/06/Django编写Restful-Api：请求与响应/</id>
    <published>2018-04-06T03:50:28.000Z</published>
    <updated>2018-04-06T05:34:09.631Z</updated>
    
    <content type="html"><![CDATA[<p>之前已经实现了访问指定URL就返回了指定的数据，这也体现了RESTful-API的一个理念，每一个URL代表着一个资源。当然RESTful API的另一个特性就是，发送不同的请求动作，会返还不同的响应。<br><a id="more"></a></p><hr><h3 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h3><p>平时我们在写Django的视图函数的时候，都会带上一个request参数，这样就能处理平时搭建网站时，浏览器访问网页时发出的常规的<code>HttpRequest</code>。但是现在我们导入了<code>django-rest-framework</code>，它能够对<code>request</code>进行拓展，并且提供更灵活的请求解析。这个特性体现在哪呢？请看下面这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.POST  <span class="comment"># 只能处理表单数据.只能处理POST请求</span></span><br><span class="line">request.data  <span class="comment"># 能处理各种数据。  可以处理'POST', 'PUT' 和 'PATCH'模式的请求</span></span><br></pre></td></tr></table></figure><p>这个例子里面的注释已经说得很清楚，拓展后的<code>request</code>使用<code>request.data</code>就可以处理各种各样的请求了，而原本的<code>request</code>在处理时需要指定请求模式。</p><hr><h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h3><p>和<code>request</code>对象一样，<strong><code>django-rest-framewor</code></strong>也对其进行了很实用的拓展，在我上一篇文章的<strong><code>snippets/views.py</code></strong>中，我们导入了<code>JsonResponse</code>用于返回<code>json</code>格式的响应，在视图函数中是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snippet_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    列出所有已经存在的snippet或者创建一个新的snippet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        snippets = Snippet.objects.all()</span><br><span class="line">        serializer = SnippetSerializer(snippets, many=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(serializer.data, safe=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        data = JSONParser().parse(request)</span><br><span class="line">        serializer = SnippetSerializer(data=data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            serializer.save()</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(serializer.data, status=<span class="number">201</span>)</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(serializer.errors, status=<span class="number">400</span>)</span><br></pre></td></tr></table></figure><p>也就是说，在<code>return</code>的时候就需要指明<strong>json格式</strong>，这样显得很不实用而且很单一，所以经过拓展后的<code>Reponse</code>对象就很方便了，<strong>它会根据客户端的请求头部信息来确定正确的内容类型以返回给客户端</strong>。只需如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Response(data)</span><br></pre></td></tr></table></figure><hr><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>我们知道发送http请求时会返回各种各样的状态吗，但是都是简单的数字，比如200、404等，这些纯数字标识符有时候可能不够明确或者客户端在使用的时候不清楚错误信息甚至是没注意看不到，所以<code>django-rest-framework</code>也对此进行了优化，状态码会是<code>HTTP_400_BAD_REQUEST</code>、<code>HTTP_404_NOT_FOUND</code>这种，极大的提高可读性。</p><h3 id="装饰API视图"><a href="#装饰API视图" class="headerlink" title="装饰API视图"></a>装饰API视图</h3><p>REST框架还提供了一个装饰器和一个类来包装视图函数，可以使用它们来写API视图，让程序能处理的情况更多。</p><ul><li><strong>@api_view装饰器用在基于视图的方法上。</strong></li><li><strong>APIView类用在基于视图的类上。</strong></li></ul><p><strong>注意：</strong></p><blockquote><p>这里使用的是基于视图方法，所以使用的是装饰器@api_view，APIview这个类暂时不会提及。</p></blockquote><p>这两个东西提供的一些功能，让我们省去很多工作，比如说确保你在视图中收到<code>Request</code>对象或在你的<code>Response</code>对象中添加上下文，这样就能实现内容通信。</p><p>另外装饰器可以在接收到输入错误的<code>request.data</code>时抛出<code>ParseError</code>异常，或者在适当的时候返回<code>405 Method Not Allowed</code>状态码。</p><hr><h3 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h3><p>上面说了这么多拓展和优化，接下来就把它们都使用起来，改进一下原本的<strong><code>snippets/views.py</code></strong>，程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status <span class="comment"># 导入HHTP状态</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view <span class="comment">#导入装饰器</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response  <span class="comment">#导入应答</span></span><br><span class="line"><span class="keyword">from</span> snippets.models <span class="keyword">import</span> Snippet <span class="comment"># 导入数据库类</span></span><br><span class="line"><span class="keyword">from</span> snippets.serializers <span class="keyword">import</span> SnippetSerializer <span class="comment"># 导入之前写好的序列化函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view(['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snippet_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    列出所有已经存在的snippet或者创建一个新的snippet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        snippets = Snippet.objects.all()</span><br><span class="line">        serializer = SnippetSerializer(snippets, many=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        serializer = SnippetSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            serializer.save()</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure><p>可以看出，经过改进的代码已经把上面所说的几个<code>django-rest-framework</code>带来的特性都应用起来了，我们可以看出程序代码量变少，并且能处理的情况更多了。 比如说，在原本的视图函数<code>snippet_detail</code>中，处理<code>&#39;PUT&#39;</code>请求的时候，需要先解析<code>json</code>格式的数据再进一步处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = JSONParser().parse(request)</span><br><span class="line">serializer = SnippetSerializer(snippet, data=data)</span><br></pre></td></tr></table></figure><p>也就是说需要分成两步实现，而且这里有一个限制就是只能解析<code>json</code>格式的数据流。而改进后的程序只需一行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializer = SnippetSerializer(data=request.data)</span><br></pre></td></tr></table></figure><p>直接使用之前说的<code>request.data</code>就可以获取到提交过来的数据了，并且可以处理各种数据和各种请求动作，方便了开发。</p><p>还有在<code>return</code>的时候也不需要指定<code>json</code>格式了，由原本的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> JsonResponse(serializer.data, status=<span class="number">201</span>)</span><br></pre></td></tr></table></figure><p>改成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Response(serializer.data,status=status.HTTP_201_CREATED)</span><br></pre></td></tr></table></figure><p>这也意味着返回给客户端的可以是<code>json</code>或者<code>html</code>等格式的内容，返回<code>HTML</code>格式的内容的话，会在浏览器返回经过渲染的、更美观的页面。同时可以看出状态码也改进成了<code>django-rest-framework</code>给我们带来的可读性更高的状态标识码，以上这些措施都很大程度的提高了对客户的友好度。</p><p>对于另一个视图函数的修改也是同样的原理，这里就不做同样的讲解了，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET', 'PUT', 'DELETE'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snippet_detail</span><span class="params">(request, pk)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Retrieve, update or delete a snippet instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        snippet = Snippet.objects.get(pk=pk)</span><br><span class="line">    <span class="keyword">except</span> Snippet.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_404_NOT_FOUND)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        serializer = SnippetSerializer(snippet)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'PUT'</span>:</span><br><span class="line">        serializer = SnippetSerializer(snippet, data=request.data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            serializer.save()</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'DELETE'</span>:</span><br><span class="line">        snippet.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure><p>以上就是对原有的常规的<code>Django</code>视图函数的改进。</p><p><strong>总结一下：</strong></p><blockquote><p>处理request提交过来的数据不需要一定是<code>json</code>格式的数据，返回的响应也不需要一定是<code>json</code>数据，也可以是经过渲染的<code>HTML</code>页面。稍后就会示范使用。</p></blockquote><hr><h3 id="URL添加格式后缀"><a href="#URL添加格式后缀" class="headerlink" title="URL添加格式后缀"></a>URL添加格式后缀</h3><p>既然上面已经说了返回给客户端的<code>Response</code>可是<code>json</code>或者是<code>HTML</code>等格式的内容，那么用户在使用的时候是如何指定返回哪种格式的内容呢，那就是在<strong><code>URL</code></strong>的最后加上后缀。<br>比如<code>http://127.0.0.1:8000/snippets.json</code>，这样就是用户自己指定了返回json格式的<code>Response</code>，而不是我们在后台指定返回固定的格式。</p><p>只需对我们的程序稍加改进就可以了，在两个视图函数添加关键词参数<strong>format</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snippet_list</span><span class="params">(request, format=None)</span>:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snippet_detail</span><span class="params">(request, pk, format=None)</span>:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再修改一下<strong><code>snippets/urls.py</code></strong>，导入<strong><code>format_suffix_patterns</code></strong>（格式后缀模式）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> rest_framework.urlpatterns <span class="keyword">import</span> format_suffix_patterns</span><br><span class="line"><span class="keyword">from</span> snippets <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^snippets/$'</span>, views.snippet_list),</span><br><span class="line">    url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)$'</span>, views.snippet_detail),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">urlpatterns = format_suffix_patterns(urlpatterns)</span><br></pre></td></tr></table></figure><hr><h3 id="测试Api"><a href="#测试Api" class="headerlink" title="测试Api"></a>测试Api</h3><p>首先当然还是可以像上一篇文章中那样的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http http://127.0.0.1:8000/snippets/</span><br></pre></td></tr></table></figure><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/7bfiKd7Kmb.png?imageslim" alt="mark"></p><ol><li>通过<strong>设置Accept头部信息来控制返回的格式</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http http://127.0.0.1:8000/snippets/ Accept:application/json  # JSON</span><br><span class="line">http http://127.0.0.1:8000/snippets/ Accept:text/html         # HTML</span><br></pre></td></tr></table></figure><p>效果如下（返回的是页面的HTML代码，只展示了一部分）：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/JKkFDIGFKk.png?imageslim" alt="mark"></p><ol><li>直接加格式后缀</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http http://127.0.0.1:8000/snippets.json  # JSON suffix</span><br><span class="line">http http://127.0.0.1:8000/snippets.api   # Browsable API suffix</span><br></pre></td></tr></table></figure><ol><li>浏览器查看Api</li></ol><p>我们可以直接在浏览器输入 <code>http://127.0.0.1:8000/snippets.api</code> 进行查看，会得到一个美观的页面：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/1cegeECCIe.png?imageslim" alt="mark"></p><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><h4 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h4><p>我们可以控制 Content-Type 头部信息来提交POST请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http --form POST http://127.0.0.1:8000/snippets/ code=&quot;print 123&quot;</span><br><span class="line">http --json POST http://127.0.0.1:8000/snippets/ code=&quot;print 456&quot;</span><br></pre></td></tr></table></figure><p>它会自动在原有的数据后面添加你提交过去的数据，效果如下：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/e2eLdFfbAg.png?imageslim" alt="mark"></p><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>我们通过<code>PUT</code>来实现修改功能，在我们之前定义的函数<code>views.snippet_detail</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)$'</span>, views.snippet_detail),</span><br></pre></td></tr></table></figure><p>所以通过 url <code>snippets/[id]</code>就可以访问到我们要的数据，就可以对其进行修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http --json PUT http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/snippets/<span class="number">1.j</span>son code=<span class="string">"sss"</span></span><br></pre></td></tr></table></figure><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/BcK1A73b1c.png?imageslim" alt="mark"></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>同之前的修改一样，我们使用<code>DELETE</code>，通过 url <code>snippets/[id]</code>访问数据，提交删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http DELETE http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/snippets/<span class="number">8.j</span>son</span><br></pre></td></tr></table></figure><p>这样我们就成功的删除了一条数据。</p><hr><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本篇文章来自<code>ziv</code>的博客，仅作整理学习分享。<br>点击这里<a href="http://www.comingnext.cn/post/7/" target="_blank" rel="noopener">访问原文</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前已经实现了访问指定URL就返回了指定的数据，这也体现了RESTful-API的一个理念，每一个URL代表着一个资源。当然RESTful API的另一个特性就是，发送不同的请求动作，会返还不同的响应。&lt;br&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="http://liuyang1.club/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Django" scheme="http://liuyang1.club/tags/Django/"/>
    
      <category term="Web" scheme="http://liuyang1.club/tags/Web/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Restful-Api" scheme="http://liuyang1.club/tags/Restful-Api/"/>
    
  </entry>
  
  <entry>
    <title>Django编写Restful-Api：序列化</title>
    <link href="http://liuyang1.club/2018/04/06/Django%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://liuyang1.club/2018/04/06/Django编写Restful-Api：序列化/</id>
    <published>2018-04-05T16:00:31.000Z</published>
    <updated>2018-04-06T05:35:10.722Z</updated>
    
    <content type="html"><![CDATA[<p>利用Django框架实现Restful-Api的序列化，即当其他人访问这个URL时返回<strong>json</strong>格式的数据。<br><a id="more"></a></p><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>首先当然是在虚拟环境中使用了，这里我们使用<code>Django-REST-Framework</code>的库，需要用到的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install django</span><br><span class="line">pip install djangorestframework</span><br><span class="line">pip install pygments <span class="comment"># 用来实现代码高亮</span></span><br></pre></td></tr></table></figure><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>首先创建一个名为<code>tutorial</code>的工程，然后在这个工程中创建一个<code>snippets</code>的APP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django-admin.py startproject tutorial</span><br><span class="line">cd tutorial</span><br><span class="line">python manage.py startapp snippets</span><br></pre></td></tr></table></figure><p>创建完成之后在tutorial/settings.py中修改一下INSTALLED_APPS，添加两个APP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'rest_framework'</span>,</span><br><span class="line">    <span class="string">'snippets.apps.SnippetsConfig'</span>, <span class="comment"># 如果Django&lt;1.9，那么使用snippets代替</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="创建模型类"><a href="#创建模型类" class="headerlink" title="创建模型类"></a>创建模型类</h3><p>创建一个Snippet模型类，用于储存代码段，编写<code>snippets/models.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> pygments.lexers <span class="keyword">import</span> get_all_lexers</span><br><span class="line"><span class="keyword">from</span> pygments.styles <span class="keyword">import</span> get_all_styles</span><br><span class="line"></span><br><span class="line">LEXERS = [item <span class="keyword">for</span> item <span class="keyword">in</span> get_all_lexers() <span class="keyword">if</span> item[<span class="number">1</span>]]</span><br><span class="line">LANGUAGE_CHOICES = sorted([(item[<span class="number">1</span>][<span class="number">0</span>], item[<span class="number">0</span>]) <span class="keyword">for</span> item <span class="keyword">in</span> LEXERS])  <span class="comment"># 得到所有的编程语言</span></span><br><span class="line">STYLE_CHOICES = sorted((item, item) <span class="keyword">for</span> item <span class="keyword">in</span> get_all_styles())  <span class="comment"># 得到所有的配色风格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snippet</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    created = models.DateTimeField(auto_now_add=<span class="keyword">True</span>)</span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>, blank=<span class="keyword">True</span>, default=<span class="string">''</span>)</span><br><span class="line">    code = models.TextField()</span><br><span class="line">    linenos = models.BooleanField(default=<span class="keyword">False</span>)</span><br><span class="line">    language = models.CharField(choices=LANGUAGE_CHOICES, default=<span class="string">'python'</span>, max_length=<span class="number">100</span>)</span><br><span class="line">    style = models.CharField(choices=STYLE_CHOICES, default=<span class="string">'friendly'</span>, max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = (<span class="string">'created'</span>,)</span><br></pre></td></tr></table></figure><p>除了注释的那里，其他的代码都很常规，和我们平时Django开发时是一样的。然后就为这个模型创建并迁移数据（这里只是为了展示，所以使用的<strong>数据库</strong>是Django自带的那个<strong>sqlite</strong>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations snippets</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><hr><h3 id="创建序列化类"><a href="#创建序列化类" class="headerlink" title="创建序列化类"></a>创建序列化类</h3><p>首先解释一下序列化：在这里可以先简单的理解为<code>serializer</code>，把模型实例转化为json格式然后响应出去，这样便于客户端调用时解析使用。</p><p>例如一个<code>PostModel</code>，里面有两个字段分别为<code>title</code>和<code>author</code>，序列化之后就是<code>{&#39;title&#39;:&#39;RESTful API&#39;,&#39;author&#39;:&#39;liu&#39;}</code>这样的<code>json</code>格式，这样明显就更适合各种客户端的使用人员解析使用。</p><p>那么反序列化其实道理差不多，反序列化之后的数据格式更便于后台使用，等下会有例子加深理解。</p><p>解释完序列化，那么接下来就该敲代码了，在<code>snippets</code>下面创建一个<code>serializers.py</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> snippets.models <span class="keyword">import</span> Snippet, LANGUAGE_CHOICES, STYLE_CHOICES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    id = serializers.IntegerField(read_only=<span class="keyword">True</span>)</span><br><span class="line">    title = serializers.CharField(required=<span class="keyword">False</span>, allow_blank=<span class="keyword">True</span>, max_length=<span class="number">100</span>)</span><br><span class="line">    <span class="comment"># 利用字段标志控制序列化器渲染到HTML页面时的的显示模板</span></span><br><span class="line">    code = serializers.CharField(style=&#123;<span class="string">'base_template'</span>: <span class="string">'textarea.html'</span>&#125;)</span><br><span class="line">    linenos = serializers.BooleanField(required=<span class="keyword">False</span>)</span><br><span class="line">    language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default=<span class="string">'python'</span>)</span><br><span class="line">    style = serializers.ChoiceField(choices=STYLE_CHOICES, default=<span class="string">'friendly'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给定经过验证的数据，创建并返回一个新的 Snippet 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Snippet.objects.create(**validated_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给定经过验证的数据，更新并返回一个已经存在的 Snippet 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, instance, validated_data)</span>:</span></span><br><span class="line">        instance.title = validated_data.get(<span class="string">'title'</span>, instance.title)</span><br><span class="line">        instance.code = validated_data.get(<span class="string">'code'</span>, instance.code)</span><br><span class="line">        instance.linenos = validated_data.get(<span class="string">'linenos'</span>, instance.linenos)</span><br><span class="line">        instance.language = validated_data.get(<span class="string">'language'</span>, instance.language)</span><br><span class="line">        instance.style = validated_data.get(<span class="string">'style'</span>, instance.style)</span><br><span class="line">        instance.save()</span><br><span class="line">        <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure><p>create和update方法定义在调用<code>serializer.save()</code>时如何创建或修改完整的实例。</p><p>关于下面这行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code = serializers.CharField(style=&#123;<span class="string">'base_template'</span>:<span class="string">'textarea.html'</span>&#125;)</span><br></pre></td></tr></table></figure><p>暂时需要知道的就是它的功能是控制序列化器渲染到HTML页面时的的显示模板，至于为什么要这样做，是因为这对于控制如何显示可浏览的API特别有用，这将在后面的文章中看到。</p><hr><h3 id="使用序列化器"><a href="#使用序列化器" class="headerlink" title="使用序列化器"></a>使用序列化器</h3><p>首先进入shell模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py shell</span><br></pre></td></tr></table></figure><p>接下来的操作就和学习Django的orm时那样，创建并保存Snippet模型实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> snippets.models <span class="keyword">import</span> Snippet</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> snippets.serializers <span class="keyword">import</span> SnippetSerializer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>snippet = Snippet(code=<span class="string">'foo = "bar"\n'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>snippet.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>snippet = Snippet(code=<span class="string">'print "hello, world"\n'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>snippet.save()</span><br></pre></td></tr></table></figure><p>这个时候查看数据库就会发现相关的表中已经多了两行数据，就是我们刚才创建的数据： image</p><p>也可以继续在shell中查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer = SnippetSerializer(snippet)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer.data</span><br><span class="line">&#123;<span class="string">'code'</span>: <span class="string">'print "hello, world"\n'</span>, <span class="string">'title'</span>: <span class="string">''</span>, <span class="string">'linenos'</span>: <span class="keyword">False</span>, <span class="string">'style'</span></span><br><span class="line">: <span class="string">'friendly'</span>, <span class="string">'language'</span>: <span class="string">'python'</span>, <span class="string">'id'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>将数据渲染成json格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>content = JSONRenderer().render(serializer.data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>content</span><br><span class="line"><span class="string">b'&#123;"id":2,"title":"","code":"print \\"hello, world\\"\\n","linenos":false</span></span><br><span class="line"><span class="string">,"language":"python","style":"friendly"&#125;'</span></span><br></pre></td></tr></table></figure><p>这里已经出现了json格式，也就是说这个json格式的数据就是要展示在某个URL上，大概可以感觉到，等下我们在访问某个URL时，会返回上面这堆数据供你使用，这其实就完成了一个序列化的过程，也可以看出客户端的功能雏形。</p><p>序列化是为了返回json格式的数据给客户端查看和使用数据，那么当客户端需要修改、增加或者删除数据时，就要把过程反过来了，也就是反序列化，把客户端提交的json格式的数据反序列化。</p><p>下面的代码把json数据流解析成Python自带的数据格式，便于我们后台Django的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.utils.six <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stream = BytesIO(content)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = JSONParser().parse(stream)</span><br></pre></td></tr></table></figure><p>检查并保存数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer = SnippetSerializer(data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer.is_valid()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer.validated_data</span><br><span class="line">OrderedDict([(<span class="string">'title'</span>, <span class="string">''</span>), (<span class="string">'code'</span>, <span class="string">'print "hello, world"'</span>), (<span class="string">'linenos'</span>,</span><br><span class="line"> <span class="keyword">False</span>), (<span class="string">'language'</span>, <span class="string">'python'</span>), (<span class="string">'style'</span>, <span class="string">'friendly'</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer.save()</span><br><span class="line">&lt;Snippet: Snippet object&gt;</span><br></pre></td></tr></table></figure><p>这个时候查看数据库又多了一条数据：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180405/C06GmFBgg8.png?imageslim" alt="mark"></p><h3 id="使用-ModelSerializers"><a href="#使用-ModelSerializers" class="headerlink" title="使用 ModelSerializers"></a>使用 ModelSerializers</h3><p>在上面的SnippetSerializer类中，我们继承的是serializers.Serializer类，可以看到SnippetSerializer类中有很多代码其实是和models.py中的Snippet模型类似一样的，所以这里我们可以改进一下。就像在Django中提供了Form类和ModelForm类一样，django-rest-framework为我们提供了Serializer类和ModelSerializer类。利用它可以让我们的代码简洁很多，修改serializers.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnippetSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Snippet</span><br><span class="line">        fields = (<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'code'</span>, <span class="string">'linenos'</span>, <span class="string">'language'</span>, <span class="string">'style'</span>)</span><br></pre></td></tr></table></figure><p>我们可以通过在shell中的打印来检查序列化器实例中的所有字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> snippets.serializers <span class="keyword">import</span> SnippetSerializer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>serializer = SnippetSerializer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(repr(serializer))</span><br></pre></td></tr></table></figure><p>打印后出现的效果如下（language非常长，只截取了一部分）： </p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180405/IGf6F9h5A1.png?imageslim" alt="mark"></p><p>在我们新的SnippetSerializer类中，可以发现和之前的对比代码少了很多，这里体现了ModelSerializer 类的快捷： </p><ul><li><strong>自动确定字段</strong> </li><li><strong>create和update方法的简单默认实现</strong></li></ul><hr><h3 id="编写Django视图"><a href="#编写Django视图" class="headerlink" title="编写Django视图"></a>编写Django视图</h3><p>接下来要做的就是使用我们的新的<code>Serializer</code>类编写一些API视图。编辑<code>snippets/views.py</code>：</p><hr><div><div class="fold_hider"><div class="close hider_title">点击查看</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse, JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"><span class="keyword">from</span> snippets.models <span class="keyword">import</span> Snippet</span><br><span class="line"><span class="keyword">from</span> snippets.serializers <span class="keyword">import</span> SnippetSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snippet_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    列出所有已经存在的snippet或者创建一个新的snippet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        snippets = Snippet.objects.all()</span><br><span class="line">        serializer = SnippetSerializer(snippets, many=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(serializer.data, safe=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        data = JSONParser().parse(request)</span><br><span class="line">        serializer = SnippetSerializer(data=data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            serializer.save()</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(serializer.data, status=<span class="number">201</span>)</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(serializer.errors, status=<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snippet_detail</span><span class="params">(request, pk)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    检索查看、更新或者删除一个代码段</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        snippet = Snippet.objects.get(pk=pk)</span><br><span class="line">    <span class="keyword">except</span> Snippet.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(status=<span class="number">404</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        serializer = SnippetSerializer(snippet)</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'PUT'</span>:</span><br><span class="line">        data = JSONParser().parse(request)</span><br><span class="line">        serializer = SnippetSerializer(snippet, data=data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            serializer.save()</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(serializer.data)</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(serializer.errors, status=<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'DELETE'</span>:</span><br><span class="line">        snippet.delete()</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(status=<span class="number">204</span>)</span><br></pre></td></tr></table></figure></div></div><hr><p>上面的代码都比较好理解，定义了不同http动作时后台不同的操作，在这里也体现了<strong>restful API</strong>的理念。</p><p><strong>需要注意的是记得添加@csrf_exempt修饰器。</strong></p><hr><h3 id="设计Django的urls"><a href="#设计Django的urls" class="headerlink" title="设计Django的urls"></a>设计Django的urls</h3><p>为了让视图函数被调用，那当然需要设计一下url了，这里的处理和平时Django开发时是一样的。首先创建<code>snippets/urls.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> snippets <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^snippets/$'</span>, views.snippet_list),</span><br><span class="line">    url(<span class="string">r'^snippets/(?P&lt;pk&gt;[0-9]+)/$'</span>, views.snippet_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接着就是tutorial/urls.py，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^'</span>, include(<span class="string">'snippets.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h3 id="对API进行测试"><a href="#对API进行测试" class="headerlink" title="对API进行测试"></a>对API进行测试</h3><p>完成了上面那些工作后，就可以开始测试了，<strong>退出shell模式并启动服务器</strong>，根据我们刚才设计的url发送请求，需要先安装<code>httpie</code>模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install httpie</span><br></pre></td></tr></table></figure><p>然后在命令行窗口访问，效果如下：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180406/0GHAah8ahh.png?imageslim" alt="mark"></p><p>或者也可以直接在浏览输入网址访问。</p><p>到这里，也就实现了一个功能，<strong>当其他人访问这个URL时返回json格式的数据给他使用。</strong></p><hr><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本篇文章来自<code>ziv</code>的博客，仅作整理学习分享。</p><p>点击这里<a href="http://www.comingnext.cn/post/6/" target="_blank" rel="noopener">访问原文</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用Django框架实现Restful-Api的序列化，即当其他人访问这个URL时返回&lt;strong&gt;json&lt;/strong&gt;格式的数据。&lt;br&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="http://liuyang1.club/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Django" scheme="http://liuyang1.club/tags/Django/"/>
    
      <category term="Web" scheme="http://liuyang1.club/tags/Web/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Restful-Api" scheme="http://liuyang1.club/tags/Restful-Api/"/>
    
      <category term="序列化" scheme="http://liuyang1.club/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Restful-Api介绍</title>
    <link href="http://liuyang1.club/2018/04/04/Restful-Api%E4%BB%8B%E7%BB%8D/"/>
    <id>http://liuyang1.club/2018/04/04/Restful-Api介绍/</id>
    <published>2018-04-04T13:36:11.000Z</published>
    <updated>2018-04-04T14:08:45.514Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便不同的前端设备与后端进行通信，这导致API构架的流行，甚至出现”API First”的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。</p><a id="more"></a><h2 id="Restful架构"><a href="#Restful架构" class="headerlink" title="Restful架构"></a>Restful架构</h2><hr><div><div class="fold_hider"><div class="close hider_title">点击这里查看</div></div><div class="fold"><p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p><h3 id="资源（Resources）"><a href="#资源（Resources）" class="headerlink" title="资源（Resources）"></a>资源（Resources）</h3><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h3 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a>表现层（Representation）</h3><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><h3 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h3><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>综合上面的解释，我们总结一下什么是RESTful架构：</p><p>（1）每一个URI代表一种资源；</p><p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>（3）客户端通过HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p></div></div><hr><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>API与用户的通信协议，总是使用<code>HTTPs</code>协议。</p><hr><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>应该尽量将API部署在专用域名之下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com</span><br></pre></td></tr></table></figure><p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.org/api/</span><br></pre></td></tr></table></figure><hr><h2 id="版本（Versioning）"><a href="#版本（Versioning）" class="headerlink" title="版本（Versioning）"></a>版本（Versioning）</h2><p>应该将API的版本号放入URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/</span><br></pre></td></tr></table></figure><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<strong>Github采用这种做法。</strong></p><hr><h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p><p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/zoos</span><br><span class="line">https://api.example.com/v1/animals</span><br><span class="line">https://api.example.com/v1/employees</span><br></pre></td></tr></table></figure><hr><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。</p><p>常用的HTTP动词有下面五个<em>（括号里是对应的SQL命令）。</em></p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>还有两个不常用的HTTP动词。</p><ul><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><table><thead><tr><th style="text-align:left">例子</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GET /zoos</td><td style="text-align:left">列出所有动物园</td></tr><tr><td style="text-align:left">POST /zoos</td><td style="text-align:left">新建一个动物园</td></tr><tr><td style="text-align:left">GET /zoos/ID</td><td style="text-align:left">获取某个指定动物园的信息</td></tr><tr><td style="text-align:left">PUT /zoos/ID</td><td style="text-align:left">更新某个指定动物园的信息（提供该动物园的全部信息）</td></tr><tr><td style="text-align:left">PATCH /zoos/ID</td><td style="text-align:left">更新某个指定动物园的信息（提供该动物园的部分信息）</td></tr><tr><td style="text-align:left">DELETE /zoos/ID</td><td style="text-align:left">删除某个动物园</td></tr><tr><td style="text-align:left">GET /zoos/ID/animals</td><td style="text-align:left">列出某个指定动物园的所有动物</td></tr><tr><td style="text-align:left">DELETE /zoos/ID/animals/ID</td><td style="text-align:left">删除某个指定动物园的指定动物</td></tr></tbody></table><hr><h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p><p>下面是一些常见的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br></pre></td></tr></table></figure><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><hr><h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180404/bDjmg54Kl8.png?imageslim" alt="mark"></p><p>状态码的完全列表<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">参见这里</a>。</p><hr><h2 id="错误处理（Error-handling）"><a href="#错误处理（Error-handling）" class="headerlink" title="错误处理（Error handling）"></a>错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET    /collection返回资源对象的列表（数组）</span><br><span class="line">GET    /collection/resource返回单个资源对象</span><br><span class="line">POST   /collection返回新生成的资源对象</span><br><span class="line">PUT    /collection/resource返回完整的资源对象</span><br><span class="line">PATCH  /collection/resource  返回完整的资源对象</span><br><span class="line">DELETE /collection/resource 返回一个空文档</span><br></pre></td></tr></table></figure><hr><h2 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p><p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"link"</span>: &#123;</span><br><span class="line">  <span class="string">"rel"</span>:   <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">  <span class="string">"href"</span>:  <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">  <span class="string">"type"</span>:  <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p><p>Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"current_user_url"</span>: <span class="string">"https://api.github.com/user"</span>,</span><br><span class="line">  <span class="string">"authorizations_url"</span>: <span class="string">"https://api.github.com/authorizations"</span>,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"message"</span>: <span class="string">"Requires authentication"</span>,</span><br><span class="line">  <span class="string">"documentation_url"</span>: <span class="string">"https://developer.github.com/v3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>（1）API的身份认证应该使用OAuth 2.0框架。</p><p>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p><hr><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文来自<strong>阮一峰</strong>先生，仅作整理学习使用。</p><p>访问原文请<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api" target="_blank" rel="noopener">点击这里</a>。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便不同的前端设备与后端进行通信，这导致API构架的流行，甚至出现”API First”的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。&lt;/p&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="http://liuyang1.club/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Web" scheme="http://liuyang1.club/tags/Web/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Restful-Api" scheme="http://liuyang1.club/tags/Restful-Api/"/>
    
  </entry>
  
  <entry>
    <title>Ajax的介绍与实现方法</title>
    <link href="http://liuyang1.club/2018/04/02/Ajax%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://liuyang1.club/2018/04/02/Ajax的介绍与实现方法/</id>
    <published>2018-04-02T06:28:03.000Z</published>
    <updated>2018-04-02T09:06:28.353Z</updated>
    
    <content type="html"><![CDATA[<p>AJAX翻译成中文就是“异步+Javascript+XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML）。<br><a id="more"></a></p><hr><h2 id="Ajax特点"><a href="#Ajax特点" class="headerlink" title="Ajax特点"></a><center>Ajax特点</center></h2><h3 id="1-异步传输"><a href="#1-异步传输" class="headerlink" title="1.异步传输"></a>1.异步传输</h3><h4 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h4><ul><li><p>同步交互：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求；</p></li><li><p>异步交互：客户端发出一个请求后，无需等待服务器响应结束，就可以发出第二个请求。</p></li></ul><h3 id="2-局部刷新"><a href="#2-局部刷新" class="headerlink" title="2.局部刷新"></a>2.局部刷新</h3><p>并不是重新加载全部页面，仅仅加载需要加载的那一部分。这一特点给用户的感受是在<strong>不知不觉中完成请求和响应过程</strong>。</p><hr><h2 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a><center>应用场景举例</center></h2><p>1.在百度搜索栏输入内容，会自动弹出联想输入内容提示：</p><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180402/mihDF0AHCb.png?imageslim" alt="mark"></p><p>2.注册账号的时候，输入已存在的用户名会给与提示：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180402/fbeJLhjIlf.png?imageslim" alt="mark"></p><hr><h2 id="Ajax的优缺点"><a href="#Ajax的优缺点" class="headerlink" title="Ajax的优缺点"></a><center>Ajax的优缺点</center></h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>AJAX使用Javascript技术向服务器发送异步请求；</li><li>AJAX无须刷新整个页面；</li><li>因为服务器响应内容不再是整个页面，而是页面中的局部，所以AJAX性能高；</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>AJAX并不适合所有场景，很多时候还是要使用同步交互；</li><li>AJAX虽然提高了用户体验，但无形中向服务器发送的请求次数增多了，导致服务器压力增大；</li><li>因为AJAX是在浏览器中使用Javascript技术完成的，所以还需要处理浏览器兼容性问题；</li></ul><hr><h2 id="Ajax代码实现"><a href="#Ajax代码实现" class="headerlink" title="Ajax代码实现"></a><center>Ajax代码实现</center></h2><h3 id="基于js的ajax"><a href="#基于js的ajax" class="headerlink" title="基于js的ajax"></a>基于js的ajax</h3><h4 id="AJAX核心（XMLHttpRequest）"><a href="#AJAX核心（XMLHttpRequest）" class="headerlink" title="AJAX核心（XMLHttpRequest）"></a>AJAX核心（XMLHttpRequest）</h4><p>其实AJAX就是在Javascript中多添加了一个对象：<code>XMLHttpRequest</code>对象。所有的异步交互都是使用XMLHttpServlet对象完成的。也就是说，我们只需要学习一个<code>Javascript</code>的新对象即可。</p><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xmlHttp = new XMLHttpRequest()；//（大多数浏览器都支持DOM2规范）</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>各个浏览器对XMLHttpRequest的支持也是不同的！为了处理浏览器兼容问题，给出下面方法来创建XMLHttpRequest对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function createXMLHttpRequest() &#123;</span><br><span class="line">        var xmlHttp;</span><br><span class="line">        // 适用于大多数浏览器，以及IE7和IE更高版本</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            xmlHttp = new XMLHttpRequest();</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            // 适用于IE6</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                xmlHttp = new ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                // 适用于IE5<span class="number">.5</span>，以及IE更早版本</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    xmlHttp = new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">                &#125; catch (e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">return</span> xmlHttp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><h5 id="步骤1-打开与服务器的连接（open方法）"><a href="#步骤1-打开与服务器的连接（open方法）" class="headerlink" title="步骤1:  打开与服务器的连接（open方法）"></a>步骤1:  打开与服务器的连接（open方法）</h5><p>当得到XMLHttpRequest对象后，就可以调用该对象的open()方法打开与服务器的连接了。open()方法的参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(method, url, async)：</span><br></pre></td></tr></table></figure><p>method：请求方式，通常为GET或POST；<br>url：请求的服务器地址，例如：/ajaxdemo1/AServlet，若为GET请求，还可以在URL后追加参数；<br>async：这个参数可以不给，默认值为true，表示异步请求；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xmlHttp = createXMLHttpRequest();</span><br><span class="line">xmlHttp.open(&quot;GET&quot;, &quot;/ajax_get/&quot;, true);</span><br></pre></td></tr></table></figure><h5 id="步骤2-发送请求"><a href="#步骤2-发送请求" class="headerlink" title="步骤2:  发送请求"></a>步骤2:  发送请求</h5><p>当使用open打开连接后，就可以调用<code>XMLHttpRequest</code>对象的send()方法发送请求了。send()方法的参数为POST请求参数，即对应HTTP协议的请求体内容，若是GET请求，需要在URL后连接参数。</p><p><strong>注意：</strong><br>若没有参数，需要给出null为参数！若不给出null为参数，可能会导致FireFox浏览器不能正常发送请求！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.send(null);</span><br></pre></td></tr></table></figure><h5 id="步骤3-接收服务器响应"><a href="#步骤3-接收服务器响应" class="headerlink" title="步骤3:  接收服务器响应"></a>步骤3:  接收服务器响应</h5><p>当请求发送出去后，服务器端就开始执行了，但服务器端的响应还没有接收到。接下来我们来接收服务器的响应。</p><p><code>XMLHttpRequest</code>对象有一个<code>onreadystatechange</code>事件，它会在<code>XMLHttpRequest</code>对象的状态发生变化时被调用。下面介绍一下<code>XMLHttpRequest</code>对象的5种状态：</p><p>0：初始化未完成状态，只是创建了XMLHttpRequest对象，还未调用open()方法；<br>1：请求已开始，open()方法已调用，但还没调用send()方法；<br>2：请求发送完成状态，send()方法已调用；<br>3：开始读取服务器响应；<br>4：读取服务器响应结束。 </p><p><code>onreadystatechange</code>事件会在状态为1、2、3、4时引发。</p><p>下面代码会被执行四次！对应XMLHttpRequest的四种状态！</p><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = function() &#123;</span><br><span class="line">            alert('hello');</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>但通常我们只关心最后一种状态，即读取服务器响应结束时，客户端才会做出改变。我们可以通过XMLHttpRequest对象的readyState属性来得到XMLHttpRequest对象的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = function() &#123;</span><br><span class="line">            if(xmlHttp.readyState == 4) &#123;</span><br><span class="line">                alert(&apos;hello&apos;);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>其实我们还要关心服务器响应的状态码是否为200，其服务器响应为404，或500，那么就表示请求失败了。我们可以通过XMLHttpRequest对象的status属性得到服务器的状态码。</p><p>最后，我们还需要获取到服务器响应的内容，可以通过XMLHttpRequest对象的responseText得到服务器响应内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = function() &#123;</span><br><span class="line">            if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123;</span><br><span class="line">                alert(xmlHttp.responseText);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h5 id="if-发送POST请求"><a href="#if-发送POST请求" class="headerlink" title="if 发送POST请求"></a>if 发送POST请求</h5><p><1>需要设置请求头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.setRequestHeader(“Content-Type”, “application/x-www-form-urlencoded”)；</span><br></pre></td></tr></table></figure></1></p><p><strong>注意 :</strong><br><strong>form表单会默认这个键值对不设定，Web服务器会忽略请求体的内容。</strong></p><p><2>在发送时可以指定请求体了：<code>xmlHttp.send(“username=yuan&amp;password=123”)</code></2></p><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><hr><div><div class="fold_hider"><div class="close hider_title">点击查看代码</div></div><div class="fold"><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;AJAX&lt;/h1&gt;</span><br><span class="line">&lt;button onclick="send()"&gt;测试&lt;/button&gt;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">       function createXMLHttpRequest() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return new XMLHttpRequest();//大多数浏览器</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    return new ActiveXObject("Msxml2.XMLHTTP");</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    return new ActiveXObject("Microsoft.XMLHTTP");</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function send() &#123;</span><br><span class="line">            var xmlHttp = createXMLHttpRequest();</span><br><span class="line">            xmlHttp.onreadystatechange = function() &#123;</span><br><span class="line">                if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123;</span><br><span class="line">                    var div = document.getElementById("div1");</span><br><span class="line">                    div.innerText = xmlHttp.responseText;</span><br><span class="line">                    div.textContent = xmlHttp.responseText;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            xmlHttp.open("POST", "/ajax_post/", true);</span><br><span class="line">            //post: xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");</span><br><span class="line">            xmlHttp.send(null);  //post: xmlHttp.send("b=B");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">       </span><br><span class="line">#--------------------------------views.py </span><br><span class="line">from django.views.decorators.csrf import csrf_exempt</span><br><span class="line"></span><br><span class="line">def login(request):</span><br><span class="line">    print('hello ajax')</span><br><span class="line">    return render(request,'index.html')</span><br><span class="line"></span><br><span class="line">@csrf_exempt   ＃csrf防御</span><br><span class="line">def ajax_post(request):</span><br><span class="line">    print('ok')</span><br><span class="line">    return HttpResponse('helloyuanhao')</span><br></pre></td></tr></table></figure></div></div><hr><h3 id="基于jquery的ajax"><a href="#基于jquery的ajax" class="headerlink" title="基于jquery的ajax"></a>基于jquery的ajax</h3><p>所有方法详情查看菜单中的<strong>附录</strong>。</p><hr><div><div class="fold_hider"><div class="close hider_title">点击查看代码</div></div><div class="fold"><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load staticfiles %&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src="&#123;% static 'JS/jquery-3.1.1.js' %&#125;"&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;button class="send_Ajax"&gt;send_Ajax&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">      //$.ajax的两种使用方式:</span><br><span class="line"></span><br><span class="line">      //$.ajax(settings);</span><br><span class="line">      //$.ajax(url,[settings]);</span><br><span class="line"></span><br><span class="line">       $(".send_Ajax").click(function()&#123;</span><br><span class="line">           $.ajax(&#123;</span><br><span class="line">               url:"/handle_Ajax/",</span><br><span class="line">               type:"POST",</span><br><span class="line">               data:&#123;username:"Yuan",password:123&#125;,</span><br><span class="line"></span><br><span class="line">               success:function(data)&#123;</span><br><span class="line">                   alert(data)</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">                 //=================== error============</span><br><span class="line"></span><br><span class="line">                error: function (jqXHR, textStatus, err) &#123;</span><br><span class="line"></span><br><span class="line">                        // jqXHR: jQuery增强的xhr</span><br><span class="line">                        // textStatus: 请求完成状态</span><br><span class="line">                        // err: 底层通过throw抛出的异常对象，值与错误类型有关</span><br><span class="line">                        console.log(arguments);</span><br><span class="line">                    &#125;,</span><br><span class="line"></span><br><span class="line">                 //=================== complete============</span><br><span class="line"></span><br><span class="line">                complete: function (jqXHR, textStatus) &#123;</span><br><span class="line">                    // jqXHR: jQuery增强的xhr</span><br><span class="line">                    // textStatus: 请求完成状态 success | error</span><br><span class="line">                    console.log('statusCode: %d, statusText: %s', jqXHR.status, jqXHR.statusText);</span><br><span class="line">                    console.log('textStatus: %s', textStatus);</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                //=================== statusCode============</span><br><span class="line">                statusCode: &#123;</span><br><span class="line">                    '403': function (jqXHR, textStatus, err) &#123;</span><br><span class="line">                        console.log(arguments);  //注意：后端模拟errror方式：HttpResponse.status_code=500</span><br><span class="line">                     &#125;,</span><br><span class="line">                    '400': function () &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div></div><hr><h4 id="ajax方法"><a href="#ajax方法" class="headerlink" title="$.ajax方法"></a>$.ajax方法</h4><p><hr><br>这里仅介绍重点的几个参数，详细的参数，可以点开隐藏的参数表。<br><div><div class="fold_hider"><div class="close hider_title">点击查看参数表</div></div><div class="fold"><h5 id="参数表"><a href="#参数表" class="headerlink" title="参数表"></a>参数表</h5><table><thead><tr><th>名称</th><th>值/描述</th></tr></thead><tbody><tr><td>async</td><td>布尔值，表示请求是否异步处理。默认是 true。</td></tr><tr><td>beforeSend(xhr)</td><td>发送请求前运行的函数。</td></tr><tr><td>cache</td><td>布尔值，表示浏览器是否缓存被请求页面。默认是 true。</td></tr><tr><td>complete(xhr,status)</td><td>请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。</td></tr><tr><td>contentType</td><td>发送数据到服务器时所使用的内容类型。默认是：”application/x-www-form-urlencoded”。</td></tr><tr><td>context</td><td>为所有 AJAX 相关的回调函数规定 “this” 值。</td></tr><tr><td>data</td><td>规定要发送到服务器的数据。</td></tr><tr><td>dataFilter(data,type)</td><td>用于处理 XMLHttpRequest 原始响应数据的函数。</td></tr><tr><td>dataType</td><td>预期的服务器响应的数据类型。</td></tr><tr><td>error(xhr,status,error)</td><td>如果请求失败要运行的函数。</td></tr><tr><td>global</td><td>布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。</td></tr><tr><td>ifModified</td><td>布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。</td></tr><tr><td>jsonp</td><td>在一个 jsonp 中重写回调函数的字符串。</td></tr><tr><td>jsonpCallback</td><td>在一个 jsonp 中规定回调函数的名称。</td></tr><tr><td>password</td><td>规定在 HTTP 访问认证请求中使用的密码。</td></tr><tr><td>processData</td><td>布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。</td></tr><tr><td>scriptCharset</td><td>规定请求的字符集。</td></tr><tr><td>success(result,status,xhr)</td><td>当请求成功时运行的函数。</td></tr><tr><td>timeout</td><td>设置本地的请求超时时间（以毫秒计）。</td></tr><tr><td>traditional</td><td>布尔值，规定是否使用参数序列化的传统样式。</td></tr><tr><td>type</td><td>规定请求的类型（GET 或 POST）。</td></tr><tr><td>url</td><td>规定发送请求的 URL。默认是当前页面。</td></tr><tr><td>username</td><td>规定在 HTTP 访问认证请求中使用的用户名。</td></tr><tr><td>xhr</td><td>用于创建 XMLHttpRequest 对象的函数。</td></tr></tbody></table></div></div></p><hr><h5 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h5><ul><li><p><strong>data</strong><br>当前ajax请求要携带的数据，是一个<strong>json</strong>的object对象，ajax方法就会默认地把它编码成某种格式<code>(urlencoded:?a=1&amp;b=2)</code>发送给服务端；此外，ajax默认以get方式发送请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function testData() &#123;</span><br><span class="line">  $.ajax(&quot;/test&quot;,&#123;     //此时的data是一个json形式的对象</span><br><span class="line">     data:&#123;</span><br><span class="line">       a:1,</span><br><span class="line">       b:2</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;);                   //?a=1&amp;b=2</span><br></pre></td></tr></table></figure></li><li><p><strong>processData</strong><br>声明当前的data数据是否进行转码或预处理，默认为true，即预处理；<br>if为false，那么对<strong>data：{a:1,b:2}</strong>会调用<strong>json</strong>对象的<strong>toString()</strong>方法，即<strong>{a:1,b:2}.toString()</strong> ,最后得到一个<strong>［object，Object］</strong>形式的结果。</p></li><li><p><strong>contentType</strong><br>默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。<br>用来指明当前请求的数据编码格式；urlencoded:?a=1&amp;b=2；如果想以其他方式提交数据，<br>比如contentType:”application/json”，即向服务器发送一个json字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&quot;/ajax_get&quot;,&#123;</span><br><span class="line">         </span><br><span class="line">              data:JSON.stringify(&#123;</span><br><span class="line">                   a:22,</span><br><span class="line">                   b:33</span><br><span class="line">               &#125;),</span><br><span class="line">               contentType:&quot;application/json&quot;,</span><br><span class="line">               type:&quot;POST&quot;,</span><br><span class="line">         </span><br><span class="line">           &#125;);                          //&#123;a: 22, b: 33&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：contentType:”application/json”一旦设定，data必须是json字符串，不能是json对象</strong></p><ul><li>traditional<br>一般是我们的data数据有数组时会用到 ：<code>data:{a:22,b:33,c:[&quot;x&quot;,&quot;y&quot;]}</code>,<br>traditional为false会对数据进行深层次迭代；</li></ul><h5 id="响应参数"><a href="#响应参数" class="headerlink" title="响应参数"></a>响应参数</h5><ul><li><strong>dataType</strong><br>预期服务器返回的数据类型,服务器端返回的数据会根据这个值解析后，传递给回调函数。<br>默认不需要显性指定这个属性，ajax会根据服务器返回的content Type来进行转换；<br>比如我们的服务器响应的content Type为json格式，这时ajax方法就会对响应的内容进行一个json格式的转换，if转换成功，我们在success的回调函数里就会得到一个json格式的对象；转换失败就会触发error这个回调函数。<br>如果我们明确地指定目标类型，就可以使用data Type。</li></ul><p>-<strong>dataType的可用值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html｜xml｜json｜text｜script</span><br></pre></td></tr></table></figure></p><h5 id="dataType实例"><a href="#dataType实例" class="headerlink" title="dataType实例"></a>dataType实例</h5><hr><div><div class="fold_hider"><div class="close hider_title">点击查看代码</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'Ajax.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ajax_get</span><span class="params">(request)</span>:</span></span><br><span class="line"></span><br><span class="line">    l=[<span class="string">'alex'</span>,<span class="string">'little alex'</span>]</span><br><span class="line">    dic=&#123;<span class="string">"name"</span>:<span class="string">"alex"</span>,<span class="string">"pwd"</span>:<span class="number">123</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#return HttpResponse(l)      #元素直接转成字符串alexlittle alex</span></span><br><span class="line">    <span class="comment">#return HttpResponse(dic)    #字典的键直接转成字符串namepwd</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(json.dumps(l))</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(json.dumps(dic))<span class="comment"># 传到前端的是json字符串,要想使用,需要JSON.parse(data)</span></span><br><span class="line"></span><br><span class="line">//---------------------------------------------------</span><br><span class="line">    function testData() &#123;</span><br><span class="line"></span><br><span class="line">        $.ajax(<span class="string">'ajax_get'</span>, &#123;</span><br><span class="line">           success: function (data) &#123;</span><br><span class="line">           console.log(data);</span><br><span class="line">           console.log(typeof(data));</span><br><span class="line">           //console.log(data.name);</span><br><span class="line">           //JSON.parse(data);</span><br><span class="line">           //console.log(data.name);</span><br><span class="line">                                     &#125;,</span><br><span class="line">           //dataType:<span class="string">"json"</span>,</span><br><span class="line">                            &#125;</span><br><span class="line">                       )&#125;</span><br></pre></td></tr></table></figure><p><strong>注解:</strong><br>Response Headers的content Type为text/html,所以返回的是String;但如果我们想要一个json对象,设定<code>dataType:&quot;json&quot;</code>即可,相当于告诉ajax方法把服务器返回的数据转成json对象发送到前端.结果为object。<br>当然，<code>return HttpResponse(json.dumps(a),content_type=&quot;application/json&quot;)</code><br>这样就不需要设定<code>dataType:&quot;json&quot;</code>了。<br><code>content_type=&quot;application/json&quot;</code>和<code>content_type=&quot;json&quot;</code>是一样的！</p></div></div><hr><h2 id="实例-用户名是否已被注册"><a href="#实例-用户名是否已被注册" class="headerlink" title="实例-用户名是否已被注册"></a>实例-用户名是否已被注册</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>在注册表单中，当用户填写了用户名后，把光标移开后，会自动向服务器发送异步请求。服务器返回true或false，返回true表示这个用户名已经被注册过，返回false表示没有注册过。</p><p>客户端得到服务器返回的结果后，确定是否在用户名文本框后显示“用户名已被注册”的错误信息！</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>页面中给出注册表单；<br>在username表单字段中添加onblur事件，调用send()方法；<br>send()方法获取username表单字段的内容，向服务器发送异步请求，参数为username；<br>django 的视图函数：获取username参数，判断是否为“yuan”，如果是响应true，否则响应false</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><hr><div><div class="fold_hider"><div class="close hider_title">点击展开代码</div></div><div class="fold"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        function createXMLHttpRequest() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return new XMLHttpRequest();</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function send() &#123;</span><br><span class="line">            var xmlHttp = createXMLHttpRequest();</span><br><span class="line">            xmlHttp.onreadystatechange = function() &#123;</span><br><span class="line">                if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123;</span><br><span class="line">                    if(xmlHttp.responseText == &quot;true&quot;) &#123;</span><br><span class="line">                        document.getElementById(&quot;error&quot;).innerText = &quot;用户名已被注册！&quot;;</span><br><span class="line">                        document.getElementById(&quot;error&quot;).textContent = &quot;用户名已被注册！&quot;;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        document.getElementById(&quot;error&quot;).innerText = &quot;&quot;;</span><br><span class="line">                        document.getElementById(&quot;error&quot;).textContent = &quot;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            xmlHttp.open(&quot;POST&quot;, &quot;/ajax_check/&quot;, true, &quot;json&quot;);</span><br><span class="line">            xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">            var username = document.getElementById(&quot;username&quot;).value;</span><br><span class="line">            xmlHttp.send(&quot;username=&quot; + username);</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//--------------------------------------------------index.html</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;注册&lt;/h1&gt;</span><br><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">用户名：&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;send()&quot;/&gt;&lt;span id=&quot;error&quot;&gt;&lt;/span&gt;&lt;br/&gt;</span><br><span class="line">密　码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//--------------------------------------------------views.py</span><br><span class="line">from django.views.decorators.csrf import csrf_exempt</span><br><span class="line"></span><br><span class="line">def login(request):</span><br><span class="line">    print(&apos;hello ajax&apos;)</span><br><span class="line">    return render(request,&apos;index.html&apos;)</span><br><span class="line">    # return HttpResponse(&apos;helloyuanhao&apos;)</span><br><span class="line"></span><br><span class="line">@csrf_exempt</span><br><span class="line">def ajax_check(request):</span><br><span class="line">    print(&apos;ok&apos;)</span><br><span class="line"></span><br><span class="line">    username=request.POST.get(&apos;username&apos;,None)</span><br><span class="line">    if username==&apos;yuan&apos;:</span><br><span class="line">        return HttpResponse(&apos;true&apos;)</span><br><span class="line">    return HttpResponse(&apos;false&apos;)</span><br></pre></td></tr></table></figure></div></div><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a><center>附录</center></h2><h3 id="jquery的ajax所有方法"><a href="#jquery的ajax所有方法" class="headerlink" title="jquery的ajax所有方法"></a>jquery的ajax所有方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>$.ajax()</code></td><td>执行异步 AJAX 请求</td></tr><tr><td><code>$.ajaxPrefilter()</code></td><td>在每个请求发送之前且被 $.ajax() 处理之前，处理自定义 Ajax 选项或修改已存在选项</td></tr><tr><td><code>$.ajaxSetup()</code></td><td>为将来的 AJAX 请求设置默认值</td></tr><tr><td><code>$.ajaxTransport()</code></td><td>创建处理 Ajax 数据实际传送的对象</td></tr><tr><td><code>$.get()</code></td><td>使用 AJAX 的 HTTP GET 请求从服务器加载数据</td></tr><tr><td><code>$.getJSON()</code></td><td>使用 HTTP GET 请求从服务器加载 JSON 编码的数据</td></tr><tr><td><code>$.getScript()</code></td><td>使用 AJAX 的 HTTP GET 请求从服务器加载并执行 JavaScript</td></tr><tr><td><code>$.param()</code></td><td>创建数组或对象的序列化表示形式（可用于 AJAX 请求的 URL 查询字符串）</td></tr><tr><td><code>$.post()</code></td><td>使用 AJAX 的 HTTP POST 请求从服务器加载数据</td></tr><tr><td><code>ajaxComplete()</code></td><td>规定 AJAX 请求完成时运行的函数</td></tr><tr><td><code>ajaxError()</code></td><td>规定 AJAX 请求失败时运行的函数</td></tr><tr><td><code>ajaxSend()</code></td><td>规定 AJAX 请求发送之前运行的函数</td></tr><tr><td><code>ajaxStart()</code></td><td>规定第一个 AJAX 请求开始时运行的函数</td></tr><tr><td><code>ajaxStop()</code></td><td>规定所有的 AJAX 请求完成时运行的函数</td></tr><tr><td><code>ajaxSuccess()</code></td><td>规定 AJAX 请求成功完成时运行的函数</td></tr><tr><td><code>load()</code></td><td>从服务器加载数据，并把返回的数据放置到指定的元素中</td></tr><tr><td><code>serialize()</code></td><td>编码表单元素集为字符串以便提交</td></tr><tr><td><code>serializeArray()</code></td><td>编码表单元素集为names和values的数组</td></tr></tbody></table><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AJAX翻译成中文就是“异步+Javascript+XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML）。&lt;br&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="http://liuyang1.club/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Django" scheme="http://liuyang1.club/tags/Django/"/>
    
      <category term="Web" scheme="http://liuyang1.club/tags/Web/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Ajax" scheme="http://liuyang1.club/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度</title>
    <link href="http://liuyang1.club/2018/04/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://liuyang1.club/2018/04/01/时间复杂度/</id>
    <published>2018-04-01T14:15:49.000Z</published>
    <updated>2018-04-02T06:26:42.926Z</updated>
    
    <content type="html"><![CDATA[<p>设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度。<br><a id="more"></a></p><hr><h2 id="算法的效率"><a href="#算法的效率" class="headerlink" title="算法的效率"></a>算法的效率</h2><p>虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率。 </p><p>算法的效率主要由以下两个复杂度来评估：<br><strong>时间复杂度</strong>：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。 </p><p><strong>空间复杂度</strong>：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。</p><hr><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h3><p>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p><p>时间复杂度<br>前面提到的时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。</p><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><p>像前面用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。<br>算法复杂度可以从最理想情况、平均情况和最坏情况三个角度来评估，由于平均情况大多和最坏情况持平，而且评估最坏情况也可以避免后顾之忧，因此一般情况下，我们设计算法时都要直接估算最坏情况的复杂度。<br>大O表示法O(f(n)中的f(n)的值可以为1、n、logn、n²等，因此我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶，那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。</p><h3 id="推导大O阶"><a href="#推导大O阶" class="headerlink" title="推导大O阶"></a>推导大O阶</h3><p>推导大O阶，我们可以按照如下的规则来进行推导，得到的结果就是大O表示法： </p><p>1.用常数1来取代运行时间中所有加法常数。<br>2.修改后的运行次数函数中，只保留最高阶项<br>3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。</p><h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>先举了例子，如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum ,n = <span class="number">0</span>, <span class="number">100</span>  <span class="comment"># 执行一次  </span></span><br><span class="line">sum = (<span class="number">1</span>+n)*n/<span class="number">2</span>  <span class="comment"># 执行一次  </span></span><br><span class="line">print(sum)       <span class="comment"># 执行一次</span></span><br></pre></td></tr></table></figure><p>上面算法的运行的次数的函数为f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为O(1)。如果sum = （1+n）*n/2这条语句再执行10遍，因为这与问题大小n的值并没有关系，所以这个算法的时间复杂度仍旧是O(1)，我们可以称之为常数阶。</p><h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>线性阶主要要分析循环结构的运行情况，如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">...  <span class="comment"># 时间复杂度为O(1)的算法</span></span><br></pre></td></tr></table></figure><p>上面算法循环体中的代码执行了n次，因此时间复杂度为O(n)。</p><h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><p>接着看如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(number&lt;n):</span><br><span class="line">number=number*<span class="number">2</span></span><br><span class="line">...  <span class="comment"># 时间复杂度为O(1)的算法</span></span><br></pre></td></tr></table></figure><p>可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。</p><h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><p>下面的代码是循环嵌套：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">       ...  <span class="comment"># 时间复杂度为O(1)的算法</span></span><br></pre></td></tr></table></figure><p>内层循环的时间复杂度在讲到线性阶时就已经得知是O(n)，现在经过外层循环n次，那么这段算法的时间复杂度则为O(n²)。<br>接下来我们来算一下下面算法的时间复杂度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">       ...  <span class="comment"># 时间复杂度为O(1)的算法</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是内循环中i到n，而不是0到n。当i=0时，内循环执行了n次；i=1时内循环执行了n-1次，当i=n-1时执行了1次，我们可以推算出总的执行次数为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n+(n<span class="number">-1</span>)+(n<span class="number">-2</span>)+(n<span class="number">-3</span>)+……+<span class="number">1</span> </span><br><span class="line">=(n+<span class="number">1</span>)+[(n<span class="number">-1</span>)+<span class="number">2</span>]+[(n<span class="number">-2</span>)+<span class="number">3</span>]+[(n<span class="number">-3</span>)+<span class="number">4</span>]+…… </span><br><span class="line">=(n+<span class="number">1</span>)+(n+<span class="number">1</span>)+(n+<span class="number">1</span>)+(n+<span class="number">1</span>)+…… </span><br><span class="line">=(n+<span class="number">1</span>)n/<span class="number">2</span> </span><br><span class="line">=n(n+<span class="number">1</span>)/<span class="number">2</span> </span><br><span class="line">=n²/<span class="number">2</span>+n/<span class="number">2</span></span><br></pre></td></tr></table></figure><p>根据此前讲过的推导大O阶的规则的第二条：只保留最高阶，因此保留n²/2。根据第三条去掉和这个项的常数，则去掉1/2,最终这段代码的时间复杂度为O(n²)。</p><h3 id="其他常见复杂度"><a href="#其他常见复杂度" class="headerlink" title="其他常见复杂度"></a>其他常见复杂度</h3><p>除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度： </p><table><thead><tr><th style="text-align:left">f(n)</th><th style="text-align:left">时间复杂度</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">f(n)=nlogn</td><td style="text-align:left">O(nlogn)</td><td style="text-align:left">称为nlogn阶</td></tr><tr><td style="text-align:left">f(n)=n³</td><td style="text-align:left">O(n³)</td><td style="text-align:left">称为立方阶</td></tr><tr><td style="text-align:left">f(n)=2ⁿ</td><td style="text-align:left">O(2ⁿ)</td><td style="text-align:left">称为指数阶</td></tr><tr><td style="text-align:left">f(n)=n!</td><td style="text-align:left">O(n!)</td><td style="text-align:left">称为阶乘阶</td></tr><tr><td style="text-align:left">f(n)=√n</td><td style="text-align:left">O(√n)</td><td style="text-align:left">称为平方根阶</td></tr></tbody></table><h3 id="复杂度的比较"><a href="#复杂度的比较" class="headerlink" title="复杂度的比较"></a>复杂度的比较</h3><p>下面将算法中常见的f(n)值根据几种典型的数量级来列成一张表，根据这种表，我们来看看各种算法复杂度的差异。</p><table><thead><tr><th>n</th><th>logn</th><th>√n</th><th>nlogn</th><th>n²</th><th>2ⁿ</th><th>n!</th></tr></thead><tbody><tr><td>5</td><td>2</td><td>2</td><td>10</td><td>25</td><td>32</td><td>120</td></tr><tr><td>10</td><td>3</td><td>3</td><td>30</td><td>100</td><td>1024</td><td>3628800</td></tr><tr><td>50</td><td>5</td><td>7</td><td>250</td><td>2500</td><td>约10^15</td><td>约3.0*10^64</td></tr><tr><td>100</td><td>6</td><td>10</td><td>600</td><td>10000</td><td>约10^30</td><td>约9.3*10^157</td></tr><tr><td>1000</td><td>9</td><td>31</td><td>9000</td><td>1000 000</td><td>约10^300</td><td>约4.0*10^2567</td></tr></tbody></table><blockquote><p>从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。</p></blockquote><p>下面给出一个更加直观的图：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180401/55K75cde6a.png?imageslim" alt="mark"></p><p>其中x轴代表n值，y轴代表T(n)值（时间复杂度）。T(n)值随着n的值的变化而变化，其中可以看出O(n!)和O(2ⁿ)随着n值的增大，它们的T(n)值上升幅度非常大，而O(logn)、O(n)、O(nlogn)随着n值的增大，T(n)值上升幅度则很小。<br>常用的时间复杂度按照耗费的时间从小到大依次是：</p><blockquote><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)</p></blockquote><hr><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本篇原文来自刘望舒先生的专栏，略作改动，将代码改为python，并重新排版。</p><p>访问原文请<a href="https://blog.csdn.net/itachi85/article/details/54882603" target="_blank" rel="noopener">点击这里</a>。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm Study Notes" scheme="http://liuyang1.club/categories/Algorithm-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="算法" scheme="http://liuyang1.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="时间复杂度" scheme="http://liuyang1.club/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
      <category term="空间复杂度" scheme="http://liuyang1.club/tags/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Redis初识及使用</title>
    <link href="http://liuyang1.club/2018/03/30/Redis%E5%88%9D%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://liuyang1.club/2018/03/30/Redis初识及使用/</id>
    <published>2018-03-30T14:34:38.000Z</published>
    <updated>2018-03-30T15:19:23.366Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是目前最火爆的内存数据库之一，通过在内存中读写数据，大大提高了读写速度，可以说Redis是实现网站高并发不可或缺的一部分。<br><a id="more"></a></p><hr><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、 list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。与Memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave同步。</p><p>Redis的出现，很大程度补偿了Memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便,Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。</p><hr><h2 id="Redis操作"><a href="#Redis操作" class="headerlink" title="Redis操作"></a>Redis操作</h2><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br></pre></td></tr></table></figure><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p><code>redis</code>模块提供两个类<code>Redis</code>和<code>StrictRedis</code>用于实现Redis的命令，<code>StrictRedis</code>用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = redis.Redis(host=<span class="string">'192.168.0.110'</span>, port=<span class="number">6379</span>,db=<span class="number">0</span>)</span><br><span class="line">r.set(<span class="string">'name'</span>, <span class="string">'zhangsan'</span>)   <span class="comment">#添加</span></span><br><span class="line"><span class="keyword">print</span> (r.get(<span class="string">'name'</span>))       <span class="comment">#获取</span></span><br></pre></td></tr></table></figure><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p><code>redis</code>模块使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数 Redis，这样就可以实现多个Redis实例共享一个连接池。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool = redis.ConnectionPool(host=<span class="string">'192.168.0.110'</span>, port=<span class="number">6379</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.set(<span class="string">'name'</span>, <span class="string">'zhangsan'</span>)   <span class="comment">#添加</span></span><br><span class="line"><span class="keyword">print</span> (r.get(<span class="string">'name'</span>))   <span class="comment">#获取</span></span><br></pre></td></tr></table></figure></p><h3 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h3><p>首先定义一个RedisHelper类，连接Redis，定义频道为monitor，定义发布(publish)及订阅(subscribe)方法。</p><h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisHelper</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__conn = redis.Redis(host=<span class="string">'192.168.0.110'</span>,port=<span class="number">6379</span>)<span class="comment">#连接Redis</span></span><br><span class="line">        self.channel = <span class="string">'monitor'</span> <span class="comment">#定义名称</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">publish</span><span class="params">(self,msg)</span>:</span><span class="comment">#定义发布方法</span></span><br><span class="line">        self.__conn.publish(self.channel,msg)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(self)</span>:</span><span class="comment">#定义订阅方法</span></span><br><span class="line">        pub = self.__conn.pubsub()</span><br><span class="line">        pub.subscribe(self.channel)</span><br><span class="line">        pub.parse_response()</span><br><span class="line">        <span class="keyword">return</span> pub</span><br></pre></td></tr></table></figure><h4 id="发布者"><a href="#发布者" class="headerlink" title="发布者"></a>发布者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#发布</span></span><br><span class="line"><span class="keyword">from</span> RedisHelper <span class="keyword">import</span> RedisHelper</span><br><span class="line"> </span><br><span class="line">obj = RedisHelper()</span><br><span class="line">obj.publish(<span class="string">'hello'</span>)<span class="comment">#发布</span></span><br></pre></td></tr></table></figure><h4 id="订阅者"><a href="#订阅者" class="headerlink" title="订阅者"></a>订阅者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#订阅</span></span><br><span class="line"><span class="keyword">from</span> RedisHelper <span class="keyword">import</span> RedisHelper</span><br><span class="line"> </span><br><span class="line">obj = RedisHelper()</span><br><span class="line">redis_sub = obj.subscribe()<span class="comment">#调用订阅方法</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    msg= redis_sub.parse_response()</span><br><span class="line">    <span class="keyword">print</span> (msg)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis是目前最火爆的内存数据库之一，通过在内存中读写数据，大大提高了读写速度，可以说Redis是实现网站高并发不可或缺的一部分。&lt;br&gt;
    
    </summary>
    
      <category term="Python Study Notes" scheme="http://liuyang1.club/categories/Python-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://liuyang1.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Django中Admin的使用</title>
    <link href="http://liuyang1.club/2018/03/29/Django%E4%B8%ADAdmin%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://liuyang1.club/2018/03/29/Django中Admin的使用/</id>
    <published>2018-03-29T12:15:07.000Z</published>
    <updated>2018-03-30T17:19:41.643Z</updated>
    
    <content type="html"><![CDATA[<p>admin是django强大功能之一，它能从数据库中读取数据，呈现在页面中，进行管理。<br><a id="more"></a></p><hr><h2 id="创建超级用户"><a href="#创建超级用户" class="headerlink" title="创建超级用户"></a>创建超级用户</h2><p>在你所在的django项目路径下，输入代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsupersuer</span><br></pre></td></tr></table></figure><p>接下来，按照提示填写用户名，邮箱(可以为空)，密码，确认密码，这样我们就成功的创建好了一个超级用户。</p><p>之后，我们运行我们的项目：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python mannage.py runserver <span class="number">4000</span></span><br></pre></td></tr></table></figure><p>这时在你的浏览器输入<code>localhost:4000/admin/</code>,就会弹出这样的界面。<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180329/89HehAAk3F.png?imageslim" alt="mark"><br>在里面输入你的账号密码，就可以进入django的管理界面：<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180329/2AgAGhE16a.png?imageslim" alt="mark"><br>我们发现django已经给我们写好了用户组和用户的数据库，在这个页面可以用来添加用户和用户组。</p><h2 id="注册数据库到admin"><a href="#注册数据库到admin" class="headerlink" title="注册数据库到admin"></a>注册数据库到admin</h2><h3 id="使用register方法"><a href="#使用register方法" class="headerlink" title="使用register方法"></a>使用register方法</h3><p>首先，在admin.py下导入所有的数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> blog.models <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>接下来，将想要显示在admin中的数据库注册到admin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin.site.register(UserInfo1)</span><br><span class="line">admin.site.register(UserType1)</span><br></pre></td></tr></table></figure><h3 id="使用register装饰器"><a href="#使用register装饰器" class="headerlink" title="使用register装饰器"></a>使用register装饰器</h3><p>在你自定义的子类上面添加装饰器，表明这里的自定义内容时对应你的哪张表的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(UserInfo1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>刷新我们的网页，就可以看到我们自己建的数据库了<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180329/FdmEc1c3g5.png?imageslim" alt="mark"></p><h2 id="添加其他功能"><a href="#添加其他功能" class="headerlink" title="添加其他功能"></a>添加其他功能</h2><h3 id="修改表单显示"><a href="#修改表单显示" class="headerlink" title="修改表单显示"></a>修改表单显示</h3><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180329/j3mKi69mKm.png?imageslim" alt="mark"><br>默认这里显示的都是UserInfo1，根本看不出，更不谈管理，那么我们如何修改这里显示的内容呢</p><p>很简单，在我们在models中创建表格的时候，自定义一个<code>__str__</code>函数，就可以自定义显示字段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.username</span><br></pre></td></tr></table></figure><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180329/jg8dheDg5G.png?imageslim" alt="mark"></p><h3 id="修改表单显示多个字段"><a href="#修改表单显示多个字段" class="headerlink" title="修改表单显示多个字段"></a>修改表单显示多个字段</h3><p>这需要我们在admin中创建一个<code>admin.ModelAdmin</code>的子类，然后在注册表单的时候，将这个参数加上就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = (<span class="string">"username"</span>, <span class="string">"age"</span>, <span class="string">"user_type"</span>)</span><br><span class="line"></span><br><span class="line">admin.site.register(UserInfo1, MyAdmin)</span><br></pre></td></tr></table></figure><p>刷新页面，发现我们想要的已经显示出来了<br><img src="http://p53x1dszf.bkt.clouddn.com/blog/180329/GiAHK8jjH4.png?imageslim" alt="mark"></p><h3 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h3><p>数据量不大的时候，找想要的很方便，但数据量增大的时候，查找功能就必不可少了。<br>添加方法，和上面一样在子类里面添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search_fields = (<span class="string">"username"</span>,<span class="string">"user_type"</span>)</span><br></pre></td></tr></table></figure><p>右侧的参数，则是添加查找内容的范围。</p><h3 id="添加筛选功能"><a href="#添加筛选功能" class="headerlink" title="添加筛选功能"></a>添加筛选功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_filter = (<span class="string">'username'</span>, )</span><br></pre></td></tr></table></figure><p><img src="http://p53x1dszf.bkt.clouddn.com/blog/180329/hF0mhI3d6B.png?imageslim" alt="mark"></p><h2 id="其他需求"><a href="#其他需求" class="headerlink" title="其他需求"></a>其他需求</h2><h3 id="修改语言为中文"><a href="#修改语言为中文" class="headerlink" title="修改语言为中文"></a>修改语言为中文</h3><p>在settings里面将<code>LANGUAGE_CODE</code>字段的值改为<code>zh-hans</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">'zh-hans'</span></span><br></pre></td></tr></table></figure><h3 id="用户权限控制"><a href="#用户权限控制" class="headerlink" title="用户权限控制"></a>用户权限控制</h3><p>定制加载的列表, 根据不同的人显示不同的内容列表。</p><p>例如：如果是超级管理员就列出所有的，如果不是，就仅列出访问者自己相关的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModelAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        qs = super(MyModelAdmin, self).get_queryset(request)</span><br><span class="line">        <span class="keyword">if</span> request.user.is_superuser:</span><br><span class="line">            <span class="keyword">return</span> qs</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> qs.filter(author=request.user)</span><br></pre></td></tr></table></figure><p><hr></p><p><center>———    未完待续    ———</center></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;admin是django强大功能之一，它能从数据库中读取数据，呈现在页面中，进行管理。&lt;br&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="http://liuyang1.club/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Django" scheme="http://liuyang1.club/tags/Django/"/>
    
      <category term="Web" scheme="http://liuyang1.club/tags/Web/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>调用CMD方法</title>
    <link href="http://liuyang1.club/2018/03/28/%E8%B0%83%E7%94%A8CMD%E6%96%B9%E6%B3%95/"/>
    <id>http://liuyang1.club/2018/03/28/调用CMD方法/</id>
    <published>2018-03-28T14:25:25.000Z</published>
    <updated>2018-03-28T15:30:06.071Z</updated>
    
    <content type="html"><![CDATA[<p>Python调用cmd的各种实现方法及优点与缺点。<br><a id="more"></a></p><hr><h2 id="使用os-system-“cmd”"><a href="#使用os-system-“cmd”" class="headerlink" title="使用os.system(“cmd”)"></a>使用os.system(“cmd”)</h2><p>这是最简单的一种方法，特点是执行的时候程序会打出cmd在linux上执行的信息。使用前需要<code>import os</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">"ls"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="使用Popen模块产生新的process"><a href="#使用Popen模块产生新的process" class="headerlink" title="使用Popen模块产生新的process"></a>使用Popen模块产生新的process</h2><p>现在大部分人都喜欢使用Popen。Popen方法不会打印出cmd在linux上执行的信息。的确，Popen非常强大，支持多种参数和模式。使用前需要<code>from subprocess import Popen, PIPE</code>。</p><h3 id="Popen函数缺陷"><a href="#Popen函数缺陷" class="headerlink" title="Popen函数缺陷"></a>Popen函数缺陷</h3><p>它是一个阻塞的方法。如果运行cmd时产生的内容非常多，函数非常容易阻塞住。</p><blockquote><p><strong>解决办法：</strong>是不使用wait()方法，但是也不能获得执行的返回值了。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.Popen(args, bufsize=<span class="number">0</span>, executable=<span class="keyword">None</span>, stdin=<span class="keyword">None</span>, stdout=<span class="keyword">None</span>, stderr=<span class="keyword">None</span>, preexec_fn=<span class="keyword">None</span>, close_fds=<span class="keyword">False</span>, shell=<span class="keyword">False</span>, cwd=<span class="keyword">None</span>, env=<span class="keyword">None</span>, universal_newlines=<span class="keyword">False</span>, startupinfo=<span class="keyword">None</span>, creationflags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><hr><div><div class="fold_hider"><div class="close hider_title">点击这里，查看具体参数</div></div><div class="fold"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>args</td><td>可以是字符串或者序列类型（如：list，元组），用于指定进程的可执行文件及其参数。如果是序列类型，第一个元素通常是可执行文件的路径。我们也可以显式的使用executeable参数来指定可执行文件的路径。</td></tr><tr><td>bufsize</td><td>指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲(全缓冲)</td></tr><tr><td>stdin, stdout, stderr</td><td>分别表示程序的标准输入、输出、错误句柄。他们可以是PIPE，文件描述符或文件对象，也可以设置为None，表示从父进程继承。</td></tr><tr><td>preexec_fn</td><td>只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用。</td></tr><tr><td>Close_sfs</td><td>在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。我们不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。</td></tr><tr><td>shell</td><td>设为true，程序将通过shell来执行。</td></tr><tr><td>cwd</td><td>用于设置子进程的当前目录</td></tr><tr><td>env</td><td>是字典类型，用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。</td></tr><tr><td>Universal_newlines</td><td>不同操作系统下，文本的换行符是不一样的。如：windows下用’/r/n’表示换，而Linux下用’/n’。如果将此参数设置为True，Python统一把这些换行符当作’/n’来处理。startupinfo与createionflags只在windows下用效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。</td></tr><tr><td>startupinfo，createionflags</td><td>只在windows下有效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。</td></tr></tbody></table></div></div><hr><h3 id="subprocess-PIPE"><a href="#subprocess-PIPE" class="headerlink" title="subprocess.PIPE"></a>subprocess.PIPE</h3><p>在创建Popen对象时，subprocess.PIPE可以初始化stdin, stdout或stderr参数，表示与子进程通信的标准流。</p><h3 id="subprocess-STDOUT"><a href="#subprocess-STDOUT" class="headerlink" title="subprocess.STDOUT"></a>subprocess.STDOUT</h3><p>创建Popen对象时，用于初始化stderr参数，表示将错误通过标准输出流输出。</p><h3 id="Popen的方法"><a href="#Popen的方法" class="headerlink" title="Popen的方法"></a>Popen的方法</h3><h4 id="Popen-poll"><a href="#Popen-poll" class="headerlink" title="Popen.poll()"></a>Popen.poll()</h4><p>用于检查子进程是否已经结束。设置并返回returncode属性。</p><h4 id="Popen-wait"><a href="#Popen-wait" class="headerlink" title="Popen.wait()"></a>Popen.wait()</h4><p>等待子进程结束。设置并返回returncode属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Popen.communicate(input=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。 Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如 果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。</p><h4 id="Popen-send-signal-signal"><a href="#Popen-send-signal-signal" class="headerlink" title="Popen.send_signal(signal)"></a>Popen.send_signal(signal)</h4><p>向子进程发送信号。</p><h4 id="Popen-terminate"><a href="#Popen-terminate" class="headerlink" title="Popen.terminate()"></a>Popen.terminate()</h4><p>停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程。</p><h4 id="Popen-kill"><a href="#Popen-kill" class="headerlink" title="Popen.kill()"></a>Popen.kill()</h4><p>杀死子进程。</p><h4 id="Popen-stdin"><a href="#Popen-stdin" class="headerlink" title="Popen.stdin()"></a>Popen.stdin()</h4><p>如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。</p><h4 id="Popen-stdout"><a href="#Popen-stdout" class="headerlink" title="Popen.stdout()"></a>Popen.stdout()</h4><p>如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。</p><h4 id="Popen-stderr"><a href="#Popen-stderr" class="headerlink" title="Popen.stderr ()"></a>Popen.stderr ()</h4><p>如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。</p><h4 id="Popen-pid"><a href="#Popen-pid" class="headerlink" title="Popen.pid()"></a>Popen.pid()</h4><p>获取子进程的进程ID。</p><h4 id="Popen-returncode"><a href="#Popen-returncode" class="headerlink" title="Popen.returncode ()"></a>Popen.returncode ()</h4><p>获取进程的返回值。如果进程还没有结束，返回None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = Popen(<span class="string">"cp -rf a/* b/"</span>, shell=<span class="keyword">True</span>, stdout=PIPE, stderr=PIPE)  </span><br><span class="line">p.wait()  </span><br><span class="line"><span class="keyword">if</span> p.returncode != <span class="number">0</span>:  </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"Error."</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>  </span><br><span class="line">END</span><br></pre></td></tr></table></figure><hr><h2 id="使用commands-getstatusoutput方法"><a href="#使用commands-getstatusoutput方法" class="headerlink" title="使用commands.getstatusoutput方法"></a>使用commands.getstatusoutput方法</h2><p>这个方法也不会打印出cmd在linux上执行的信息。这个方法唯一的优点是，<strong>它不是一个阻塞的方法</strong>。即没有Popen函数阻塞的问题。使用前需要<code>import commands</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> commands</span><br><span class="line">status, output = commands.getstatusoutput(<span class="string">"ls"</span>)</span><br></pre></td></tr></table></figure><p>还有只获得output和status的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands.getoutput(<span class="string">"ls"</span>)  </span><br><span class="line">commands.getstatus(<span class="string">"ls"</span>)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python调用cmd的各种实现方法及优点与缺点。&lt;br&gt;
    
    </summary>
    
      <category term="Python Study Notes" scheme="http://liuyang1.club/categories/Python-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="CMD" scheme="http://liuyang1.club/tags/CMD/"/>
    
  </entry>
  
  <entry>
    <title>ORM的F与Q查找</title>
    <link href="http://liuyang1.club/2018/03/28/ORM%E4%B8%ADF%E4%B8%8EQ%E6%9F%A5%E6%89%BE/"/>
    <id>http://liuyang1.club/2018/03/28/ORM中F与Q查找/</id>
    <published>2018-03-28T13:25:42.000Z</published>
    <updated>2018-03-28T16:16:03.738Z</updated>
    
    <content type="html"><![CDATA[<p>有时候靠单一的关键字参数查询已经很难满足查询要求，此时就需要ORM的F和Q查询。<br><a id="more"></a></p><hr><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br></pre></td></tr></table></figure><hr><h2 id="F查询"><a href="#F查询" class="headerlink" title="F查询"></a>F查询</h2><blockquote><p>F查询——专门取对象中某列值的操作，<strong>不可使用__双下划线</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于book表中每本书的价格都在原价格的基础上增加20元</span></span><br><span class="line">models.Book.objects.update(price=F(<span class="string">"price"</span>)+<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>取到Book书中price一列值，并对每个值进行＋20的操作</p><hr><h2 id="Q查询"><a href="#Q查询" class="headerlink" title="Q查询"></a>Q查询</h2><blockquote><p>Q查询——对对象的复杂查询</p></blockquote><p>filter() 等方法中的<strong>关键字参数查询都是相当于进行“AND” 操作的</strong>。 如果你需要执行更复杂的查询（例如OR语句），你可以使用Q对象。</p><h3 id="关键字封装"><a href="#关键字封装" class="headerlink" title="关键字封装"></a>关键字封装</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1 Q对象可以对关键字参数进行封装，从而更好地应用多个查询</span></span><br><span class="line">q1=models.Book.objects.filter(Q(title__startswith=<span class="string">'P'</span>)).all()</span><br><span class="line">print(q1)<span class="comment">#[&lt;Book: Python&gt;, &lt;Book: Perl&gt;]</span></span><br></pre></td></tr></table></figure><h3 id="使用操作符"><a href="#使用操作符" class="headerlink" title="使用操作符"></a>使用操作符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以组合使用&amp;,|操作符，当一个操作符是用于两个Q的对象,它产生一个新的Q对象。</span></span><br><span class="line">Q(title__startswith=<span class="string">'P'</span>) | Q(title__startswith=<span class="string">'J'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Q对象可以用~操作符放在前面表示否定，也可允许否定与不否定形式的组合</span></span><br><span class="line">Q(title__startswith=<span class="string">'P'</span>) | ~Q(pub_date__year=<span class="number">2015</span>)</span><br></pre></td></tr></table></figure><h3 id="可使用Q对象的方法"><a href="#可使用Q对象的方法" class="headerlink" title="可使用Q对象的方法"></a>可使用Q对象的方法</h3><ul><li>filter() </li><li>exclude()</li><li>get()</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Q对象可以与关键字参数查询一起使用，不过一定要<strong>把Q对象放在关键字参数查询的前面</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确：</span></span><br><span class="line">Book.objects.get(</span><br><span class="line">    Q(pub_date=date(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">2</span>)) | Q(pub_date=date(<span class="number">2005</span>, <span class="number">5</span>, <span class="number">6</span>)),</span><br><span class="line">    title__startswith=<span class="string">'P'</span>)</span><br><span class="line"><span class="comment"># 错误：</span></span><br><span class="line">Book.objects.get(</span><br><span class="line">    question__startswith=<span class="string">'P'</span>,</span><br><span class="line">    Q(pub_date=date(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">2</span>)) | Q(pub_date=date(<span class="number">2005</span>, <span class="number">5</span>, <span class="number">6</span>)))</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候靠单一的关键字参数查询已经很难满足查询要求，此时就需要ORM的F和Q查询。&lt;br&gt;
    
    </summary>
    
      <category term="Web Study Notes" scheme="http://liuyang1.club/categories/Web-Study-Notes/"/>
    
    
      <category term="Python" scheme="http://liuyang1.club/tags/Python/"/>
    
      <category term="Django" scheme="http://liuyang1.club/tags/Django/"/>
    
      <category term="Web" scheme="http://liuyang1.club/tags/Web/"/>
    
      <category term="数据库" scheme="http://liuyang1.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="ORM" scheme="http://liuyang1.club/tags/ORM/"/>
    
  </entry>
  
</feed>
