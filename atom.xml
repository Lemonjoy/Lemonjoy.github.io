<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Liu&#39;s Tech Blog</title>
  
  <subtitle>Python技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuyang0001.github.io/"/>
  <updated>2020-01-18T06:39:20.796Z</updated>
  <id>https://liuyang0001.github.io/</id>
  
  <author>
    <name>Liu Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>21-合并两个有序链表</title>
    <link href="https://liuyang0001.github.io/2020/01/18/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://liuyang0001.github.io/2020/01/18/21-合并两个有序链表/</id>
    <published>2020-01-18T06:01:01.000Z</published>
    <updated>2020-01-18T06:39:20.796Z</updated>
    
    <content type="html"><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p><hr></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：每次将较小的接到新表的尾端</strong></p></blockquote><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        l3 = ListNode(<span class="keyword">None</span>)  <span class="comment">#合并后的新的头结点</span></span><br><span class="line">        <span class="comment"># 分别创建三个链表的指针</span></span><br><span class="line">        l1_p, l2_p, l3_p = l1, l2, l3</span><br><span class="line">        <span class="comment"># 两指针所指不完全为空</span></span><br><span class="line">        <span class="keyword">while</span> l1_p <span class="keyword">and</span> l2_p:</span><br><span class="line">            <span class="comment"># 将较小的那个结点接到l3的尾端</span></span><br><span class="line">            <span class="keyword">if</span> l1_p.val &lt; l2_p.val:</span><br><span class="line">                l3_p.next=l1_p</span><br><span class="line">                l1_p= l1_p.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l3_p.next=l2_p</span><br><span class="line">                l2_p=l2_p.next</span><br><span class="line">            l3_p = l3_p.next</span><br><span class="line">        <span class="comment"># 将剩余的部分复制给l_others，均为空则为None</span></span><br><span class="line">        l_others = l1_p <span class="keyword">if</span> l1_p <span class="keyword">else</span> l2_p</span><br><span class="line">        l3_p.next = l_others</span><br><span class="line">        <span class="comment"># 返回除了头指针之外的结点</span></span><br><span class="line">        <span class="keyword">return</span> l3.next</span><br></pre></td></tr></table></figure><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 先考虑递归边界问题</span></span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2==<span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="comment"># 最后会返回l1，l2中较小的为头结点</span></span><br><span class="line">        <span class="keyword">elif</span> l1.val &lt; l2.val:</span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1 </span><br><span class="line">        <span class="keyword">elif</span> l1.val&gt;=l2.val:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1,l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>20-有效的括号</title>
    <link href="https://liuyang0001.github.io/2020/01/18/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://liuyang0001.github.io/2020/01/18/20-有效的括号/</id>
    <published>2020-01-18T05:20:24.000Z</published>
    <updated>2020-01-18T06:39:30.146Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><a id="more"></a><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ol><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用栈的先进后出的特性</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        dic = &#123;<span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>,  <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'('</span>: <span class="string">')'</span>&#125;</span><br><span class="line">        stack_ = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">try</span>:  <span class="comment"># 异常处理</span></span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> dic:</span><br><span class="line">                    stack_.append(c)</span><br><span class="line">                <span class="keyword">elif</span> dic[stack_.pop()] != c:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="comment"># 空栈进行pop()会返回IndexError</span></span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> len(stack_) == <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="栈" scheme="https://liuyang0001.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>19-删除链表的倒数第N个结点</title>
    <link href="https://liuyang0001.github.io/2020/01/17/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://liuyang0001.github.io/2020/01/17/19-删除链表的倒数第N个结点/</id>
    <published>2020-01-17T11:15:44.000Z</published>
    <updated>2020-01-17T11:22:50.516Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p>核心思想：采用<strong>双指针</strong>，使他们<strong>相差n</strong>个位置，则后面的指针到达最后一个元素时，前面的指针刚好指向要删除元素的前一个元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 设置双指针</span></span><br><span class="line">        pre, p = head,head</span><br><span class="line">        <span class="comment"># 只有一个结点的情况</span></span><br><span class="line">        <span class="keyword">if</span> head.next==<span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># p先向后移动n个位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            p=p.next</span><br><span class="line">        <span class="comment"># 此时p为空，说明要删除的为头结点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="comment"># 删除位置不为首尾结点，同步向后移动，直到p指向最后一结点</span></span><br><span class="line">        <span class="keyword">while</span> p.next:</span><br><span class="line">            p=p.next</span><br><span class="line">            pre=pre.next</span><br><span class="line">        <span class="comment"># 删除结点</span></span><br><span class="line">        pre.next = pre.next.next</span><br><span class="line">        <span class="comment"># 返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>18-四数之和</title>
    <link href="https://liuyang0001.github.io/2020/01/17/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://liuyang0001.github.io/2020/01/17/18-四数之和/</id>
    <published>2020-01-17T11:03:49.000Z</published>
    <updated>2020-01-17T11:13:07.096Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><a id="more"></a><blockquote><p><strong>注意：答案中不可以包含重复的四元组。</strong></p></blockquote><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p><p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：采用双指针，每次固定两个数，剩下两个数字采用双指针遍历</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">4</span>:  <span class="comment"># 不足四个数</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">4</span>:  <span class="comment"># 正好四个数</span></span><br><span class="line">            <span class="keyword">return</span> [nums] <span class="keyword">if</span> sum(nums) == target <span class="keyword">else</span> []</span><br><span class="line">        nums.sort()  <span class="comment"># 排序</span></span><br><span class="line">        <span class="comment"># 最大的四个数和小于target，最小的四个数和大于target</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums[:<span class="number">4</span>]) &gt; target <span class="keyword">or</span> sum(nums[<span class="number">-4</span>:]) &lt; target:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)<span class="number">-1</span>):</span><br><span class="line">                low = j+<span class="number">1</span>  <span class="comment"># 双指针遍历</span></span><br><span class="line">                high = len(nums)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                    sum_four = nums[i]+nums[j]+nums[low]+nums[high]</span><br><span class="line">                    cur_list = [nums[i], nums[j], nums[low], nums[high]]</span><br><span class="line">                    <span class="keyword">if</span> sum_four == target <span class="keyword">and</span> cur_list <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                        res.append(cur_list)</span><br><span class="line">                    <span class="keyword">if</span> sum_four &lt;= target:</span><br><span class="line">                        low += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum_four &gt; target:</span><br><span class="line">                        high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/4sum" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>17-电话号码的字母组合</title>
    <link href="https://liuyang0001.github.io/2020/01/16/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://liuyang0001.github.io/2020/01/16/17-电话号码的字母组合/</id>
    <published>2020-01-16T13:04:58.000Z</published>
    <updated>2020-01-16T13:55:47.191Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><a id="more"></a><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt=""></p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：回溯算法</strong>（可当成<strong>深度优先</strong>的算法）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># 电话号与九宫格字母相对应</span></span><br><span class="line">        phone_dict = &#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">                      <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">                      <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">                      <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">                      <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">                      <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">                      <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">                      <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]&#125;</span><br><span class="line">        <span class="comment"># 空字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回溯函数:实现效果是类似深度优先</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(digits_cut, tmp)</span>:</span></span><br><span class="line">            <span class="comment"># 遍历到最后一个字母，返回上一层</span></span><br><span class="line">            <span class="keyword">if</span>(digits_cut == <span class="string">""</span>):</span><br><span class="line">                res.append(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> phone_dict[digits_cut[<span class="number">0</span>]]:</span><br><span class="line">                <span class="comment"># 递归下一位字母</span></span><br><span class="line">                dfs(digits_cut=digits_cut[<span class="number">1</span>:], tmp=tmp + c)</span><br><span class="line">        <span class="comment"># 调用回溯函数</span></span><br><span class="line">        dfs(digits, <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>16-最接近的三数之和</title>
    <link href="https://liuyang0001.github.io/2020/01/15/16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://liuyang0001.github.io/2020/01/15/16-最接近的三数之和/</id>
    <published>2020-01-15T12:16:40.000Z</published>
    <updated>2020-01-15T12:38:41.331Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1，2，1，-4],  target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与target最接近的三个数的和为2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：采用双指针，</strong></p><p><strong>若target-sum&gt;0，说明sum太小，low向高移动</strong><br><strong>若target-sum&lt;0，说明sum太大，high向低移动</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 只有三个数字，直接相加返回</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(nums)</span><br><span class="line">        <span class="comment"># 对nums进行排序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="comment"># 初始差值为最大值</span></span><br><span class="line">        d_value = sys.maxsize</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># low=i+1为去除之前判断过得操作</span></span><br><span class="line">            low, high = i+<span class="number">1</span>, len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high):</span><br><span class="line">                x = target - nums[low] - nums[high] - nums[i]</span><br><span class="line">                <span class="comment"># 进行差值</span></span><br><span class="line">                <span class="keyword">if</span> abs(x) &lt; abs(d_value):</span><br><span class="line">                    d_value = x</span><br><span class="line">                <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">                    low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> x &lt; <span class="number">0</span>:</span><br><span class="line">                    high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">        <span class="keyword">return</span> target - d_value</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/3sum-closest" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>14-最长公共前缀</title>
    <link href="https://liuyang0001.github.io/2020/01/14/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>https://liuyang0001.github.io/2020/01/14/14-最长公共前缀/</id>
    <published>2020-01-14T09:32:28.000Z</published>
    <updated>2020-01-14T10:35:45.557Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="暴力法-双重循环"><a href="#暴力法-双重循环" class="headerlink" title="暴力法-双重循环"></a>暴力法-双重循环</h3><blockquote><p>核心思想：分别对比每个元素的每个相同位置的字母，不同即返回结果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> len(strs)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment">#i的范围：[0,最短的字符串长度]</span></span><br><span class="line">        <span class="comment">#j的范围：[0,字符串的数量-1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(min(strs, key=len))):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(strs)<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> strs[j][i] != strs[j+<span class="number">1</span>][i]:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">            res += strs[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="利用特殊函数-zip和set"><a href="#利用特殊函数-zip和set" class="headerlink" title="利用特殊函数-zip和set"></a>利用特殊函数-zip和set</h3><blockquote><p><strong>keypoint：</strong></p><p><strong>1.*进行解包；</strong></p><p><strong>2.zip打包成列表；</strong></p><p><strong>3.set列表去重</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span>     </span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 使用*解包将每一位的字符分别打包成一个列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> zip(*strs):</span><br><span class="line">            <span class="comment"># 去重后列表只剩一个元素</span></span><br><span class="line">            <span class="keyword">if</span> len(set(i)) == <span class="number">1</span>:</span><br><span class="line">                res += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>13-罗马数字转整数</title>
    <link href="https://liuyang0001.github.io/2020/01/13/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://liuyang0001.github.io/2020/01/13/13-罗马数字转整数/</id>
    <published>2020-01-13T04:24:08.000Z</published>
    <updated>2020-01-13T04:39:47.007Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><a id="more"></a><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">数值</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">V</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">X</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">50</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">500</td></tr><tr><td style="text-align:left">M</td><td style="text-align:left">1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。 |<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下<strong>六种情况：</strong> </p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：查找字典，当前value值小于右侧的value值时减去， 否则加上该值</strong></p><p><strong>注意点    ：边界情况的处理</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        hash_map = &#123;<span class="string">'I'</span>:<span class="number">1</span>, <span class="string">'V'</span>:<span class="number">5</span>, <span class="string">'X'</span>:<span class="number">10</span>, <span class="string">'L'</span>:<span class="number">50</span>, <span class="string">'C'</span>:<span class="number">100</span>, <span class="string">'D'</span>:<span class="number">500</span>, <span class="string">'M'</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="comment"># 右侧的value大于当前value,减去当前值</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; len(s)<span class="number">-1</span>) <span class="keyword">and</span> (hash_map[s[i]] &lt; hash_map[s[i+<span class="number">1</span>]]):</span><br><span class="line">                res -= hash_map[s[i]]</span><br><span class="line">            <span class="comment"># 否则，则加上当前值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += hash_map[s[i]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>12-整数转罗马数字</title>
    <link href="https://liuyang0001.github.io/2020/01/12/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>https://liuyang0001.github.io/2020/01/12/12-整数转罗马数字/</id>
    <published>2020-01-12T07:38:42.000Z</published>
    <updated>2020-01-12T10:28:47.363Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><a id="more"></a><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">数值</th></tr></thead><tbody><tr><td style="text-align:left">I</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">V</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">X</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">50</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">500</td></tr><tr><td style="text-align:left">M</td><td style="text-align:left">1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。 |<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下<strong>六种情况：</strong> </p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p><hr></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：使用贪心算法</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        num_dict = &#123;<span class="number">1</span>: <span class="string">'I'</span>,</span><br><span class="line">                    <span class="number">4</span>: <span class="string">'IV'</span>,</span><br><span class="line">                    <span class="number">5</span>: <span class="string">'V'</span>,</span><br><span class="line">                    <span class="number">9</span>: <span class="string">'IX'</span>,</span><br><span class="line">                    <span class="number">10</span>: <span class="string">'X'</span>,</span><br><span class="line">                    <span class="number">40</span>: <span class="string">'XL'</span>,</span><br><span class="line">                    <span class="number">50</span>: <span class="string">'L'</span>,</span><br><span class="line">                    <span class="number">90</span>: <span class="string">'XC'</span>,</span><br><span class="line">                    <span class="number">100</span>: <span class="string">'C'</span>,</span><br><span class="line">                    <span class="number">400</span>: <span class="string">'CD'</span>,</span><br><span class="line">                    <span class="number">500</span>: <span class="string">'D'</span>,</span><br><span class="line">                    <span class="number">900</span>: <span class="string">'CM'</span>,</span><br><span class="line">                    <span class="number">1000</span>: <span class="string">'M'</span>&#125;</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 贪心算法，将字典逆置，从大的开始除</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> sorted(num_dict.keys())[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            tmp = num//key</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += num_dict[key] * (tmp)</span><br><span class="line">            <span class="comment"># 更新num值</span></span><br><span class="line">            num -= key*(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心算法" scheme="https://liuyang0001.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>11-盛最多水的容器</title>
    <link href="https://liuyang0001.github.io/2020/01/11/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>https://liuyang0001.github.io/2020/01/11/11-盛最多水的容器/</id>
    <published>2020-01-11T06:46:00.000Z</published>
    <updated>2020-01-11T06:54:35.842Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><a id="more"></a><blockquote><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p></blockquote><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt=""></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><hr></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line"></span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure><p><hr></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：只有相对短的一边向内收缩才有可能使得面积变大</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        left, right, res = <span class="number">0</span>, len(height)<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right):</span><br><span class="line">            <span class="comment"># 判断是否需要更新最大面积</span></span><br><span class="line">            <span class="keyword">if</span> min(height[left], height[right])*(right-left) &gt; res:</span><br><span class="line">                res = min(height[left], height[right]) * (right - left)</span><br><span class="line">            <span class="comment"># 使得短的一端向内收缩</span></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>10-正则表达式匹配</title>
    <link href="https://liuyang0001.github.io/2020/01/10/10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>https://liuyang0001.github.io/2020/01/10/10-正则表达式匹配/</id>
    <published>2020-01-10T14:59:41.000Z</published>
    <updated>2020-01-10T15:33:05.212Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><a id="more"></a><table><thead><tr><th>字符</th><th>匹配规则</th></tr></thead><tbody><tr><td>.</td><td>匹配任意单个字符</td></tr><tr><td>*</td><td>匹配零个或多个前面的那一个元素</td></tr></tbody></table><p><strong>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</strong></p><blockquote><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。</p><p>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p></blockquote><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;aa&quot;p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;aa&quot;p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;ab&quot;p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;aab&quot;p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, text: str, pattern: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 递归边界：</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pattern: </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> text</span><br><span class="line">        <span class="comment"># text 非空并且p[0]==s[0]或者“.”</span></span><br><span class="line">        first = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] <span class="keyword">in</span> &#123;text[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line">        <span class="comment"># 处理带星号的问题</span></span><br><span class="line">        <span class="keyword">if</span> len(pattern) &gt;= <span class="number">2</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(text, pattern[<span class="number">2</span>:]) <span class="keyword">or</span> first <span class="keyword">and</span> self.isMatch(text[<span class="number">1</span>:], pattern)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 正常递归</span></span><br><span class="line">            <span class="keyword">return</span> first <span class="keyword">and</span> self.isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>9-回文数</title>
    <link href="https://liuyang0001.github.io/2020/01/09/9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>https://liuyang0001.github.io/2020/01/09/9-回文数/</id>
    <published>2020-01-09T02:25:44.000Z</published>
    <updated>2020-01-09T02:36:40.402Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>直接转换成字符串对比即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> str(x)==str(x)[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>8-字符串转换整数</title>
    <link href="https://liuyang0001.github.io/2020/01/08/8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"/>
    <id>https://liuyang0001.github.io/2020/01/08/8-字符串转换整数/</id>
    <published>2020-01-08T05:20:29.000Z</published>
    <updated>2020-01-08T06:28:03.667Z</updated>
    
    <content type="html"><![CDATA[<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><a id="more"></a><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><blockquote><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p></blockquote><p><strong>在任何情况下，若函数不能进行有效的转换时，请返回 0。</strong></p><blockquote><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;  -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line"></span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line"></span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line"></span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure><h2 id="解法-常规"><a href="#解法-常规" class="headerlink" title="解法-常规"></a>解法-常规</h2><p>该题解法很容易想到，只是有很多小细节需要注意。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        str_ = s.strip()  <span class="comment"># 去掉字符串的空白</span></span><br><span class="line">        <span class="keyword">if</span> len(str_) == <span class="number">0</span>:  <span class="comment"># 空字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums_ls = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        symbols_ls = [<span class="string">"-"</span>, <span class="string">"+"</span>]</span><br><span class="line">        <span class="comment"># 判断首个字符</span></span><br><span class="line">        <span class="keyword">if</span> str_[<span class="number">0</span>]<span class="keyword">not</span> <span class="keyword">in</span> nums_ls <span class="keyword">and</span> str_[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> symbols_ls:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = str_[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 判断后面的字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> str_[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> nums_ls:</span><br><span class="line">                res += i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">try</span>: <span class="comment"># 只有正负号时，返回0</span></span><br><span class="line">            res = int(res)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># if res &gt; 2147483647:</span></span><br><span class="line">        <span class="comment">#     return 2147483647</span></span><br><span class="line">        <span class="comment"># elif res &lt; -2147483648:</span></span><br><span class="line">        <span class="comment">#     return -2147483648</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     return res</span></span><br><span class="line">        <span class="comment"># 功能同上面注释部分，不过更加优雅</span></span><br><span class="line">        <span class="keyword">return</span> min(max(res, <span class="number">-2147483648</span>), <span class="number">2147483647</span>)</span><br></pre></td></tr></table></figure><h2 id="解法-正则"><a href="#解法-正则" class="headerlink" title="解法-正则"></a>解法-正则</h2><p>利用正则表达式，来提取有效字符串。</p><table><thead><tr><th>正则</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开头</td></tr><tr><td>[+-]</td><td>代表一个+字符或-字符</td></tr><tr><td>?</td><td>前面一个字符可有可无</td></tr><tr><td>\d</td><td>一个数字</td></tr><tr><td>+</td><td>前面一个字符的一个或多个</td></tr><tr><td>*</td><td>前面一个字符的零个或多个</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> max(min(int(*re.findall(<span class="string">'^[\+\-]?\d+'</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), <span class="number">-2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>7-整数反转</title>
    <link href="https://liuyang0001.github.io/2020/01/07/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>https://liuyang0001.github.io/2020/01/07/7-整数反转/</id>
    <published>2020-01-07T08:17:26.000Z</published>
    <updated>2020-01-07T08:32:40.572Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思路：int -&gt; abs(int) -&gt; str[::-1] -&gt; int</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        y = abs(x)</span><br><span class="line">        k = int(str(y)[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">2147483647</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> k*(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode刷题笔记</title>
    <link href="https://liuyang0001.github.io/2020/01/07/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://liuyang0001.github.io/2020/01/07/Leetcode刷题笔记/</id>
    <published>2020-01-07T06:54:39.000Z</published>
    <updated>2020-01-07T07:16:14.461Z</updated>
    
    <content type="html"><![CDATA[<p>所有刷题笔记内容的汇总，与个人总结。</p><a id="more"></a><hr><table><thead><tr><th style="text-align:center">#</th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">源码文件</th><th style="text-align:center">博客文章</th></tr></thead><tbody><tr><td style="text-align:center">001</td><td style="text-align:center">两数之和</td><td style="text-align:center">简单</td><td style="text-align:center">数组；哈希表</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/1_TwoSum.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/02/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/">:memo:</a></td></tr><tr><td style="text-align:center">002</td><td style="text-align:center">两数相加</td><td style="text-align:center">中等</td><td style="text-align:center">链表；数学</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/2_AddTwoNumbers.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/03/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/">:memo:</a></td></tr><tr><td style="text-align:center">003</td><td style="text-align:center">无重复字符的最长子串</td><td style="text-align:center">中等</td><td style="text-align:center">字符串；滑动窗口</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/3_LengthOfLongestSubstring.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/03/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">:memo:</a></td></tr><tr><td style="text-align:center">004</td><td style="text-align:center">寻找两个有序数组的中位数</td><td style="text-align:center">困难</td><td style="text-align:center">数组；分治算法</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/4_findMedianSortedArrays.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/04/4-寻找两个有序数组的中位数/">:memo:</a></td></tr><tr><td style="text-align:center">005</td><td style="text-align:center">最长回文子串</td><td style="text-align:center">中等</td><td style="text-align:center">字符串；动态规划；中心扩展</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/5_longestPalindrome.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/05/5-最长回文子串/">:memo:</a></td></tr><tr><td style="text-align:center">006</td><td style="text-align:center">Z字形变换</td><td style="text-align:center">中等</td><td style="text-align:center">字符串</td><td style="text-align:center"><a href="https://github.com/Liuyang0001/LeetCode_By_Python/blob/master/Codes/6_convert.py" target="_blank" rel="noopener">Python3.5.2</a></td><td style="text-align:center"><a href="https://liuyang0001.github.io/2020/01/06/6-Z字形变换/">:memo:</a></td></tr><tr><td style="text-align:center">007</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">008</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有刷题笔记内容的汇总，与个人总结。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>6.Z字形变换</title>
    <link href="https://liuyang0001.github.io/2020/01/06/6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>https://liuyang0001.github.io/2020/01/06/6-Z字形变换/</id>
    <published>2020-01-06T10:10:21.000Z</published>
    <updated>2020-01-06T10:29:26.943Z</updated>
    
    <content type="html"><![CDATA[<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><a id="more"></a><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>Key Point：</strong>巧妙利用flag实现触碰到边界时进行“<strong>回弹</strong>”的效果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows&lt;<span class="number">2</span>: <span class="comment"># 该算法在小于2时，直接返回即可</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 初始化一个长度为numRows的列表</span></span><br><span class="line">        ls = [<span class="string">""</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numRows)]</span><br><span class="line">        flag, i = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> string <span class="keyword">in</span> s:</span><br><span class="line">            ls[i] += string</span><br><span class="line">            <span class="comment"># i等于0或者numRows-1时，改变方向</span></span><br><span class="line">            <span class="keyword">if</span> i % (numRows<span class="number">-1</span>) == <span class="number">0</span>:</span><br><span class="line">                flag = -flag</span><br><span class="line">            i += flag</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(ls)</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/zigzag-conversion" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>5.最长回文子串</title>
    <link href="https://liuyang0001.github.io/2020/01/05/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://liuyang0001.github.io/2020/01/05/5-最长回文子串/</id>
    <published>2020-01-05T06:14:37.000Z</published>
    <updated>2020-01-05T11:53:38.839Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="1-中心扩展"><a href="#1-中心扩展" class="headerlink" title="1-中心扩展"></a>1-中心扩展</h3><p>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。</p><p><img src="https://pic.leetcode-cn.com/1b9bfe346a4a9a5718b08149be11236a6db61b3922265d34f22632d4687aa0a8-image.png" alt=""></p><p>由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 <code>n+n-1</code> 个中心。</p><p><strong>时间复杂度：O<em>(</em>n<em>²）   空间复杂度：O(1）</em></strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 中心扩展</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expandAroundCenter</span><span class="params">(self,s: str,left:int,right:int)</span> -&gt; str:</span></span><br><span class="line">        L, R = left, right</span><br><span class="line">        <span class="keyword">while</span> L&gt;= <span class="number">0</span> <span class="keyword">and</span> R&lt; len(s) <span class="keyword">and</span> s[L]==s[R]:</span><br><span class="line">            L -= <span class="number">1</span></span><br><span class="line">            R += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[L+<span class="number">1</span>:R]</span><br><span class="line">    <span class="comment"># 求最长回文子串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>: <span class="comment"># 长度小于等于1直接返回原字符串</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        res = s[:<span class="number">1</span>] <span class="comment"># 初始化result为字符串首位</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            len1 = self.expandAroundCenter(s, i, i)</span><br><span class="line">            len2 = self.expandAroundCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 迭代res使其成为最长的子串</span></span><br><span class="line">            res = max(len1,len2,res,key=len)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="2-马拉车算法（Manacher’s-Algorithm）"><a href="#2-马拉车算法（Manacher’s-Algorithm）" class="headerlink" title="2-马拉车算法（Manacher’s Algorithm）"></a>2-马拉车算法（Manacher’s Algorithm）</h3><p>Manacher‘s Algorithm是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p><p>首先我们解决下奇数和偶数的问题，在每个字符间插入 “#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。</p><p><img src="https://pic.leetcode-cn.com/ad2b5e0da4a3a35b60f60c9a5a2be07a8074f9be0fe1597351eeff7dc460789a-image.png" alt=""></p><p>首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 “#” 的原字符串的总长度。例如下图中下标是 6 的地方，可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 “#c#b#c#b#c#”。而去掉 # 恢复到原来的字符串，变成 “cbcbc”，它的长度刚好也就是 5。</p><p><img src="https://pic.leetcode-cn.com/ae2c30d48d35faa7f3d0d8bc4fe18d0691f3d13dcfc5846ddce1bf7a002681f5-image.png" alt=""></p><p><strong>求原字符串下标</strong><br>用 P 的下标 i 减去 P [ i ]，再除以 2，就是原字符串的开头下标了。</p><p>例如我们找到 P[ i ] 的最大值为 5，也就是回文串的最大长度是 5，对应的下标是 6，所以原字符串的开头下标是（6 - 5 ）/ 2 = 0。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。</p><p><strong>求每个 P [ i ]</strong><br>接下来是算法的关键了，它充分利用了回文串的对称性。</p><p>我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。</p><p>让我们考虑求 P [ i ] 的时候，如下图。</p><p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。</p><p><img src="https://pic.leetcode-cn.com/29eb66280ca149c3bf5d9906e066b4a2b39d1bf8f9dd0533ca00479aca6f4f39-image.png" alt=""></p><p>我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。</p><p>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。</p><ol><li><strong>超出了 R</strong></li></ol><p><img src="https://pic.leetcode-cn.com/b0d52a5f30747e55ef09b3c7b7cfc23026e37040edc41f387263e8f8a0ba8f49-image.png" alt=""></p><p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p><ol><li><strong>P [ i_mirror ] 遇到了原字符串的左边界</strong></li></ol><p><img src="https://pic.leetcode-cn.com/714e6f768e67304fb7162ecac3ae85fcf23ad82a21456e8ca55ac2c8cfd2609e-image.png" alt=""></p><p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#”，之后遇到了 “^” 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p><ol><li><strong>i 等于了 R</strong><br>此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。</li></ol><p><strong>考虑 C 和 R 的更新</strong><br>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p><p><img src="https://pic.leetcode-cn.com/5fbe52880634a9d5fa60ad5e126e8c5c38c5a6eadd0c901a3495dc1307d46d6b-image.png" alt=""></p><p>此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。</p><p>作者：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/" target="_blank" rel="noopener">windliang|链接地址</a></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 马拉车算法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 将一个可能是偶数长/奇数长的字符串，首位以及每个字符间添加#</span></span><br><span class="line">        test = <span class="string">'#'</span>+<span class="string">'#'</span>.join(s)+<span class="string">'#'</span></span><br><span class="line">        <span class="comment"># 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(test)):</span><br><span class="line">            left = i - <span class="number">1</span></span><br><span class="line">            right = i + <span class="number">1</span></span><br><span class="line">            step = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len(test) <span class="keyword">and</span> test[left] == test[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 找到合适的起点位置</span></span><br><span class="line">            <span class="keyword">if</span> step &gt; max_len:</span><br><span class="line">                max_len = step</span><br><span class="line">                start = (i - max_len) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="动态规划" scheme="https://liuyang0001.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="中心扩展" scheme="https://liuyang0001.github.io/tags/%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>4.寻找两个有序数组的中位数</title>
    <link href="https://liuyang0001.github.io/2020/01/04/4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://liuyang0001.github.io/2020/01/04/4-寻找两个有序数组的中位数/</id>
    <published>2020-01-04T08:35:37.000Z</published>
    <updated>2020-01-07T06:54:51.724Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line"></span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line"></span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p><strong>分别在num1和num2切割，找到满足Lmax1&lt;Rmin2且Lmax2&lt;Rmin的位置。</strong></p><h3 id="奇偶问题"><a href="#奇偶问题" class="headerlink" title="奇偶问题"></a>奇偶问题</h3><p>两个数组合并后的长度，有可能是偶数，也有可能是奇数。如果可以让数组长度总是为偶数，那么就可以用公式覆盖。</p><p>通过虚拟加入<code>&quot;#&quot;</code>，让每个数组的长度都变成 2x + 1，所以 <code>n+m -&gt; 2n + 2m + 2</code>，恒为<strong>偶数</strong>。</p><p>转换后，<strong>原始的元素可以通过新下标//2得到。</strong></p><p><img src="https://pic.leetcode-cn.com/9e95202ed9e3fbad08971f69e9212b817750e05d6d6cece656cda25385f04a1e-image.png" alt=""></p><p>比如9，原来是3位，现在是7位， 7//2=3</p><p>而对于割，如果<code>‘#’</code>上等于割在2个元素之间，割在数字上等于把数字划到2个部分，总是有以下成立：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LMaxi = (Ci-1)/2 位置上的元素</span><br><span class="line">RMini = Ci/2 位置上的元素</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/ji-yu-bian-bian-xiong-de-shuo-ming-xue-xi-hou-shi-/" target="_blank" rel="noopener">点击查看详细</a></p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        <span class="comment"># 使得num2成为更长的表</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; m:</span><br><span class="line">            <span class="keyword">return</span> self.findMedianSortedArrays(nums2, nums1)</span><br><span class="line"></span><br><span class="line">        start_pos = <span class="number">0</span></span><br><span class="line">        end_pos = <span class="number">2</span> * m</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start_pos &lt;= end_pos:</span><br><span class="line">            c1 = (start_pos + end_pos) // <span class="number">2</span></span><br><span class="line">            c2 = m + n - c1  <span class="comment"># 因为数组从0开始，所以c1+c2=(m+n+1)-1</span></span><br><span class="line">            <span class="comment"># 切割nums1</span></span><br><span class="line">            LMax1 = nums1[(c1 - <span class="number">1</span>) // <span class="number">2</span>] <span class="keyword">if</span> c1 &gt; <span class="number">0</span> <span class="keyword">else</span> (<span class="number">-1</span> * sys.maxsize)</span><br><span class="line">            RMin1 = nums1[c1 // <span class="number">2</span>] <span class="keyword">if</span> c1 &lt; <span class="number">2</span> * n <span class="keyword">else</span> sys.maxsize</span><br><span class="line">            <span class="comment"># 切割nums2</span></span><br><span class="line">            LMax2 = nums2[(c2 - <span class="number">1</span>) // <span class="number">2</span>] <span class="keyword">if</span> c2 &gt; <span class="number">0</span> <span class="keyword">else</span> (<span class="number">-1</span> * sys.maxsize)</span><br><span class="line">            RMin2 = nums2[c2 // <span class="number">2</span>] <span class="keyword">if</span> c2 &lt; <span class="number">2</span> * m <span class="keyword">else</span> sys.maxsize</span><br><span class="line">            <span class="comment"># 不满足LMax&lt;RMin 则进行调整切割位置</span></span><br><span class="line">            <span class="keyword">if</span> LMax1 &gt; RMin2:</span><br><span class="line">                end_pos = c1 - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> LMax2 &gt; RMin1:</span><br><span class="line">                start_pos = c1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 找到合适的c1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 返回中位数</span></span><br><span class="line">        <span class="keyword">return</span> (max(LMax1, LMax2) + min(RMin1, RMin2)) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="分治算法" scheme="https://liuyang0001.github.io/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>3.无重复字符的最长子串</title>
    <link href="https://liuyang0001.github.io/2020/01/03/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>https://liuyang0001.github.io/2020/01/03/3-无重复字符的最长子串/</id>
    <published>2020-01-03T07:46:58.000Z</published>
    <updated>2020-01-04T09:38:13.714Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这道题主要用到思路是：<strong>滑动窗口</strong></p><blockquote><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！</p></blockquote><blockquote><p>如何移动？</p><p>我们只要找到那个相同元素的位置，把队列中它左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:<span class="keyword">return</span> <span class="number">0</span> <span class="comment"># 如果字符串s为空，返回0</span></span><br><span class="line">        lookup = [] <span class="comment"># 初始化窗口</span></span><br><span class="line">        max_len = <span class="number">0</span> <span class="comment"># 窗口长度</span></span><br><span class="line">        cur_len = <span class="number">0</span> <span class="comment"># 当前子串长度</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): <span class="comment"># 遍历字符串s</span></span><br><span class="line">            val = s[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">in</span> lookup: <span class="comment"># 如果该值不在窗口中</span></span><br><span class="line">                lookup.append(val) <span class="comment"># 添加到窗口内</span></span><br><span class="line">                cur_len += <span class="number">1</span>  <span class="comment"># 当前长度+1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 如果该值在窗口中已存在</span></span><br><span class="line">                index = lookup.index(val) <span class="comment"># 获取其在窗口中的位置</span></span><br><span class="line">                lookup = lookup[index+<span class="number">1</span>:] <span class="comment"># 移除该位置及之前的字符</span></span><br><span class="line">                lookup.append(val) </span><br><span class="line">                cur_len = len(lookup) <span class="comment"># 当前长度更新为窗口长度</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; max_len: <span class="comment"># 看是否需要更新最大长度值</span></span><br><span class="line">                max_len = cur_len</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_len <span class="comment"># 返回最大子串长度</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>2.两数相加</title>
    <link href="https://liuyang0001.github.io/2020/01/03/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>https://liuyang0001.github.io/2020/01/03/2-两数相加/</id>
    <published>2020-01-03T06:04:18.000Z</published>
    <updated>2020-01-03T06:27:19.252Z</updated>
    
    <content type="html"><![CDATA[<p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</code></p><p><code>输出：7 -&gt; 0 -&gt; 8</code></p><p><code>原因：342 + 465 = 807</code></p><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>将链表转换成字符串，方便进行逆置操作；最后再讲字符串转换成链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ln2str</span><span class="params">(ln: ListNode)</span>:</span><span class="comment">#链表转换为字符串</span></span><br><span class="line">            <span class="keyword">if</span> ln.next == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> str(ln.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> str(ln.val) + str(ln2str(ln.next))</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">str2ln</span><span class="params">(str_res: str)</span>:</span><span class="comment">#字符串转换成链表</span></span><br><span class="line">            <span class="keyword">if</span> len(str_res)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> ListNode(int(str_res))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ln_temp = ListNode(int(str_res[<span class="number">0</span>]))</span><br><span class="line">                ln_temp.next = str2ln(str_res[<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">return</span> ln_temp</span><br><span class="line"></span><br><span class="line">        str1 = ln2str(l1)[::<span class="number">-1</span>] <span class="comment">#将链表1转换为字符串并逆置</span></span><br><span class="line">        str2 = ln2str(l2)[::<span class="number">-1</span>] <span class="comment">#将链表2转换为字符串并逆置</span></span><br><span class="line">        str_res = str(int(str1)+int(str2))[::<span class="number">-1</span>] <span class="comment">#相加后转换为字符串，逆置</span></span><br><span class="line">        <span class="keyword">return</span> str2ln(str_res)  <span class="comment">#返回转换成的链表</span></span><br></pre></td></tr></table></figure><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>把两个数按位相加，并存到一个新的链表中，使用carry保存是否需要进位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummyHead = ListNode(<span class="number">0</span>) <span class="comment"># 建立一个头结点</span></span><br><span class="line">        curr, carry = dummyHead, <span class="number">0</span> <span class="comment">#curr表当前结点；carry表进位</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2: <span class="comment"># 不全为空</span></span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l1: <span class="comment"># l1非空</span></span><br><span class="line">                sum += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2: <span class="comment"># l2非空</span></span><br><span class="line">                sum += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            sum += carry</span><br><span class="line">            carry = sum // <span class="number">10</span></span><br><span class="line">            curr.next = ListNode(sum % <span class="number">10</span>)</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">if</span> carry &gt; <span class="number">0</span>: <span class="comment"># 需要进位，使得链表加长</span></span><br><span class="line">            curr.next = ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next; <span class="comment">#返回除头结点之后链表</span></span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
