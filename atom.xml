<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Liu&#39;s Tech Blog</title>
  
  <subtitle>Python技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuyang0001.github.io/"/>
  <updated>2020-02-25T15:20:34.325Z</updated>
  <id>https://liuyang0001.github.io/</id>
  
  <author>
    <name>Liu Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>60-第k个排列</title>
    <link href="https://liuyang0001.github.io/2020/02/25/60-%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>https://liuyang0001.github.io/2020/02/25/60-第k个排列/</id>
    <published>2020-02-25T14:48:22.000Z</published>
    <updated>2020-02-25T15:20:34.325Z</updated>
    
    <content type="html"><![CDATA[<p>给出集合 <code>[1,2,3,…,*n*]</code>，其所有元素共有 <em>n</em>! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，给定 <em>n</em> 和 <em>k</em>，返回第 <em>k</em> 个排列。</p><a id="more"></a><blockquote><p>当 n = 3 时, 所有排列如下：</p><ol><li><code>&quot;123&quot;</code></li><li><code>&quot;132&quot;</code></li><li><code>&quot;213&quot;</code></li><li><code>&quot;231&quot;</code></li><li><code>&quot;312&quot;</code></li><li>`”321”</li></ol></blockquote><p><strong>说明：</strong></p><ul><li>给定 <em>n</em> 的范围是 [1, 9]。</li><li>给定 <em>k</em> 的范围是[1,  <em>n</em>!]。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 3, k = 3</span><br><span class="line">输出: &quot;213&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 4, k = 9</span><br><span class="line">输出: &quot;2314&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：回溯算法+剪枝</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 阶乘表</span></span><br><span class="line">        fac = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>]</span><br><span class="line">        nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 回溯函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backTrack</span><span class="params">(nums,tmp, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                <span class="keyword">return</span> tmp</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> fac[len(nums)<span class="number">-1</span>] &lt; k:</span><br><span class="line">                    k -= fac[len(nums)<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">return</span> backTrack(nums[:i]+nums[i+<span class="number">1</span>:], tmp+str(nums[i]), k)</span><br><span class="line">        <span class="keyword">return</span> backTrack(nums,<span class="string">""</span>, k)</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：</center></strong><a href="https://leetcode-cn.com/problems/permutation-sequence/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/permutation-sequence/solution/" target="_blank" rel="noopener">Solution</a><strong></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出集合 &lt;code&gt;[1,2,3,…,*n*]&lt;/code&gt;，其所有元素共有 &lt;em&gt;n&lt;/em&gt;! 种排列。&lt;/p&gt;
&lt;p&gt;按大小顺序列出所有排列情况，并一一标记，给定 &lt;em&gt;n&lt;/em&gt; 和 &lt;em&gt;k&lt;/em&gt;，返回第 &lt;em&gt;k&lt;/em&gt; 个排列。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>59-螺旋矩阵II</title>
    <link href="https://liuyang0001.github.io/2020/02/25/59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
    <id>https://liuyang0001.github.io/2020/02/25/59-螺旋矩阵II/</id>
    <published>2020-02-25T14:40:41.000Z</published>
    <updated>2020-02-25T14:47:48.579Z</updated>
    
    <content type="html"><![CDATA[<p><strong>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em>2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</strong></p><p><strong><a id="more"></a></strong></p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a><strong>解法</strong></h2><blockquote><p><strong>核心思想：设立上下左右四个边界即可，先开辟等大的空数组，再依次填入数字</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 设定四个边界值，并初始化要求大的数组，初始为0</span></span><br><span class="line">        l, r, t, b = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        mat = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        num, tar = <span class="number">1</span>, n * n</span><br><span class="line">        <span class="keyword">while</span> num &lt;= tar:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r + <span class="number">1</span>):  <span class="comment"># left to right</span></span><br><span class="line">                mat[t][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(t, b + <span class="number">1</span>):  <span class="comment"># top to bottom</span></span><br><span class="line">                mat[i][r] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(r, l - <span class="number">1</span>, <span class="number">-1</span>):  <span class="comment"># right to left</span></span><br><span class="line">                mat[b][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, t - <span class="number">1</span>, <span class="number">-1</span>):  <span class="comment"># bottom to top</span></span><br><span class="line">                mat[i][l] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/spiral-matrix-ii/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;给定一个正整数 &lt;em&gt;n&lt;/em&gt;，生成一个包含 1 到 &lt;em&gt;n&lt;/em&gt;2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>58-最后一个单词的长度</title>
    <link href="https://liuyang0001.github.io/2020/02/25/58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <id>https://liuyang0001.github.io/2020/02/25/58-最后一个单词的长度/</id>
    <published>2020-02-25T14:11:42.000Z</published>
    <updated>2020-02-25T14:20:48.105Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串 <code>s</code>，返回其最后一个单词的长度。</p><p>如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p><p>如果不存在最后一个单词，请返回 0 。</p><a id="more"></a><p><strong>说明：</strong>一个单词是指仅由字母组成、不包含任何空格的 <strong>最大子字符串</strong>。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello World&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：去除首尾空格后，利用空格进行切片，返回最后一个元素的长度即可。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        res = s.strip().split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">return</span> len(res[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/length-of-last-word/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/length-of-last-word/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个仅包含大小写字母和空格 &lt;code&gt;&amp;#39; &amp;#39;&lt;/code&gt; 的字符串 &lt;code&gt;s&lt;/code&gt;，返回其最后一个单词的长度。&lt;/p&gt;
&lt;p&gt;如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。&lt;/p&gt;
&lt;p&gt;如果不存在最后一个单词，请返回 0 。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>57-插入区间</title>
    <link href="https://liuyang0001.github.io/2020/02/16/57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>https://liuyang0001.github.io/2020/02/16/57-插入区间/</id>
    <published>2020-02-16T11:07:42.000Z</published>
    <updated>2020-02-25T14:11:55.281Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">输出: [[1,5],[6,9]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">输出: [[1,2],[3,10],[12,16]]</span><br><span class="line">解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：先添加到原数组中，按左端点排序后，判断后一个的起始点是否包含在前一个区间中。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        intervals.append(newInterval)</span><br><span class="line">        n = len(intervals)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> intervals</span><br><span class="line">        intervals.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 后一个区间中包含在前一个区间内的元素</span></span><br><span class="line">            <span class="keyword">if</span> intervals[i + <span class="number">1</span>][<span class="number">0</span>] <span class="keyword">in</span> range(intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>] + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 新的区间范围</span></span><br><span class="line">                l1, l2 = intervals[i][<span class="number">0</span>], max(</span><br><span class="line">                    intervals[i][<span class="number">1</span>], intervals[i+<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">                intervals[i+<span class="number">1</span>] = [l1, l2]</span><br><span class="line">                intervals[i] = <span class="string">"*"</span></span><br><span class="line">        res = [i <span class="keyword">for</span> i <span class="keyword">in</span> intervals <span class="keyword">if</span> i != <span class="string">"*"</span> ]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/insert-interval/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/insert-interval/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个&lt;em&gt;无重叠的 ，&lt;/em&gt;按照区间起始端点排序的区间列表。&lt;/p&gt;
&lt;p&gt;在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>56-合并区间</title>
    <link href="https://liuyang0001.github.io/2020/02/16/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>https://liuyang0001.github.io/2020/02/16/56-合并区间/</id>
    <published>2020-02-16T11:07:26.000Z</published>
    <updated>2020-02-16T11:19:38.814Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：按左端点排序后，判断后一个的起始点是否包含在前一个区间中</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n = len(intervals)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> intervals</span><br><span class="line">        res = []</span><br><span class="line">        intervals.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 后一个区间中包含在前一个区间内的元素</span></span><br><span class="line">            <span class="keyword">if</span> intervals[i + <span class="number">1</span>][<span class="number">0</span>] <span class="keyword">in</span> range(intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>] + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 新的区间范围</span></span><br><span class="line">                l1, l2 = intervals[i][<span class="number">0</span>], max(intervals[i][<span class="number">1</span>], intervals[i+<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">                intervals[i+<span class="number">1</span>] = [l1, l2]</span><br><span class="line">                intervals[i] = <span class="string">"*"</span></span><br><span class="line">        res = [ i <span class="keyword">for</span> i <span class="keyword">in</span> intervals <span class="keyword">if</span> i != <span class="string">"*"</span> ]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/merge-intervals/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/merge-intervals/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>55-跳跃游戏</title>
    <link href="https://liuyang0001.github.io/2020/02/16/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>https://liuyang0001.github.io/2020/02/16/55-跳跃游戏/</id>
    <published>2020-02-16T11:01:22.000Z</published>
    <updated>2020-02-16T11:06:53.197Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：贪心算法。从头开始遍历，不断更新当前位置能达到的最大位置，最大索引大于数组长度则可以到达。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        max_i = <span class="number">0</span>  <span class="comment"># 初始化当前能到达最远的位置</span></span><br><span class="line">        <span class="comment"># i为当前位置，jump是当前位置的跳数</span></span><br><span class="line">        <span class="keyword">for</span> i, jump <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="comment"># 如果当前位置能到达，并且当前位置+跳数&gt;最远位置</span></span><br><span class="line">            <span class="keyword">if</span> max_i &gt;= i <span class="keyword">and</span> i+jump &gt; max_i:</span><br><span class="line">                max_i = i+jump  <span class="comment"># 更新最远能到达位置</span></span><br><span class="line">        <span class="keyword">return</span> max_i &gt;= i</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/jump-game/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/jump-game/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="贪心算法" scheme="https://liuyang0001.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>54-螺旋矩阵</title>
    <link href="https://liuyang0001.github.io/2020/02/16/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>https://liuyang0001.github.io/2020/02/16/54-螺旋矩阵/</id>
    <published>2020-02-16T10:40:15.000Z</published>
    <updated>2020-02-16T11:00:27.151Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 <em>m</em> x <em>n</em> 个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：输出一次-&gt;删掉-&gt;旋转一次</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res += matrix.pop(<span class="number">0</span>)</span><br><span class="line">            matrix = list(map(list, zip(*matrix)))[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/spiral-matrix/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/spiral-matrix/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 个元素的矩阵（&lt;em&gt;m&lt;/em&gt; 行, &lt;em&gt;n&lt;/em&gt; 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>53-最大子序和</title>
    <link href="https://liuyang0001.github.io/2020/02/15/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>https://liuyang0001.github.io/2020/02/15/53-最大子序和/</id>
    <published>2020-02-15T12:52:52.000Z</published>
    <updated>2020-02-15T14:01:49.789Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><a id="more"></a><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：使用动态规划的思想，直接在原数组上修改</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        max_sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 保存到当前位置可能的最大子序和</span></span><br><span class="line">                nums[i] += nums[i - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 更新max值</span></span><br><span class="line">            max_sum = max(nums[i], max_sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/maximum-subarray/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/maximum-subarray/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="https://liuyang0001.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="动态规划" scheme="https://liuyang0001.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>50-pow-x-n</title>
    <link href="https://liuyang0001.github.io/2020/02/15/50-pow-x-n/"/>
    <id>https://liuyang0001.github.io/2020/02/15/50-pow-x-n/</id>
    <published>2020-02-15T12:16:36.000Z</published>
    <updated>2020-02-15T14:02:31.249Z</updated>
    
    <content type="html"><![CDATA[<p>实现 <code>pow(x, n)</code>，即计算 x 的 n 次幂函数。</p><a id="more"></a><p><strong>说明:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：转换成二进制计算法</strong></p></blockquote><p><img src="https://pic.leetcode-cn.com/ab780b00a05f762c87ae4c68e74ef8d3a8b961a98762c02b61585d8f8c61747c-image.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        flag = <span class="keyword">True</span> <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">        res, n = <span class="number">1</span>, abs(n)</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="comment"># 每次取得最后一位</span></span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">0x01</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="number">1</span>/res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h2><p><strong><center><a href="https://leetcode-cn.com/problems/powx-n/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/powx-n/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 &lt;code&gt;pow(x, n)&lt;/code&gt;，即计算 x 的 n 次幂函数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分查找" scheme="https://liuyang0001.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>49-字母异位词分组</title>
    <link href="https://liuyang0001.github.io/2020/02/14/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <id>https://liuyang0001.github.io/2020/02/14/49-字母异位词分组/</id>
    <published>2020-02-14T08:34:37.000Z</published>
    <updated>2020-02-14T08:39:46.018Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：维护一个ans的映射表，key为字母的拆散后排序形成的元祖，value为字符串列表，默认为空列表。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># value默认值为空列表</span></span><br><span class="line">        ans = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            ans[tuple(sorted(s))].append(s)</span><br><span class="line">            print(ans)</span><br><span class="line">        <span class="keyword">return</span> ans.values()</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/group-anagrams" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希表" scheme="https://liuyang0001.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>48-旋转图像</title>
    <link href="https://liuyang0001.github.io/2020/02/12/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://liuyang0001.github.io/2020/02/12/48-旋转图像/</id>
    <published>2020-02-12T14:48:49.000Z</published>
    <updated>2020-02-14T07:53:01.069Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。</p><a id="more"></a><p><strong>说明：</strong></p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><blockquote><p><strong>核心思想：先转置矩阵，再将每行逆置。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 转置矩阵</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 翻转每行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            matrix[i].reverse()</span><br></pre></td></tr></table></figure><p>该思路还可以<strong>一行代码</strong>解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        matrix[:] = map(list,zip(*matrix[::<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p>核心思想：从外层到内层，每个元素旋转90度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anext_ything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 求转90度后下一个坐标的位置</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">next_xy</span><span class="params">(x, y, s)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> y, s - <span class="number">1</span> - x</span><br><span class="line">            </span><br><span class="line">        n = len(matrix)</span><br><span class="line">        <span class="comment"># 行数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            l = n - i * <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 列数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(l<span class="number">-1</span>):</span><br><span class="line">                x, y = <span class="number">0</span>, j</span><br><span class="line">                tem = matrix[x + i][y + i]</span><br><span class="line">                <span class="comment"># 四条边上各有一个点</span></span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                    next_x, next_y = next_xy(x, y, l)</span><br><span class="line">                    tem_new = matrix[next_x+i][next_y+i]</span><br><span class="line">                    matrix[next_x+i][next_y+i] = tem</span><br><span class="line">                    x, y, tem = next_x, next_y, tem_new</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/rotate-image" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="叔祖" scheme="https://liuyang0001.github.io/tags/%E5%8F%94%E7%A5%96/"/>
    
  </entry>
  
  <entry>
    <title>47-全排列II</title>
    <link href="https://liuyang0001.github.io/2020/02/07/47-%E5%85%A8%E6%8E%92%E5%88%97II/"/>
    <id>https://liuyang0001.github.io/2020/02/07/47-全排列II/</id>
    <published>2020-02-07T15:22:13.000Z</published>
    <updated>2020-02-07T15:24:47.176Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：采用回溯算法。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()  <span class="comment"># 排序</span></span><br><span class="line">        <span class="comment"># 设置访问数组</span></span><br><span class="line">        check = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        res, tem = [], []</span><br><span class="line">        <span class="comment"># 调用回溯函数</span></span><br><span class="line">        self.backtrack(nums, tem, res, check)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回溯函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(self, nums: List[int], tem: List[int], res: List[int], check)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(tem) == len(nums):</span><br><span class="line">            res.append(tem[:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> check[i] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 剪枝</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> check[i - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                check[i] = <span class="number">1</span></span><br><span class="line">                tem.append(nums[i])</span><br><span class="line">                self.backtrack(nums, tem, res, check)</span><br><span class="line">                check[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> tem == []:  <span class="comment"># 无法pop的情况</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        tem.pop()</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/permutations-ii" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个可包含重复数字的序列，返回所有不重复的全排列。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="回溯算法l" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95l/"/>
    
  </entry>
  
  <entry>
    <title>46-全排列</title>
    <link href="https://liuyang0001.github.io/2020/02/07/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>https://liuyang0001.github.io/2020/02/07/46-全排列/</id>
    <published>2020-02-07T13:53:21.000Z</published>
    <updated>2020-02-07T15:25:31.208Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：采用回溯算法。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        <span class="comment"># 设置访问标记</span></span><br><span class="line">        check = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len_nums)]</span><br><span class="line">        res, tem = [], []</span><br><span class="line">        <span class="comment"># 调用回溯函数</span></span><br><span class="line">        self.backtrack(nums, tem, res, check)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回溯函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(self, nums: List[int], tem: List[int], res: List[int], check)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(tem) == len(nums):</span><br><span class="line">            res.append(tem[:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> check[i] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                check[i] = <span class="number">1</span></span><br><span class="line">                tem.append(nums[i])</span><br><span class="line">                self.backtrack(nums, tem, res,check)</span><br><span class="line">                check[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> tem == []:  <span class="comment"># 无法pop的情况</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        tem.pop()</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/permutations" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个没有重复数字的序列，返回其所有可能的全排列。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>43-字符串相乘</title>
    <link href="https://liuyang0001.github.io/2020/02/06/43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <id>https://liuyang0001.github.io/2020/02/06/43-字符串相乘/</id>
    <published>2020-02-06T15:05:30.000Z</published>
    <updated>2020-02-06T15:18:24.145Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li><p>num1 和 num2 的长度小于110。</p></li><li><p>num1 和 num2 只包含数字 0-9。</p></li><li><p>num1 和 num2 均不以零开头，除非是数字 0 本身。</p></li><li><p>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</p></li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：用一个list来保存每一位（+进位后的），然后再转成字符串即可。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> num1 == <span class="string">"0"</span> <span class="keyword">or</span> num2 == <span class="string">"0"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">        num1, num2 = num1[::<span class="number">-1</span>], num2[::<span class="number">-1</span>] <span class="comment"># 反转方便遍历相乘</span></span><br><span class="line">        lenNum = len(num1) + len(num2)  <span class="comment"># 保存最终最大的数字</span></span><br><span class="line">        returnNum = [<span class="number">0</span> <span class="keyword">for</span> c <span class="keyword">in</span> range(lenNum)]  <span class="comment"># 用list先存储</span></span><br><span class="line">        <span class="keyword">for</span> index2 <span class="keyword">in</span> range(len(num2)):</span><br><span class="line">            multiplier2 = int(num2[index2])  <span class="comment"># 就直接按照顺序放，最后再反过来！</span></span><br><span class="line">            <span class="keyword">for</span> index1 <span class="keyword">in</span> range(len(num1)):</span><br><span class="line">                multiplier1 = int(num1[index1])</span><br><span class="line">                temp = multiplier2 * multiplier1 + returnNum[index1 + index2]</span><br><span class="line">                <span class="keyword">if</span> temp &gt;= <span class="number">10</span>:  <span class="comment"># 是否涉及进位问题</span></span><br><span class="line">                    returnNum[index1 + index2] = temp % <span class="number">10</span></span><br><span class="line">                    returnNum[index1 + index2 + <span class="number">1</span>] += int(temp / <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    returnNum[index1 + index2] = temp</span><br><span class="line">        returnNum = returnNum[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> returnNum <span class="keyword">and</span> returnNum[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">del</span> returnNum[<span class="number">0</span>]  <span class="comment"># 去除无效的0</span></span><br><span class="line">        returnNum = [str(c) <span class="keyword">for</span> c <span class="keyword">in</span> returnNum]  <span class="comment"># 将列表中的每一个元素转成字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(returnNum)</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/multiply-strings" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数学" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>42-接雨水</title>
    <link href="https://liuyang0001.github.io/2020/02/05/42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://liuyang0001.github.io/2020/02/05/42-接雨水/</id>
    <published>2020-02-05T14:08:49.000Z</published>
    <updated>2020-02-05T14:17:27.122Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><a id="more"></a><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt=""></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>核心思路：使用双指针从两侧遍历,与当前的最大左右值相比，判断当前格子装了多少水。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: [int])</span> -&gt; int:</span></span><br><span class="line">        size = len(height)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">3</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, size - <span class="number">1</span></span><br><span class="line">        left_max, right_max = height[left], height[right]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt;= height[right]:</span><br><span class="line">                <span class="keyword">if</span> height[left] &gt; left_max:</span><br><span class="line">                    left_max = height[left]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += left_max - height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> height[right] &gt; right_max:</span><br><span class="line">                    right_max = height[right]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += right_max - height[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>41-缺失的第一个正数</title>
    <link href="https://liuyang0001.github.io/2020/02/04/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <id>https://liuyang0001.github.io/2020/02/04/41-缺失的第一个正数/</id>
    <published>2020-02-04T11:31:30.000Z</published>
    <updated>2020-02-04T14:21:02.501Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><a id="more"></a><p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：通过桶排序的思想，使得每个数字和其索引相对应</strong>。</p><p><strong>负数和大于数组长度的数跳过</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 3 应该放在索引为 2 的地方</span></span><br><span class="line">    <span class="comment"># 4 应该放在索引为 3 的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="comment"># 先判断这个数字是不是索引，然后判断这个数字是不是放在了正确的地方</span></span><br><span class="line">            <span class="comment"># i != nums[i]-1  这里外层套nums是防止[1,1]出现死循环</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span> &lt;= nums[i] &lt;= size <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]:</span><br><span class="line">                nums[nums[i]<span class="number">-1</span>], nums[i] = nums[i],nums[nums[i]<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> != nums[i]:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> size + <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/first-missing-positive" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个未排序的整数数组，找出其中没有出现的最小的正整数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>40-组合总和II</title>
    <link href="https://liuyang0001.github.io/2020/02/03/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/"/>
    <id>https://liuyang0001.github.io/2020/02/03/40-组合总和II/</id>
    <published>2020-02-03T14:04:04.000Z</published>
    <updated>2020-02-03T14:46:55.143Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><hr></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：回溯算法</strong></p></blockquote><blockquote><p><strong>关键点：去重，如果上一个数和当前数字相同，则跳过</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        begin, end = <span class="number">0</span>, len(candidates)</span><br><span class="line">        <span class="keyword">if</span> end == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, path = [], []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.helper(candidates, begin, end, target, path, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, candidates: List[int], begin: int, end: int, delta: int, path: List[int], res: List[int])</span>:</span></span><br><span class="line">        <span class="keyword">if</span> delta == <span class="number">0</span>:</span><br><span class="line">            res.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(begin, end):</span><br><span class="line">            delta_new = delta-candidates[index]</span><br><span class="line">            <span class="keyword">if</span> delta_new &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> index != begin <span class="keyword">and</span> candidates[index<span class="number">-1</span>] == candidates[index]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(candidates[index])</span><br><span class="line">            <span class="comment"># 与上题的不同在于每个元素不能重复使用</span></span><br><span class="line">            <span class="comment"># 所以下一个区间为[index+1,end)</span></span><br><span class="line">            self.helper(candidates, index+<span class="number">1</span>, end, delta_new, path, res)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;
&lt;p&gt;candidates 中的每个数字在每个组合中只能使用一次。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>39-组合总和</title>
    <link href="https://liuyang0001.github.io/2020/02/03/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>https://liuyang0001.github.io/2020/02/03/39-组合总和/</id>
    <published>2020-02-03T14:03:46.000Z</published>
    <updated>2020-02-03T14:13:00.401Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><a id="more"></a><p><strong>说明：</strong></p><ul><li>所有数字（包括 target）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p>核心思想：采用回溯算法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        begin, end = <span class="number">0</span>, len(candidates)</span><br><span class="line">        <span class="keyword">if</span> end == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 剪枝的前提是数组元素排序</span></span><br><span class="line">        <span class="comment"># 深度深的边不能比深度浅的边还小</span></span><br><span class="line">        <span class="comment"># 要排序的理由：1、前面用过的数后面不能再用；2、下一层边上的数不能小于上一层边上的数。</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="comment"># 在遍历的过程中记录路径，一般而言它是一个栈</span></span><br><span class="line">        path, res = [], []</span><br><span class="line">        <span class="comment"># 注意要传入 end ，在 range 中， end 取不到</span></span><br><span class="line">        self.helper(candidates, <span class="number">0</span>, end, path, res, target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, candidates, begin, end, path, res, target)</span>:</span></span><br><span class="line">        <span class="comment"># 先写递归终止的情况</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># Python 中可变对象是引用传递，因此需要将当前 path 里的值拷贝出来</span></span><br><span class="line">            <span class="comment"># 或者使用 path.copy()</span></span><br><span class="line">            res.append(path[:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(begin, end):</span><br><span class="line">            delta = target - candidates[index]</span><br><span class="line">            <span class="comment"># “剪枝”操作，不必递归到下一层，并且后面的分支也不必执行</span></span><br><span class="line">            <span class="keyword">if</span> delta &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            path.append(candidates[index])</span><br><span class="line">            <span class="comment"># 因为下一层不能比上一层还小，起始索引还从 index 开始</span></span><br><span class="line">            self.helper(candidates, index, end, path, res, delta)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/combination-sum" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&lt;/p&gt;
&lt;p&gt;candidates 中的数字可以无限制重复被选取。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>38-外观数列</title>
    <link href="https://liuyang0001.github.io/2020/02/02/38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/"/>
    <id>https://liuyang0001.github.io/2020/02/02/38-外观数列/</id>
    <published>2020-02-02T07:50:50.000Z</published>
    <updated>2020-02-02T08:17:01.746Z</updated>
    
    <content type="html"><![CDATA[<p>外观数列是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">前五项如下：</span><br><span class="line"></span><br><span class="line">   1.     1</span><br><span class="line">   2.     11</span><br><span class="line">   3.     21</span><br><span class="line">   4.     1211</span><br><span class="line">   5.     111221</span><br><span class="line">   </span><br><span class="line">1  被读作  (&quot;一个一&quot;) , 即 11。</span><br><span class="line">11 被读作 (&quot;两个一&quot;）, 即 21。</span><br><span class="line">21 被读作（&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。</span><br></pre></td></tr></table></figure><p>   <strong>注意：整数序列中的每一项将表示为一个字符串。</strong></p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 1</span><br><span class="line">输出: &quot;1&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 4</span><br><span class="line">输出: &quot;1211&quot;</span><br><span class="line">解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：后一个序列是由前一个序列确定的，故采用递归法。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        <span class="comment"># 加上*，可以防止数组越界,不用考虑边界问题</span></span><br><span class="line">        num = self.countAndSay(n<span class="number">-1</span>)+<span class="string">"*"</span></span><br><span class="line">        nums_ls = list(num)</span><br><span class="line">        <span class="comment"># print(nums_ls)</span></span><br><span class="line">        count, res = <span class="number">1</span>, <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums_ls) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 计数重复的数值</span></span><br><span class="line">            <span class="keyword">if</span> nums_ls[i] == nums_ls[i+<span class="number">1</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums_ls[i] != nums_ls[i+<span class="number">1</span>]:</span><br><span class="line">                res += str(count) + nums_ls[i]</span><br><span class="line">                <span class="comment"># print(res)</span></span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/count-and-say" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;外观数列是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>36-有效的数独</title>
    <link href="https://liuyang0001.github.io/2020/02/02/36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <id>https://liuyang0001.github.io/2020/02/02/36-有效的数独/</id>
    <published>2020-02-02T06:29:23.000Z</published>
    <updated>2020-02-02T06:42:48.469Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><a id="more"></a><ul><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li></ul><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p><strong>说明:</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>给定数独序列只包含数字 1-9 和字符 ‘.’ 。</li><li>给定数独永远是 9x9 形式的。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: false</span><br><span class="line">解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。</span><br><span class="line">     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：使用三个哈希表进行计数，三个表中所有的value均不大于1时，返回True。</strong></p></blockquote><blockquote><p><strong>如何计算Box的索引值?</strong></p></blockquote><p><img src="https://pic.leetcode-cn.com/2b141392e2a1811d0e8dfdf6279b1352e59fad0b3961908c6ff9412b6a7e7ccf-image.png" alt=""></p><p>按照上图将9x9的数独分成0-8共九个3x3：则索引值为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box_index = row//<span class="number">3</span>*<span class="number">3</span>+column//<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        rows_ls = [&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        columns_ls = [&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        boxes_ls = [&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                num = board[row][column]</span><br><span class="line">                <span class="keyword">if</span> num != <span class="string">"."</span>:</span><br><span class="line">                    num = int(num)</span><br><span class="line">                    box_index = row//<span class="number">3</span>*<span class="number">3</span>+column//<span class="number">3</span></span><br><span class="line">                    rows_ls[row][num] = rows_ls[row].get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    columns_ls[column][num] = columns_ls[column].get(</span><br><span class="line">                        num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    boxes_ls[box_index][num] = boxes_ls[box_index].get(</span><br><span class="line">                        num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># check valid</span></span><br><span class="line">                    <span class="keyword">if</span> rows_ls[row][num] &gt; <span class="number">1</span> <span class="keyword">or</span> columns_ls[column][num] &gt; <span class="number">1</span> <span class="keyword">or</span> boxes_ls[box_index][num] &gt; <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://leetcode-cn.com/problems/valid-sudoku" target="_blank" rel="noopener">LeetCode中该题地址，Click here!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="哈希表" scheme="https://liuyang0001.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
