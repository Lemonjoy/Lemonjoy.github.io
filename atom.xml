<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Liu&#39;s Tech Blog</title>
  
  <subtitle>Python技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuyang0001.github.io/"/>
  <updated>2020-07-24T10:25:34.017Z</updated>
  <id>https://liuyang0001.github.io/</id>
  
  <author>
    <name>Liu Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wsl配置git环境</title>
    <link href="https://liuyang0001.github.io/2020/07/24/wsl%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83/"/>
    <id>https://liuyang0001.github.io/2020/07/24/wsl配置git环境/</id>
    <published>2020-07-24T08:12:02.000Z</published>
    <updated>2020-07-24T10:25:34.017Z</updated>
    
    <content type="html"><![CDATA[<p>这篇记录下在WSL(Ubuntu-20.04)下如何配置git环境。</p><a id="more"></a><hr><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>直接使用apt-get即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>随后使用<code>whereis git</code> 或者<code>git --version</code>检查是否安装完成。</p><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200724161810.png" alt=""></p><hr><h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><ul><li>配置你的用户名</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name xxx</span><br></pre></td></tr></table></figure><ul><li>配置你的邮箱地址</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email  xxx@xxx.com</span><br></pre></td></tr></table></figure><ul><li>查看是否配置成功</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200724162803.png" alt=""></p><hr><h2 id="配置SSH秘钥"><a href="#配置SSH秘钥" class="headerlink" title="配置SSH秘钥"></a>配置SSH秘钥</h2><ul><li>生成ssh秘钥，把xxx换成你上面填的邮箱</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa  -C <span class="string">"xxxx@xxx.com"</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200724163252.png" alt=""></p><ul><li>找到我们生成秘钥并打开公钥</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200724163802.png" alt=""></p><ul><li>复制公钥的内容并且打开你的<a href="https://github.com/settings/profile" target="_blank" rel="noopener">github设置界面</a></li><li>找到SSHkey设置，点击右上角的New SSH key</li></ul><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200724164244.png" alt=""></p><ul><li>把刚复制的公钥内容添加进去。</li><li>回到我们的linux命令行，使用ssh命令检查是否配置成功</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200724164606.png" alt=""></p><hr><p><strong>到这里就配置完成了，Enjoy it.</strong></p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>很简单的步骤，万万没想到，我还是踩坑了。</p><p>总结起来一句话就是：<strong>ssh key配置好了也不代表能用https的方式免密码clone和push</strong>，其实已经配置好了，只是用了错误的clone方式。</p><p>顺便记录一下已经用https方式clone项目的解决办法：</p><ul><li>移除当前的源地址。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure><ul><li>添加ssh格式的源地址</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:用户名/Repo名称.git</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇记录下在WSL(Ubuntu-20.04)下如何配置git环境。&lt;/p&gt;
    
    </summary>
    
      <category term="WSL使用笔记" scheme="https://liuyang0001.github.io/categories/WSL%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://liuyang0001.github.io/tags/Linux/"/>
    
      <category term="WSL" scheme="https://liuyang0001.github.io/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>WSL2的升级与安装笔记</title>
    <link href="https://liuyang0001.github.io/2020/07/23/WSL2%E7%9A%84%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/"/>
    <id>https://liuyang0001.github.io/2020/07/23/WSL2的安装笔记/</id>
    <published>2020-07-23T14:04:39.000Z</published>
    <updated>2020-07-24T07:32:28.977Z</updated>
    
    <content type="html"><![CDATA[<p>这部分记录了如何安装wsl，以及如何升级到wsl2的心酸历程。</p><a id="more"></a><hr><h2 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h2><p><strong>安装wsl2对系统版本有硬性的要求：</strong></p><ul><li>运行 Windows 10（<a href="ms-settings:windowsupdate" target="_blank" rel="noopener">已更新到版本 2004</a> 的<strong>内部版本 19041</strong> 或更高版本）。</li><li>通过按 Windows 徽标键 + R，检查你的 Windows 版本，然后键入 <strong>winver</strong>，选择“确定”。  如果内部版本低于 19041，请<a href="ms-settings:windowsupdate" target="_blank" rel="noopener">更新到最新的 Windows 版本</a>。 </li></ul><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200723224746.png" alt=""></p><h2 id="升级windows"><a href="#升级windows" class="headerlink" title="升级windows"></a>升级windows</h2><blockquote><p>如果版本达到了要求，则跳过此步骤。</p></blockquote><ul><li><code>Win+S</code> 搜索<strong>预览体验计划</strong></li></ul><p>加入预览体验计划，获取更新版本。</p><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200723224245.png" alt=""></p><ul><li>进行windows更新</li></ul><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200723224525.png" alt=""></p><p>然后就是漫长的等待过程，无论是下载还是安装的过程都很漫长。</p><hr><h2 id="WSL的安装"><a href="#WSL的安装" class="headerlink" title="WSL的安装"></a>WSL的安装</h2><ul><li><p>使用<strong>管理员</strong>权限打开powershell</p></li><li><p>启用“适用于 Linux 的 Windows 子系统”可选功能</p></li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br></pre></td></tr></table></figure><blockquote><p>这时候wsl其实已经启用了，重启就可以了，但还要更新到wsl2，就在后面一起重启了。</p></blockquote><h2 id="升级到WSL2"><a href="#升级到WSL2" class="headerlink" title="升级到WSL2"></a>升级到WSL2</h2><ul><li>启用“虚拟机平台”可选组件</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><ul><li><strong>重启</strong>电脑。</li><li>重新<strong>管理员</strong>身份打开powershell，用下面的命令将wsl2设置为默认。</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200723225303.png" alt=""></p><p>出现上面这行就是好了，如果<strong>有问题请参考后文</strong>中遇到的问题及解决办法。</p><hr><h2 id="安装linux分发版"><a href="#安装linux分发版" class="headerlink" title="安装linux分发版"></a>安装linux分发版</h2><p>选择一个你喜欢的就可以了，任君挑选。</p><ul><li><p>打开 <a href="https://aka.ms/wslstore" target="_blank" rel="noopener">Microsoft Store</a>，并选择你偏好的 Linux 分发版。</p><p><img src="https://docs.microsoft.com/zh-cn/windows/wsl/media/store.png" alt="Microsoft Store 中的 Linux 分发版的视图"></p><p>单击以下链接会打开每个分发版的 Microsoft Store 页面：</p><ul><li><a href="https://www.microsoft.com/store/apps/9pjn388hp8c9" target="_blank" rel="noopener">Ubuntu 16.04 LTS</a></li><li><a href="https://www.microsoft.com/store/apps/9N9TNGVNDL3Q" target="_blank" rel="noopener">Ubuntu 18.04 LTS</a></li><li><a href="https://www.microsoft.com/store/apps/9n6svws3rx71" target="_blank" rel="noopener">Ubuntu 20.04 LTS</a></li><li><a href="https://www.microsoft.com/store/apps/9NJFZK00FGKV" target="_blank" rel="noopener">openSUSE Leap 15.1</a></li><li><a href="https://www.microsoft.com/store/apps/9MZ3D1TRP8T1" target="_blank" rel="noopener">SUSE Linux Enterprise Server 12 SP5</a></li><li><a href="https://www.microsoft.com/store/apps/9PN498VPMF3Z" target="_blank" rel="noopener">SUSE Linux Enterprise Server 15 SP1</a></li><li><a href="https://www.microsoft.com/store/apps/9PKR34TNCV07" target="_blank" rel="noopener">Kali Linux</a></li><li><a href="https://www.microsoft.com/store/apps/9MSVKQC78PK6" target="_blank" rel="noopener">Debian GNU/Linux</a></li><li><a href="https://www.microsoft.com/store/apps/9n6gdm4k2hnc" target="_blank" rel="noopener">Fedora Remix for WSL</a></li><li><a href="https://www.microsoft.com/store/apps/9NV1GV1PXZ6P" target="_blank" rel="noopener">Pengwin</a></li><li><a href="https://www.microsoft.com/store/apps/9N8LP0X93VCP" target="_blank" rel="noopener">Pengwin Enterprise</a></li><li><a href="https://www.microsoft.com/store/apps/9p804crf0395" target="_blank" rel="noopener">Alpine WSL</a></li></ul></li><li><p>在分发版的页面中，选择“获取”。</p></li></ul><p><img src="https://docs.microsoft.com/zh-cn/windows/wsl/media/ubuntustore.png" alt="Microsoft Store 中的 Linux 分发版"></p><p>安心等待片刻，就安装好了，这时你点击开始，就可以在最近安装看见你安装好的分发版了。</p><p>初次启动它会进行一个初始化的过程，需要等待一段时间。完成之后会让你设置账号和密码。</p><p><img src="https://docs.microsoft.com/zh-cn/windows/wsl/media/ubuntuinstall.png" alt="Windows 控制台中的 Ubuntu 解包"></p><hr><h2 id="排查安装问题"><a href="#排查安装问题" class="headerlink" title="排查安装问题"></a>排查安装问题</h2><p>下面是相关的错误和建议的修复措施。 有关其他常见错误及其解决方法，请参阅 <a href="https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting" target="_blank" rel="noopener">WSL 故障排除页</a>。</p><ul><li><strong>安装失败并出现错误 0x80070003</strong><ul><li>适用于 Linux 的 Windows 子系统只能在系统驱动器（通常是 <code>C:</code> 驱动器）中运行。 请确保分发版存储在系统驱动器上：</li><li>打开“设置”-&gt;“存储”-&gt;“更多存储设置： 更改新内容的保存位置” <img src="https://docs.microsoft.com/zh-cn/windows/wsl/media/appstorage.png" alt="用于在 C: 驱动器中安装应用的系统设置屏幕截图"></li></ul></li><li><strong>WslRegisterDistribution 失败并出现错误 0x8007019e</strong><ul><li>未启用“适用于 Linux 的 Windows 子系统”可选组件：</li><li>打开“控制面板” -&gt; “程序和功能” -&gt; “打开或关闭 Windows 功能”-&gt; 选中“适用于 Linux 的 Windows 子系统”，或使用本文开头所述的 PowerShell cmdlet。</li></ul></li><li><strong>安装失败，出现错误 0x80070003 或错误 0x80370102</strong><ul><li>请确保在计算机的 BIOS 内已启用虚拟化。 有关如何执行此操作的说明因计算机而异，并且很可能在 CPU 相关选项下。</li></ul></li><li><strong>尝试升级时出错：<code>Invalid command line option: wsl --set-version Ubuntu 2</code></strong><ul><li>请确保已启用适用于 Linux 的 Windows 子系统，并且你使用的是 Windows 内部版本 19041 或更高版本。 若要启用 WSL，请在 PowerShell 提示符下以具有管理员权限的身份运行此命令：<code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code>。 可在<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10" target="_blank" rel="noopener">此处</a>找到完整的 WSL 安装说明。</li></ul></li><li><strong>由于虚拟磁盘系统的某个限制，无法完成所请求的操作。虚拟硬盘文件必须是解压缩的且未加密的，并且不能是稀疏的。</strong><ul><li>请检查 <a href="https://github.com/microsoft/WSL/issues/4103" target="_blank" rel="noopener">WSL GitHub 主题 #4103</a>，其中跟踪了此问题以提供更新的信息。</li></ul></li><li><strong>无法将词语“wsl”识别为 cmdlet、函数、脚本文件或可运行程序的名称。</strong><ul><li>请确保<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10#enable-the-virtual-machine-platform-optional-component" target="_blank" rel="noopener">已安装“适用于 Linux 的 Windows 子系统”可选组件</a>。 此外，如果你使用的是 ARM64 设备，并从 PowerShell 运行此命令，则会收到此错误。 请改为从 <a href="https://docs.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-6" target="_blank" rel="noopener">PowerShell Core</a> 或从命令提示符运行 <code>wsl.exe</code>。</li></ul></li></ul><hr><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/faq" target="_blank" rel="noopener">常见问题</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-faq" target="_blank" rel="noopener">WSL 2 常见问题解答</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting" target="_blank" rel="noopener">疑难解答</a></p><hr><h2 id="记录所踩的坑"><a href="#记录所踩的坑" class="headerlink" title="记录所踩的坑"></a>记录所踩的坑</h2><blockquote><p>上面的问题和解决办法，是官方的手册给的，下面说记录下安装的心酸历程，如果上面没找到你的问题，可以看看我的经历是不是能给你点帮助：</p></blockquote><ol><li><p>首先是windows版本，我一直保持着最新的版本，想当然的以为版本足够，查了各种方法也装不上wsl2，后来在一个大佬的笔记里发现要打开预览版本更新。</p></li><li><p>之后就是安装WSL 2遇到了 <code>requires an update to its kernel component. For information please visit https://aka.ms/wsl2kernel</code>的问题，然后就下载了最新版本的内核。</p></li><li><p>然后又遇到内核无法安装的问题，这时我已经要炸了，冷静下来想起了解决之前问题时候尝试装过一次内核，随后找到应用卸载的界面卸载了之前装的内核，安装新内核成功。</p></li><li><p>之后也成功的切换到了wsl2，但是从应用商店下载的Ubuntu20,04第一次打开加载报错，不信邪的我切换回了wsl1，再打开Ubuntu成功运行，这时候我心态已经有点崩了，搞来搞去wsl2还是不能用。</p></li><li><p>我又在应用商店下载了Ubuntu18.04，切换回了wsl2重新安装，还是失败，看了下报错<code>0xc03a001a</code>，找到一个大佬的解答说是因为开了<strong>压缩内容以便节省磁盘空间</strong>的原因，首先确定你的一些或者所有的文件夹右上角是否都有两个相对的蓝色箭头，然后找到路径:<code>C:\Users\user name\AppData\Local\Packages\CanonicalGroupLimited.xxxx  (xxx为你所下载的对应Linux发行版)</code>这个文件夹，若它确实是右上角带有<strong>两个相对箭头</strong>，那么：</p></li></ol><blockquote><p>右键 -&gt; 属性 -&gt; 常规 -&gt; 高级 -&gt; 取消勾选 <code>压缩内容以便节省磁盘空间</code> 这一项 -&gt; 确定<br>再次启动所安装的 <code>Linux</code> 发行版应该就可正常使用。</p></blockquote><p>随后我以为终于可以解决了，然而并没有。还是报错，具体是什么忘记了，也没查到答案。最后问题还是自己解决的。我灵机一动，既然wsl1环境可以正常安装，那我是不是在1环境下安装，再转换到2环境下呢？最后问题完美解决。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsl --set-version Ubuntu-20.04  2</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200723233623.png" alt=""></p><p><strong>终于等到你，还好我没放弃！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这部分记录了如何安装wsl，以及如何升级到wsl2的心酸历程。&lt;/p&gt;
    
    </summary>
    
      <category term="WSL使用笔记" scheme="https://liuyang0001.github.io/categories/WSL%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://liuyang0001.github.io/tags/Linux/"/>
    
      <category term="WSL" scheme="https://liuyang0001.github.io/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>爬虫项目:Leetcode-Helper</title>
    <link href="https://liuyang0001.github.io/2020/06/20/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE-Leetcode-Helper/"/>
    <id>https://liuyang0001.github.io/2020/06/20/爬虫项目-Leetcode-Helper/</id>
    <published>2020-06-20T08:31:02.000Z</published>
    <updated>2020-06-29T13:51:08.224Z</updated>
    
    <content type="html"><![CDATA[<p>哪个程序员😁不想一键下载写过的代码，自动上传Github，并且还能生成一份好看的README呢？</p><p>有用的话点个⭐吧，谢谢你。<a href="https://github.com/Liuyang0001/Leetcode-Helper" target="_blank" rel="noopener">项目传送门 |🚪|</a></p><a id="more"></a><hr><p><strong>💕主要功能💕</strong></p><p>🍉 模拟登陆力扣中国站(leetcode-cn)</p><p>🍉 爬取每题提交的ac代码，保存至本地。</p><p>🍉 自动生成优美的README文件至本地。</p><p>🍉 支持自动更新至Github仓库。 </p><p>🍉 加入失败重试机制，减少延时，加快下载速度。</p><p>🍉 加入增量更新功能(根据最近的提交来更新已存在的题库)。【默认】 🆕</p><hr><p><strong>少啰嗦，先看东西 :   <a href="https://github.com/Liuyang0001/LeetCode_By_Python" target="_blank" rel="noopener">具体效果,点击这里 </a></strong> 😃 </p><hr><ul><li>生成的README效果图：</li></ul><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200613133201.png" alt=""></p><ul><li>生成的源码效果图：</li></ul><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200619174224.png" alt=""></p><hr><p><strong>💕使用说明💕</strong></p><ul><li><strong>clone 该项目到你的本地。</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Liuyang0001/Leetcode-Helper.git</span><br></pre></td></tr></table></figure><ul><li><strong>配置你的cofig.json文件。</strong></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"email"</span>: <span class="string">"xx账号xxxx"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"xxx密码xxx"</span>,</span><br><span class="line">    <span class="attr">"repo_path"</span>: <span class="string">"x:/xxx源码仓库的本地路径xxx/"</span>,</span><br><span class="line">    <span class="attr">"git_url"</span>: <span class="string">"https://github.com/xxxxx/xxx仓库名xx/tree/master/codes_auto/"</span>,</span><br><span class="line">    <span class="attr">"download_start_id"</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="attr">"download_end_id"</span>: <span class="number">1000000</span>,</span><br><span class="line">    <span class="attr">"refresh"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"get_recent_submissions_nums"</span>: <span class="number">40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>安装依赖库</strong></li></ul><p>依赖库为<code>retry</code> ，<code>pandas</code> ，<code>requests</code>，<code>gitpython</code>可自行安装，或者使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -r requirement.txt</span><br></pre></td></tr></table></figure><ul><li><strong>运行<code>main.py</code>文件</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><hr><blockquote><p>其他说明：</p><ol><li>第一次运行比较慢，主要是需要建立本地数据库，请耐心等待。</li><li><del>后续会增加增量更新，请持续关注。</del> 已加入，默认获取最近40次提交，可以在config修改。</li><li><del>如果发生异常，请尝试重新运行 。</del>   已加入失败重试机制。</li><li>为了运行速度，已生成代码不会覆盖，相同题的代码仅保留一份ac的。</li><li>如果大家有需求的话，可能还会写个GUI界面，会更直观一点。</li></ol></blockquote><hr><p>本人是一个准研一的小菜🐔，在家无事的练手项目，求轻喷。</p><p>Enjoy coding！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哪个程序员😁不想一键下载写过的代码，自动上传Github，并且还能生成一份好看的README呢？&lt;/p&gt;
&lt;p&gt;有用的话点个⭐吧，谢谢你。&lt;a href=&quot;https://github.com/Liuyang0001/Leetcode-Helper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目传送门 |🚪|&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫项目" scheme="https://liuyang0001.github.io/categories/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://liuyang0001.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="git" scheme="https://liuyang0001.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>同时存在unicode-escape和utf-8的解码方法</title>
    <link href="https://liuyang0001.github.io/2020/06/09/%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8unicode-escape%E5%92%8Cutf-8%E7%9A%84%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>https://liuyang0001.github.io/2020/06/09/同时存在unicode-escape和utf-8的解码方法/</id>
    <published>2020-06-09T10:53:12.000Z</published>
    <updated>2020-06-09T12:14:30.522Z</updated>
    
    <content type="html"><![CDATA[<p>在爬取lc提交代码的时候遇到的一个问题，在爬取到的源码中，符号是采用<code>unicode-escape</code>编码的，而其中的中文是采用<code>utf-8</code>编码的，正常解码无论怎样都会出现乱码，本文记录下解决办法。</p><a id="more"></a><p>[TOC]</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面是lc第一题爬取的源码，编码为”utf-8”，中文可以正确显示，但是换行符等符号并不能正确显示，因此需要转换。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">code = <span class="string">"class Solution:\u000A    def twoSum(self, nums: List[int], target: int) \u002D\u003E List[int]:\u000A        dic \u003D defaultdict(int) # 哈希字典\u000A        for i,num in enumerate(nums):\u000A            if num in dic: return [dic[num],i]\u000A            dic[target\u002Dnum]\u003Di"</span></span><br></pre></td></tr></table></figure><p>正常我们的解码是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code = code.encode(&quot;utf-8&quot;).decode(&quot;unicode-escape&quot;)</span><br></pre></td></tr></table></figure><p>这样上面的换行符等就可以正确显示为<code>\n</code>等正确的编码，但是原本上面的中文就是<code>utf-8</code>了，解码为<code>unicode-escape</code>就会出现乱码，输出文件就会像下面的这样。</p><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200609195642.png" alt=""></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>其实很简单，就是<strong>局部解码</strong>就可以了：</p><ul><li><p>首先利用<strong>正则</strong>表达式找到所有采用<code>unicode-escape</code>编码的字符，</p></li><li><p>然后将其解码再替换原字符串</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">code = re.sub(<span class="string">r'(\\u[\s\S]&#123;4&#125;)'</span>,<span class="keyword">lambda</span> x:x.group(<span class="number">1</span>).encode(<span class="string">"utf-8"</span>).decode(<span class="string">"unicode-escape"</span>),code)</span><br></pre></td></tr></table></figure><p>再来查看一下我们写入的文件，就没有乱码的情况了。</p><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200609194737.png" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在爬取lc提交代码的时候遇到的一个问题，在爬取到的源码中，符号是采用&lt;code&gt;unicode-escape&lt;/code&gt;编码的，而其中的中文是采用&lt;code&gt;utf-8&lt;/code&gt;编码的，正常解码无论怎样都会出现乱码，本文记录下解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Spider Study Notes" scheme="https://liuyang0001.github.io/categories/Spider-Study-Notes/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://liuyang0001.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="编码" scheme="https://liuyang0001.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>2020中传计算机专硕考研经验贴</title>
    <link href="https://liuyang0001.github.io/2020/05/29/2020%E4%B8%AD%E4%BC%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E7%A1%95%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
    <id>https://liuyang0001.github.io/2020/05/29/2020中传计算机专硕考研经验贴/</id>
    <published>2020-05-29T12:18:00.000Z</published>
    <updated>2020-07-05T11:17:20.365Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅仅是我个人的经验贴，记录下考研总结和反思，如果能给你带来一点收获，那就太好了。</p><p>对了，纯主观，不接受反驳。 😃</p><a id="more"></a><hr><h1 id="劝退环节"><a href="#劝退环节" class="headerlink" title="劝退环节"></a>劝退环节</h1><p>如果你还没考虑好是不是要考中传，那下面这些点可能会直接把你劝退，如果很坚决的想考，那么这些也一定要知道。我只拿专硕举例，学硕我也没什么发言权。</p><ol><li><strong>优先一志愿问题</strong>：官网写的调剂和一志愿分别排名，优先一志愿。实际情况是今年扩招了，一志愿未满，<del>仍然一志愿按1:1.2左右的比例录取，然后招30个调剂。</del>【后面有很多一志愿<strong>补录</strong>成功，基本上都上岸了，个人猜测是有一部分调剂上岸，最后并没有来。】<strong>至于往年，没有收过调剂，今年比较特殊。按往年的情况来讲，对你影响不大。</strong></li><li><strong>复试时间问题</strong>：中传的复试时间很晚，<u>若一志愿未上，调剂基本上也不剩什么了</u>，今年情况特殊还有一些，往年更惨一点。</li><li><strong>校内调剂问题</strong>：没有校内调剂这个说法。</li><li><strong>压分问题</strong>：专业课没感觉有压分现象，政治，英语常规操作，不过大家都一样。</li><li><strong>专业课难度</strong>：在只考数据结构里难度中上，甚至考了手写图的代码题。多选题比较爱失分，但好好复习考个110应该问题不大。如果你做过北交大的专业课难度，你就知道我在说什么，北交的专业课真的简单，不过就一门专业课，可以多花点时间，所以还好。</li><li><strong>录取分数问题：</strong>今年<strong>最低分国家线录取</strong>，但这不具有代表性，今年情况太特殊了。</li></ol><hr><h1 id="初试部分"><a href="#初试部分" class="headerlink" title="初试部分"></a>初试部分</h1><p>如果你能接受中传上面“略显”苛刻的情况，那么就往下看吧，不然就可以退场了。</p><h2 id="英语一"><a href="#英语一" class="headerlink" title="英语一"></a>英语一</h2><p>英语这部分我没有什么发言权，毕竟只有过线的成绩。不过我的自我总结可以给你一些忠告：</p><ol><li>英语真题要趁早做，反复做，做到这张<u>卷子里的每个单词你都认识</u>就算合格了。</li><li>可以留一年或者两年de真题，留着模拟考试。</li><li>不用看恋恋有词，不用看恋恋有词，不用看恋恋有词，重要的事情说三遍，不是说不好，是太磨叽了，很浪费时间。</li><li>背单词的软件，我推荐墨墨背单词。（速来打钱!）</li><li>网课不用看太多，我推荐先把去年的<u>刘晓燕救命班</u>看一遍，你就知道你需要前期的储备是什么。阅读可以看唐迟的。</li><li>不要买模拟试题，用处不大，别浪费钱。</li></ol><h2 id="数学一"><a href="#数学一" class="headerlink" title="数学一"></a>数学一</h2><p>数学这部分其实核心就是多做题，多总结，无他，唯手熟尔。</p><ol><li>数学这部分还是推荐看视频的（可以倍速看，1.5x很爽），不过要一边看一遍记录，不然可能会很快睡着，其实看谁的视频取决于个人风格，张宇确实很有意思，不过我可能更想推荐<u>高昆仑</u>，讲课逻辑很清晰，也经常会给你一些小套路，让你觉得解题挺有意思的，强推。另外，各位也可以支持下我高数老师们的b站号<strong><a href="https://space.bilibili.com/504207128/" target="_blank" rel="noopener">梨米特爱讲课</a></strong>，免费分享各种考研数学的课程，干货很多，各位可以去看看。</li><li>我个人对回归教材这个观点不是很赞同的，我就喜欢看别人给我总结完的，看教材我是真的看不下去，而且我都没买辅导教材（题除外），一般就是打印了一遍网课的讲义，做做笔记这样子，也没感觉有什么不行的，而且很省钱！</li><li>关于习题，我做了两遍题源一千题，但是感觉自己还是很菜，我可能是个榆木脑袋，233333。对了，线代部分没有做，线代部分还得是我永乐大帝的线代笔记。</li><li>10月开始做真题，两天一套，要掐时间做，我做了15年的，可能有点少，时间不大够了，前期花的时间太多了。所以你可以9月就开始了。</li><li>之后就是最后模拟冲刺阶段了，做了李6，李4，张4. 然后基本上就考试了。</li></ol><h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><p>政治我能给你的帮助也不太多，几点建议：</p><ol><li>没必要买肖秀荣三件套，你不会翻几次的，相信我。只需要买肖1000题就够了，练练选择手感。</li><li>网课我推荐徐涛的，听过就知道了，可以后台倍速放着当bgm，玄学：锻炼政治语感。据说腿姐的也不错，我们这年腿姐押题压的很准，可惜我没看，心痛。</li><li>对了，我非常推荐小白考研的小程序，可以刷题。很值得买，强推，而且省钱，连上面的肖1000的钱都省下来了，我感觉省钱这一中心思想，贯穿了我公共课的主线。233333</li><li>最后阶段就是背了，这个背诵肖四的话可以关注一下b站的“空卡”小姐姐，他的背诵视频很有用。</li><li>北京地区的政治确实是存在一定压分情况的，但是你们是一样的，而且你选择中传也调剂的希望不多了，所以压不压分对你一志愿没什么影响，但对你调剂有影响，水区的政治主观题给的真的多一些。</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>最后就是专业课了，数据结构，这部分反而简单了，我的建议，时间足够的话，<strong>王道书+习题三遍</strong>，时间不够也至少要两遍。天勤我没做，这里就不推荐了，想看也可以，但两本书的代码风格完全不一样，很容易乱，推荐选一本看，有时间可以做另一本的题。</p><p>往年真题里有数据结构的，我都建议做，比如821的计网+数据结构 ，还有程序设计里的数据结构题。至少做一遍吧，感受下往年的难度，当练手了吧，最好限时做。</p><p>最后说一下新改的<strong>824数据结构的题型：15道单选，填空，10道判断，10道多选，应用题，代码题。</strong></p><p>总体来说，代码部分有难度，我们甚至考了图的代码题，不能拿这个赌还是要掌握，其次就是多选题很容易失分，我们当初大纲都没写这个，吃了大亏啊。</p><hr><h1 id="复试部分"><a href="#复试部分" class="headerlink" title="复试部分"></a>复试部分</h1><h2 id="总成绩构成"><a href="#总成绩构成" class="headerlink" title="总成绩构成"></a>总成绩构成</h2><p><code>总成绩 = (初试分数/5)*0.6 + 复试成绩(百分制)*0.4</code></p><p><code>复试成绩 = 外语听说成绩*0.1 + 专业知识与综合素养*0.9</code></p><p>也就是说<strong>总成绩的1分=初试的8.333分=复试成绩的2.5分</strong>，这也就意味着你<strong>复试比别人高1分就可以抹平初试3.333分的差距</strong>，复试的重要性不用我多说了吧，所以高别人30分的也不代表你就稳了(特别高的话，当我没说)，还是要好好复习专业课，低分的更要好好复习去逆袭，我自己本身就是个很好的例子。</p><p><img src="https://gitee.com/liuyang0001/blogimage/raw/master/img/20200529113244.png" alt=""></p><h2 id="专业知识与综合素养部分"><a href="#专业知识与综合素养部分" class="headerlink" title="专业知识与综合素养部分"></a>专业知识与综合素养部分</h2><p>这部分分成三部分的考核，首先是一分钟自我介绍，然后是专业课抽题部分，个人感觉这部分占比不是很大，我答成什么样子我心理是有b数的，最后成绩很高，只是后面答得比较好，简历写得比较好。回正题，考试官会让你从<strong>十个编号里选一个作为你挑选的题目</strong>，每个编号里<strong>5</strong>个问题，你可以从中任意<strong>选择3个作答</strong>，我们是网络面试，所以是老师读题，你可以选择回答或者不回答当前问题，不会可以跳过，但最后要回答满三个问题。这五个题，一般情况都是数据结构，计算机网络，操作系统，软件工程各一道，剩下还有一道半开放的问题，比如对人工智能的了解，对深度学习算法的理解，对融媒体的了解之类的。下面是我能记起来的考试时出的问题角度，当时考试太紧张，很多都忘了，只能想起这么多了，仅供参考。</p><p><strong>专业课抽题（5选3）</strong></p><ul><li><p>数据结构——直接排序，归并排序比较</p></li><li><p>计网——时分复用</p></li><li><p>软件工程——类图</p></li></ul><p>最后就是专业课提问的部分，主要是从你的<strong>个人陈述（简历），科研设想部分出题</strong>，所以我想提醒大家的是：<strong>只要是写在你简历上的东西，一定要是自己能有把握回答的东西</strong>，要是被问住了，很影响分数。对了，关于简历部分，最重要的是<strong>突出亮点</strong>，把你最牛逼的，最让人眼前一亮的东西展示出来。对于计算机专业，最重要的肯定是<strong>代码能力</strong>，比如你熟悉什么语言（c/python/java…）,做了哪些<strong>项目</strong>，用到了哪些技术栈，有没有<strong>竞赛获奖</strong>（ACM大佬带带我），或者奖学金，绩点高的也可以写上去(像我一样很低的,还挂了好几科的就算了吧),对了，如果你有博客也可以写上去，也是有加分的。最后再强调一遍，只要是写在你简历上的东西，一定要是自己能有把握回答的东西！不太熟的弄懂，不然就别写，(或者侥幸心里的话这种不太熟的放在后面也行)。</p><p>下面是我面试问到的问题，仅供参考。</p><p><strong>专业课面试提问</strong></p><ol><li>阐述下项目xxx的难点。</li><li>介绍一下另一个项目xxxx?</li><li>在python中你熟悉的库有哪些?</li><li>开放问题——你最熟悉的语言，遇到的问题，如何解决?</li><li>谈一下你的科研设想。</li><li>你为什么要选择大数据方向？</li></ol><h2 id="英语听说能力部分"><a href="#英语听说能力部分" class="headerlink" title="英语听说能力部分"></a>英语听说能力部分</h2><p>这部分<strong>占比很低，也拉不开什么差距</strong>，占复试成绩里的10分，也就是总成绩的4分，基本上不会有超过1分的分差，所以像我这种英语只能过线的水平也不用太过担心。说下流程，主要是两个部分的考核，第一部分是一分钟英语自我介绍，第二部分是十选一抽题作答。第一部分没什么好说的，第二部分主要是一些生活类的话题，或者一些很浅的专业知识相关的问题。重复一下，真的不用担心，拉不开差距的一部分，放轻松把自我介绍背熟就ok了，抽题听不懂的话老师也会给你重复。还听不懂还会用英语给你解释，没问题的，老师都很nice，对了，忘了说，你的考官还是专业面的老师，就是一起考完所有的。自我介绍我写的很水，基本上机器翻译的，给你们做个参考吧。</p><p><strong>一分钟自我介绍</strong></p><p><strong>Good afternoon, respected professors!</strong> </p><p><strong>My name is Liu Yang, 24 years old. I graduated in Electronic Information Engineering from Tianjin Polytechnic University. After  graduation，the more I experienced， the clearer I realized the shortcomings of myself.  I’m eager to learn more about computer science and I hope I can study further in CUC. I am a hard-working  student and I will try my best to finish my project no matter how difficult it is.</strong>  </p><p><strong>Besides ,In my spare time, I would like to write my blog, which is a good way to record what I’ve learned or something interesting in my life.</strong></p><p><strong>I am very glad to be here for this interview. I hope I can make a good performance today. That’s all, Thank you !</strong> </p><p><strong>10选1抽题作答</strong></p><p>在你学习c或者python中，遇到的问题如何解决的?(感觉抽到的和上面老师的重了，但是换成英语了)</p><h2 id="复试名单问题"><a href="#复试名单问题" class="headerlink" title="复试名单问题"></a>复试名单问题</h2><p>中传出的复试名单都是乱序的，所以拿到名单第一时间筛选出有用的部分，从而来判断自己的竞争力还是很有必要的，至少你要知道你在复试中排名多少，前后的分数差距。</p><blockquote><p>​       这是个很好解决的问题，你的考生号都是有规律的，基本上就是：<strong>中传编号+地区号+学院号+方向号+顺序号</strong>，我们需要拿到的有效的数据是：<strong>学院号+方向号</strong>,比如说今年学硕学院号是09，专硕是16，方向号一般为10，20，30这种，根据你们的情况来判断就可以了。会py的可以直接拿我写过的脚本修改一下正则表达式，将名单转成csv格式，然后直接跑就行，不会的就直接Excel搜索也行。脚本文件还有我们这届的复试名单，我放github了，<strong><a href="https://github.com/Liuyang0001/selcet_from_csv/" target="_blank" rel="noopener">脚本传送门</a></strong>。或者给我留言吧，有时间我也可以帮忙，如果我看的到的话。</p></blockquote><hr><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这么又臭又长的流水账能看到这里的应该都是真爱了，祝各位都能如愿上岸！</p><p>有问题留言吧，我看到的话会回的，发邮件也行，对了也可以加群，群里学长很多的，他们说当初收到了很多人的帮助，想要帮助一下下一届，他们真是可爱的人呢。</p><p><strong>群号：1057574055</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文仅仅是我个人的经验贴，记录下考研总结和反思，如果能给你带来一点收获，那就太好了。&lt;/p&gt;
&lt;p&gt;对了，纯主观，不接受反驳。 😃&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://liuyang0001.github.io/categories/Others/"/>
    
    
      <category term="cuc" scheme="https://liuyang0001.github.io/tags/cuc/"/>
    
      <category term="考研" scheme="https://liuyang0001.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>博客更新计划</title>
    <link href="https://liuyang0001.github.io/2020/05/08/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E8%AE%A1%E5%88%92/"/>
    <id>https://liuyang0001.github.io/2020/05/08/博客更新计划/</id>
    <published>2020-05-08T15:41:58.000Z</published>
    <updated>2020-07-24T11:01:58.966Z</updated>
    
    <content type="html"><![CDATA[<p>近期对博客进行调整：</p><p><del>1.加入置顶权重，而不是仅仅依靠时间线来展示顺序。</del>【已完成】</p><p>2.由于最近忙于复试，很多题解没更新也没时间进行整理，打算复试后抽出时间进行整理归纳。【在做了，进度1%】</p><p><del>3.写一个爬虫，用来辅助更新LeetCode的readme，应该不是很难得一个脚本，最近有点懒，抽空写完并把其过程记录下来。</del>【已完成】</p><p><del>4.改变代码块风格，使其不显示行号，同时增加一键复制功能。</del>【已完成】</p><a id="more"></a><p><hr><br>我真的太想念书了，毕竟啊，人菜就要多读书。</p><p>努力提升自己永远都不会出错，加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期对博客进行调整：&lt;/p&gt;
&lt;p&gt;&lt;del&gt;1.加入置顶权重，而不是仅仅依靠时间线来展示顺序。&lt;/del&gt;【已完成】&lt;/p&gt;
&lt;p&gt;2.由于最近忙于复试，很多题解没更新也没时间进行整理，打算复试后抽出时间进行整理归纳。【在做了，进度1%】&lt;/p&gt;
&lt;p&gt;&lt;del&gt;3.写一个爬虫，用来辅助更新LeetCode的readme，应该不是很难得一个脚本，最近有点懒，抽空写完并把其过程记录下来。&lt;/del&gt;【已完成】&lt;/p&gt;
&lt;p&gt;&lt;del&gt;4.改变代码块风格，使其不显示行号，同时增加一键复制功能。&lt;/del&gt;【已完成】&lt;/p&gt;
    
    </summary>
    
      <category term="Python Study Notes" scheme="https://liuyang0001.github.io/categories/Python-Study-Notes/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>筛选复试名单</title>
    <link href="https://liuyang0001.github.io/2020/05/08/%E7%AD%9B%E9%80%89%E5%A4%8D%E8%AF%95%E5%90%8D%E5%8D%95/"/>
    <id>https://liuyang0001.github.io/2020/05/08/筛选复试名单/</id>
    <published>2020-05-08T14:42:05.000Z</published>
    <updated>2020-05-30T10:10:25.478Z</updated>
    
    <content type="html"><![CDATA[<p>今天高高兴兴，因为复试名单公布了，但拿到名单的时候发现是乱序的，那么怎么样才能拿到本专业的真实名单呢？</p><p>所以打算利用所学，来筛选出符合条件的名单，轻松判断自己所处的位置及竞争力。</p><a id="more"></a><hr><h2 id="导入库函数"><a href="#导入库函数" class="headerlink" title="导入库函数"></a>导入库函数</h2><ul><li><code>os</code>  ——用来获取当前路径</li><li><code>re</code>  ——用来正则匹配考生编号</li><li><code>pandas</code> ——用来操作csv，读取和写入</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><hr><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="写出对应的正则表达式"><a href="#写出对应的正则表达式" class="headerlink" title="写出对应的正则表达式"></a>写出对应的正则表达式</h3><ol><li>首先我们需要明确要匹配的字符的构成</li></ol><blockquote><p>考生编号：学校编号+地区号+学院号+方向+流水号</p></blockquote><ol><li>根据需要书写正则表达式</li></ol><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 【计算机专硕】匹配规则</span></span><br><span class="line">pat1 = <span class="string">"^10033[0-9]&#123;4&#125;16[123]0[0-9]&#123;2&#125;$"</span></span><br></pre></td></tr></table></figure><h3 id="读取csv文件"><a href="#读取csv文件" class="headerlink" title="读取csv文件"></a>读取csv文件</h3><p>这里我们是用pandas进行读取文件，将其格式化为df类型。</p><blockquote><p><strong>需要注意的是：windows默认的编码方式为gbk，而不是utf-8</strong></p></blockquote><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(read_path, encoding=<span class="string">"gbk"</span>) <span class="keyword">as</span> file:</span><br><span class="line">        data = pd.read_csv(file)</span><br></pre></td></tr></table></figure><h3 id="取得对应的考生编号，并匹配"><a href="#取得对应的考生编号，并匹配" class="headerlink" title="取得对应的考生编号，并匹配"></a>取得对应的考生编号，并匹配</h3><p>取得第i行的第一列元素，将其转换成字符串，便于后续对其进行正则匹配</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取到15位准考证号</span></span><br><span class="line">number = data.iloc[[i], <span class="number">0</span>].to_string()[<span class="number">-15</span>:]</span><br></pre></td></tr></table></figure><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><p>利用<code>re.match()</code>进行匹配，判断当前是否为我们所查找的。</p><p>如果匹配，则取到该行的所有元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> re.match(rule, number):</span><br><span class="line">df = data.iloc[[i], :]</span><br></pre></td></tr></table></figure><h3 id="输出到csv文件"><a href="#输出到csv文件" class="headerlink" title="输出到csv文件"></a>输出到csv文件</h3><p>pandas的df类型数据直接就有输出到csv文件的方法，直接调用输出即可。</p><blockquote><p>不过有几点需要注意：</p><ol><li>输出依旧要采用gbk编码</li><li>索引值要置为False，不然会多一列我们并不想要的原先数据的索引列</li><li>输出模式要选择附加模式，这样不会覆盖原数据</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_csv(write_path, mode=<span class="string">"a"</span>, index=<span class="keyword">False</span>,header=<span class="keyword">None</span>, encoding=<span class="string">"gbk"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a><center>源码</center></h2><p><strong><center><a href="https://github.com/Liuyang0001/selcet_from_csv/" target="_blank" rel="noopener">Github项目源码地址</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天高高兴兴，因为复试名单公布了，但拿到名单的时候发现是乱序的，那么怎么样才能拿到本专业的真实名单呢？&lt;/p&gt;
&lt;p&gt;所以打算利用所学，来筛选出符合条件的名单，轻松判断自己所处的位置及竞争力。&lt;/p&gt;
    
    </summary>
    
      <category term="Python Study Notes" scheme="https://liuyang0001.github.io/categories/Python-Study-Notes/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="pandas" scheme="https://liuyang0001.github.io/tags/pandas/"/>
    
      <category term="re" scheme="https://liuyang0001.github.io/tags/re/"/>
    
      <category term="csv" scheme="https://liuyang0001.github.io/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>100-相同的树</title>
    <link href="https://liuyang0001.github.io/2020/04/01/100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>https://liuyang0001.github.io/2020/04/01/100-相同的树/</id>
    <published>2020-04-01T08:40:24.000Z</published>
    <updated>2020-04-01T09:46:56.381Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：两棵树同步递归遍历相比较即可。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 两个空结点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># 结点均非空且值相等</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> q <span class="keyword">and</span> p.val == q.val:</span><br><span class="line">            <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/same-tree/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/same-tree/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个二叉树，编写一个函数来检验它们是否相同。&lt;/p&gt;
&lt;p&gt;如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://liuyang0001.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>99-恢复二叉搜索树</title>
    <link href="https://liuyang0001.github.io/2020/04/01/99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://liuyang0001.github.io/2020/04/01/99-恢复二叉搜索树/</id>
    <published>2020-04-01T08:40:11.000Z</published>
    <updated>2020-04-01T09:45:12.751Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  /</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">输出: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  3</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：两次利用中序遍历该树，第一次遍历为扫描结点值，第二次遍历为把排序后的结点值依次填入。</strong></p><p><strong>注意：取排序后的列表值，不能使用pop()</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tree = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root,flag)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left,flag)</span><br><span class="line">            <span class="keyword">if</span> flag==<span class="string">"traverse"</span>:</span><br><span class="line">                tree.append(root.val)</span><br><span class="line">            <span class="keyword">elif</span> flag == <span class="string">"modify"</span>:</span><br><span class="line">                <span class="comment"># 注意:这里不能使用pop()</span></span><br><span class="line">                <span class="comment"># 排序不会改变pop的顺序</span></span><br><span class="line">                root.val = tree[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">del</span> tree[<span class="number">0</span>]</span><br><span class="line">            helper(root.right, flag)</span><br><span class="line">        <span class="comment"># 先遍历</span></span><br><span class="line">        helper(root, flag=<span class="string">"traverse"</span>)</span><br><span class="line">        <span class="comment"># 排序</span></span><br><span class="line">        tree.sort()</span><br><span class="line">        <span class="comment"># 再替换</span></span><br><span class="line">        helper(root, flag=<span class="string">"modify"</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://liuyang0001.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>98-验证二叉搜索树</title>
    <link href="https://liuyang0001.github.io/2020/04/01/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://liuyang0001.github.io/2020/04/01/98-验证二叉搜索树/</id>
    <published>2020-04-01T08:17:41.000Z</published>
    <updated>2020-04-01T09:41:09.095Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><a id="more"></a><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：中序遍历该树，得到的数列有序即可证明是一颗二叉排序树</strong></p><p><strong>注意：得到的数列应该无重复字符</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        tree = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            tree.append(root.val)</span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="comment"># print(tree,sorted(tree))</span></span><br><span class="line">        <span class="comment"># 需判断是否存在重复结点</span></span><br><span class="line">        <span class="keyword">return</span> tree==sorted(tree) <span class="keyword">and</span> len(set(tree))==len(tree)</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://liuyang0001.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>96-不同的二叉搜索树</title>
    <link href="https://liuyang0001.github.io/2020/04/01/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://liuyang0001.github.io/2020/04/01/96-不同的二叉搜索树/</id>
    <published>2020-04-01T08:08:16.000Z</published>
    <updated>2020-04-01T09:37:45.057Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：卡特兰数问题，典型的dp解决</strong></p></blockquote><p><img src="https://github.com/Liuyang0001/liuyang0001.github.io/tree/master/images/image-98.png" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp_list = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp_list[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp_list[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                dp_list[i] += dp_list[j]*dp_list[i-j<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp_list[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，求以 1 … &lt;em&gt;n&lt;/em&gt; 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="动态规划" scheme="https://liuyang0001.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>95-不同的二叉搜索树-ii</title>
    <link href="https://liuyang0001.github.io/2020/04/01/95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-ii/"/>
    <id>https://liuyang0001.github.io/2020/04/01/95-不同的二叉搜索树-ii/</id>
    <published>2020-04-01T08:02:03.000Z</published>
    <updated>2020-04-01T09:28:14.345Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的<strong>二叉搜索树</strong>。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释:</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用二叉搜索树的性质，左子树只能比当前结点小，右子树只能比当前结点大。每个结点均有可能做为根结点。</strong></p><p><strong>技巧点：利用lru_cache收集每一个返回的值</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># Notice：返回值应为List[TreeNode]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 收集每次的返回值，组成缓存列表,None为动态调节大小</span></span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(start, end)</span>:</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                res.append(<span class="keyword">None</span>)</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 左子树均小于val</span></span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> helper(start, val - <span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 右子树均大于val</span></span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> helper(val + <span class="number">1</span>, end):</span><br><span class="line">                        <span class="comment"># 构建树节点</span></span><br><span class="line">                        root = TreeNode(val,left,right)</span><br><span class="line">                        res.append(root)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，生成所有由 1 … &lt;em&gt;n&lt;/em&gt; 为节点所组成的&lt;strong&gt;二叉搜索树&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="动态规划" scheme="https://liuyang0001.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>94-二叉树的中序遍历</title>
    <link href="https://liuyang0001.github.io/2020/04/01/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://liuyang0001.github.io/2020/04/01/94-二叉树的中序遍历/</id>
    <published>2020-04-01T07:56:56.000Z</published>
    <updated>2020-04-01T09:23:10.931Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用递归算法即可</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个二叉树，返回它的&lt;em&gt;中序&lt;/em&gt; 遍历。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="树" scheme="https://liuyang0001.github.io/tags/%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://liuyang0001.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>93-复原ip地址</title>
    <link href="https://liuyang0001.github.io/2020/04/01/93-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/"/>
    <id>https://liuyang0001.github.io/2020/04/01/93-复原ip地址/</id>
    <published>2020-04-01T07:52:04.000Z</published>
    <updated>2020-04-01T09:20:22.717Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;25525511135&quot;</span><br><span class="line">输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：回溯算法：利用分割4次之后剩余的字符串是否为空，来界定是不是有效的结果</strong></p><p><strong>count记录分割次数, ip记录当前的字符串, s记录剩余字符串</strong></p><p><strong>注意：分割一次加一个“.”，最后会多出一个点号</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># count记录分割次数, ip记录当前的字符串, s记录剩余字符串</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(count, ip, s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> s==<span class="string">""</span>: <span class="comment"># 最后面会有个点号</span></span><br><span class="line">                    res.append(ip[:<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">0</span>: <span class="comment"># 需考虑[0.0.0.0]的情况</span></span><br><span class="line">                backtrack(count + <span class="number">1</span>, ip + s[:<span class="number">1</span>] + <span class="string">"."</span>, s[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">"0"</span>:</span><br><span class="line">                backtrack(count + <span class="number">1</span>, ip + s[:<span class="number">2</span>] + <span class="string">"."</span>, s[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">2</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">"0"</span> <span class="keyword">and</span> int(s[:<span class="number">3</span>]) &lt; <span class="number">256</span>:</span><br><span class="line">                backtrack(count + <span class="number">1</span>, ip + s[:<span class="number">3</span>] + <span class="string">"."</span>, s[<span class="number">3</span>:])</span><br><span class="line">                </span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="string">""</span>, s)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/restore-ip-addresses/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>92-反转链表</title>
    <link href="https://liuyang0001.github.io/2020/04/01/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://liuyang0001.github.io/2020/04/01/92-反转链表/</id>
    <published>2020-04-01T07:49:17.000Z</published>
    <updated>2020-04-01T09:14:16.193Z</updated>
    
    <content type="html"><![CDATA[<p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p><a id="more"></a><p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：需要翻转的部分使用头插法即可</strong></p><p><strong>技巧：在原链表添加一个头部，更便于操作</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="comment"># 找到翻转链表部分的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="comment"># print("pre:", pre.val)</span></span><br><span class="line">        rear1 = pre <span class="comment"># 翻转部分的前一个结点</span></span><br><span class="line">        rear2 = pre.next <span class="comment"># 翻转部分的第一个结点，翻转后为尾结点</span></span><br><span class="line">        cur_node = pre.next</span><br><span class="line">        <span class="comment"># 翻转部分的头结点</span></span><br><span class="line">        dummy2 = ListNode(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n-m+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 头插法翻转链表</span></span><br><span class="line">            save_node = cur_node.next</span><br><span class="line">            cur_node.next = dummy2.next</span><br><span class="line">            dummy2.next = cur_node</span><br><span class="line">            cur_node = save_node</span><br><span class="line">        <span class="comment"># 拼接</span></span><br><span class="line">        rear2.next = cur_node</span><br><span class="line">        rear1.next = dummy2.next</span><br><span class="line">        <span class="comment"># head结点可能已经改变，返回头结点的下一节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转从位置 &lt;em&gt;m&lt;/em&gt; 到 &lt;em&gt;n&lt;/em&gt; 的链表。请使用一趟扫描完成反转。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>91-解码方法</title>
    <link href="https://liuyang0001.github.io/2020/04/01/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>https://liuyang0001.github.io/2020/04/01/91-解码方法/</id>
    <published>2020-04-01T07:31:17.000Z</published>
    <updated>2020-05-08T14:43:16.385Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包含数字的<strong>非空</strong>字符串，请计算解码方法的总数。</p><a id="more"></a><p>一条包含字母 <code>A-Z</code> 的消息通过以下方式进行了编码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;12&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;226&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用动态规划的思想，利用前两位来更新当前位置</strong></p></blockquote><p><strong>算法设计如下：</strong></p><ul><li><p>特判，若s为空或者s[0]==”0”，返回0</p></li><li><p>初始化dp=[0,…,0]，长度为n+1，dp[0]=1,dp[1]=1。dp[1]=1表示第一位的解码方法，dp[0]的作用，在于两位时，如：”12”，dp[2]=dp[1]+dp[0]。</p></li><li><p>遍历s，遍历区间[1,n)：</p><ul><li>若s[i]==”0”：<ul><li>若<code>s[i-1]==&quot;1&quot; or s[i-1]==&quot;2&quot;</code>：<ul><li>此时，到当前位置的解码方法dp[i+1]和上上一位的相同，</li><li>因为上一位和本位置结合在了一起。dp[i+1]=dp[i-1]</li></ul></li><li>否则，返回0，表示无法解码</li></ul></li><li>否则：<ul><li>判断何时既可以自身解码也可以和前一位结合：</li><li>若上一位s[i-1]==”1”，则当前位既可以单独解码也可以和上一位结合。</li><li>或者上一位s[i]==”2”，则此时，若1”&lt;=s[i]&lt;=”6”，也是可以的。</li><li>综上，<code>s[i-1]==&quot;1&quot; or (s[i-1]==&quot;2&quot; and &quot;1&quot;&lt;=s[i]&lt;=&quot;6&quot;)</code>。</li><li>此时，dp[i+1]=dp[i]+dp[i-1]，等于上一位和上上位的解码方法之和。</li><li>否则，dp[i+1]=dp[i]</li></ul></li></ul></li><li><p>返回dp[n]</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">"0"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">"0"</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">"1"</span> <span class="keyword">or</span> s[i - <span class="number">1</span>] == <span class="string">"2"</span>:</span><br><span class="line">                    dp[i + <span class="number">1</span>] = dp[i - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">"1"</span> <span class="keyword">or</span> (s[i - <span class="number">1</span>] == <span class="string">"2"</span> <span class="keyword">and</span> <span class="string">"1"</span> &lt;= s[i] &lt;= <span class="string">"6"</span>):</span><br><span class="line">                    dp[i + <span class="number">1</span>] = dp[i] + dp[i - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i + <span class="number">1</span>] = dp[i]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/decode-ways/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/decode-ways/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个只包含数字的&lt;strong&gt;非空&lt;/strong&gt;字符串，请计算解码方法的总数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="字符串" scheme="https://liuyang0001.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="动态规划" scheme="https://liuyang0001.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>90-子集II</title>
    <link href="https://liuyang0001.github.io/2020/03/30/90-%E5%AD%90%E9%9B%86II/"/>
    <id>https://liuyang0001.github.io/2020/03/30/90-子集II/</id>
    <published>2020-03-30T10:45:31.000Z</published>
    <updated>2020-03-30T15:37:01.540Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p><a id="more"></a><p><strong>说明：</strong>解集不能包含重复的子集。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：利用回溯算法，</strong></p><p><strong>关键点：去重—-&gt;【排序+当前值与上一个值判断】</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(index, tem)</span>:</span></span><br><span class="line">            res.append(tem)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, n):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                backtrack(i + <span class="number">1</span>, tem + [nums[i]])</span><br><span class="line">        backtrack(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/subsets-ii/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/subsets-ii/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个可能包含重复元素的整数数组 &lt;strong&gt;&lt;em&gt;nums&lt;/em&gt;&lt;/strong&gt;，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>89-格雷编码</title>
    <link href="https://liuyang0001.github.io/2020/03/30/89-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"/>
    <id>https://liuyang0001.github.io/2020/03/30/89-格雷编码/</id>
    <published>2020-03-30T10:43:52.000Z</published>
    <updated>2020-03-30T15:33:22.782Z</updated>
    
    <content type="html"><![CDATA[<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 <em>n</em>，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,3,2]</span><br><span class="line">解释:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br><span class="line"></span><br><span class="line">对于给定的 n，其格雷编码序列并不唯一。</span><br><span class="line">例如，[0,2,3,1] 也是一个有效的格雷编码序列。</span><br><span class="line"></span><br><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 0 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。</span><br><span class="line">     因此，当 n = 0 时，其格雷编码序列为 [0]。</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：第n个格雷码：G(n) = (n&gt;&gt;1) OXR n，即最高位保留，其他位相异或</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span> ** n):</span><br><span class="line">            <span class="comment"># 最高位保留，其他位异或操作</span></span><br><span class="line">            res.append(i ^ (i &gt;&gt; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/gray-code/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/gray-code/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。&lt;/p&gt;
&lt;p&gt;给定一个代表编码总位数的非负整数 &lt;em&gt;n&lt;/em&gt;，打印其格雷编码序列。格雷编码序列必须以 0 开头。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="回溯算法" scheme="https://liuyang0001.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="https://liuyang0001.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>88-合并两个有序数组</title>
    <link href="https://liuyang0001.github.io/2020/03/30/88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://liuyang0001.github.io/2020/03/30/88-合并两个有序数组/</id>
    <published>2020-03-30T10:41:42.000Z</published>
    <updated>2020-03-30T12:29:49.129Z</updated>
    
    <content type="html"><![CDATA[<p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，请你将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>num1</em> 成为一个有序数组。</p><a id="more"></a><p><strong>说明:</strong></p><ul><li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em> 。</li><li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：先合并，在排序。</strong></p><p><strong>坑：有的0有效有的0无效，所以第一个列表有效部分直接取[:-m]</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums2)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        nums =nums1[:-n] + nums2</span><br><span class="line">        nums1[:] = sorted(nums)</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/merge-sorted-array/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给你两个有序整数数组 &lt;em&gt;nums1&lt;/em&gt; 和 &lt;em&gt;nums2&lt;/em&gt;，请你将 &lt;em&gt;nums2&lt;/em&gt; 合并到 &lt;em&gt;nums1&lt;/em&gt; 中&lt;em&gt;，&lt;/em&gt;使 &lt;em&gt;num1&lt;/em&gt; 成为一个有序数组。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="数组" scheme="https://liuyang0001.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>86-分隔链表</title>
    <link href="https://liuyang0001.github.io/2020/03/30/86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://liuyang0001.github.io/2020/03/30/86-分隔链表/</id>
    <published>2020-03-30T10:38:20.000Z</published>
    <updated>2020-03-30T11:23:05.084Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure><hr><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>核心思想：x为边界，拆分成两个链表处理，最后在合在一起即可。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        p = head</span><br><span class="line">        p1 = head1 = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p2 = head2 = ListNode(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">while</span> p != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; x:</span><br><span class="line">                p1.next = p</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2.next = p</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        p1.next = head2.next</span><br><span class="line">        p2.next = <span class="keyword">None</span> <span class="comment"># 尾边界</span></span><br><span class="line">        <span class="keyword">del</span> head2</span><br><span class="line">        <span class="keyword">return</span> head1.next</span><br></pre></td></tr></table></figure><hr><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a><center>相关信息</center></h2><p><strong><center>LeetCode：<a href="https://leetcode-cn.com/problems/partition-list/comments/" target="_blank" rel="noopener">Discussion</a> | <a href="https://leetcode-cn.com/problems/partition-list/solution/" target="_blank" rel="noopener">Solution</a></center></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个链表和一个特定值 &lt;em&gt;x&lt;/em&gt;，对链表进行分隔，使得所有小于 &lt;em&gt;x&lt;/em&gt; 的节点都在大于或等于 &lt;em&gt;x&lt;/em&gt; 的节点之前。&lt;/p&gt;
&lt;p&gt;你应当保留两个分区中每个节点的初始相对位置。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://liuyang0001.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://liuyang0001.github.io/tags/Python/"/>
    
      <category term="Algorithms" scheme="https://liuyang0001.github.io/tags/Algorithms/"/>
    
      <category term="双指针" scheme="https://liuyang0001.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="https://liuyang0001.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
